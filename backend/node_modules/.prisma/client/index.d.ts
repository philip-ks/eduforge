
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Program
 * *
 *  * Student domain profile (already in your system)
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model FacultyProfile
 * *
 *  * Faculty domain profile (NEW)
 *  * - Connected to User (role=FACULTY)
 *  * - Admin assigns department/designation; faculty fills personal info
 */
export type FacultyProfile = $Result.DefaultSelection<Prisma.$FacultyProfilePayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Designation
 * 
 */
export type Designation = $Result.DefaultSelection<Prisma.$DesignationPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model FacultySubject
 * 
 */
export type FacultySubject = $Result.DefaultSelection<Prisma.$FacultySubjectPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseOffering
 * *
 *  * CourseOffering now references FacultyProfile (login-enabled faculty)
 */
export type CourseOffering = $Result.DefaultSelection<Prisma.$CourseOfferingPayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model AttendanceSession
 * 
 */
export type AttendanceSession = $Result.DefaultSelection<Prisma.$AttendanceSessionPayload>
/**
 * Model AttendanceMark
 * 
 */
export type AttendanceMark = $Result.DefaultSelection<Prisma.$AttendanceMarkPayload>
/**
 * Model LibraryBook
 * 
 */
export type LibraryBook = $Result.DefaultSelection<Prisma.$LibraryBookPayload>
/**
 * Model LibraryCopy
 * 
 */
export type LibraryCopy = $Result.DefaultSelection<Prisma.$LibraryCopyPayload>
/**
 * Model LibraryIssue
 * 
 */
export type LibraryIssue = $Result.DefaultSelection<Prisma.$LibraryIssuePayload>
/**
 * Model Request
 * 
 */
export type Request = $Result.DefaultSelection<Prisma.$RequestPayload>
/**
 * Model StudentSetting
 * 
 */
export type StudentSetting = $Result.DefaultSelection<Prisma.$StudentSettingPayload>
/**
 * Model FeeAccount
 * 
 */
export type FeeAccount = $Result.DefaultSelection<Prisma.$FeeAccountPayload>
/**
 * Model FeeCharge
 * 
 */
export type FeeCharge = $Result.DefaultSelection<Prisma.$FeeChargePayload>
/**
 * Model FeePayment
 * 
 */
export type FeePayment = $Result.DefaultSelection<Prisma.$FeePaymentPayload>
/**
 * Model Counter
 * 
 */
export type Counter = $Result.DefaultSelection<Prisma.$CounterPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  STUDENT: 'STUDENT',
  FACULTY: 'FACULTY',
  INSTITUTION_ADMIN: 'INSTITUTION_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const RequestStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  CLOSED: 'CLOSED'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const AttendanceMarkStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LEAVE: 'LEAVE',
  MEDICAL: 'MEDICAL'
};

export type AttendanceMarkStatus = (typeof AttendanceMarkStatus)[keyof typeof AttendanceMarkStatus]


export const LibraryCopyStatus: {
  AVAILABLE: 'AVAILABLE',
  ISSUED: 'ISSUED',
  LOST: 'LOST',
  DAMAGED: 'DAMAGED'
};

export type LibraryCopyStatus = (typeof LibraryCopyStatus)[keyof typeof LibraryCopyStatus]


export const LibraryIssueStatus: {
  ISSUED: 'ISSUED',
  RETURNED: 'RETURNED',
  OVERDUE: 'OVERDUE',
  LOST: 'LOST'
};

export type LibraryIssueStatus = (typeof LibraryIssueStatus)[keyof typeof LibraryIssueStatus]


export const Theme: {
  SYSTEM: 'SYSTEM',
  LIGHT: 'LIGHT',
  DARK: 'DARK'
};

export type Theme = (typeof Theme)[keyof typeof Theme]


export const ProfileVisibility: {
  CAMPUS_ONLY: 'CAMPUS_ONLY',
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE'
};

export type ProfileVisibility = (typeof ProfileVisibility)[keyof typeof ProfileVisibility]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type AttendanceMarkStatus = $Enums.AttendanceMarkStatus

export const AttendanceMarkStatus: typeof $Enums.AttendanceMarkStatus

export type LibraryCopyStatus = $Enums.LibraryCopyStatus

export const LibraryCopyStatus: typeof $Enums.LibraryCopyStatus

export type LibraryIssueStatus = $Enums.LibraryIssueStatus

export const LibraryIssueStatus: typeof $Enums.LibraryIssueStatus

export type Theme = $Enums.Theme

export const Theme: typeof $Enums.Theme

export type ProfileVisibility = $Enums.ProfileVisibility

export const ProfileVisibility: typeof $Enums.ProfileVisibility

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facultyProfile`: Exposes CRUD operations for the **FacultyProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacultyProfiles
    * const facultyProfiles = await prisma.facultyProfile.findMany()
    * ```
    */
  get facultyProfile(): Prisma.FacultyProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.designation`: Exposes CRUD operations for the **Designation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Designations
    * const designations = await prisma.designation.findMany()
    * ```
    */
  get designation(): Prisma.DesignationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facultySubject`: Exposes CRUD operations for the **FacultySubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacultySubjects
    * const facultySubjects = await prisma.facultySubject.findMany()
    * ```
    */
  get facultySubject(): Prisma.FacultySubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseOffering`: Exposes CRUD operations for the **CourseOffering** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseOfferings
    * const courseOfferings = await prisma.courseOffering.findMany()
    * ```
    */
  get courseOffering(): Prisma.CourseOfferingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceSession`: Exposes CRUD operations for the **AttendanceSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceSessions
    * const attendanceSessions = await prisma.attendanceSession.findMany()
    * ```
    */
  get attendanceSession(): Prisma.AttendanceSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceMark`: Exposes CRUD operations for the **AttendanceMark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceMarks
    * const attendanceMarks = await prisma.attendanceMark.findMany()
    * ```
    */
  get attendanceMark(): Prisma.AttendanceMarkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.libraryBook`: Exposes CRUD operations for the **LibraryBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBooks
    * const libraryBooks = await prisma.libraryBook.findMany()
    * ```
    */
  get libraryBook(): Prisma.LibraryBookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.libraryCopy`: Exposes CRUD operations for the **LibraryCopy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryCopies
    * const libraryCopies = await prisma.libraryCopy.findMany()
    * ```
    */
  get libraryCopy(): Prisma.LibraryCopyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.libraryIssue`: Exposes CRUD operations for the **LibraryIssue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryIssues
    * const libraryIssues = await prisma.libraryIssue.findMany()
    * ```
    */
  get libraryIssue(): Prisma.LibraryIssueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.request`: Exposes CRUD operations for the **Request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requests
    * const requests = await prisma.request.findMany()
    * ```
    */
  get request(): Prisma.RequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentSetting`: Exposes CRUD operations for the **StudentSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSettings
    * const studentSettings = await prisma.studentSetting.findMany()
    * ```
    */
  get studentSetting(): Prisma.StudentSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeAccount`: Exposes CRUD operations for the **FeeAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeAccounts
    * const feeAccounts = await prisma.feeAccount.findMany()
    * ```
    */
  get feeAccount(): Prisma.FeeAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeCharge`: Exposes CRUD operations for the **FeeCharge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeCharges
    * const feeCharges = await prisma.feeCharge.findMany()
    * ```
    */
  get feeCharge(): Prisma.FeeChargeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feePayment`: Exposes CRUD operations for the **FeePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeePayments
    * const feePayments = await prisma.feePayment.findMany()
    * ```
    */
  get feePayment(): Prisma.FeePaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.counter`: Exposes CRUD operations for the **Counter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counters
    * const counters = await prisma.counter.findMany()
    * ```
    */
  get counter(): Prisma.CounterDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Program: 'Program',
    Student: 'Student',
    FacultyProfile: 'FacultyProfile',
    Department: 'Department',
    Designation: 'Designation',
    Subject: 'Subject',
    FacultySubject: 'FacultySubject',
    Course: 'Course',
    CourseOffering: 'CourseOffering',
    Enrollment: 'Enrollment',
    AttendanceSession: 'AttendanceSession',
    AttendanceMark: 'AttendanceMark',
    LibraryBook: 'LibraryBook',
    LibraryCopy: 'LibraryCopy',
    LibraryIssue: 'LibraryIssue',
    Request: 'Request',
    StudentSetting: 'StudentSetting',
    FeeAccount: 'FeeAccount',
    FeeCharge: 'FeeCharge',
    FeePayment: 'FeePayment',
    Counter: 'Counter'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "program" | "student" | "facultyProfile" | "department" | "designation" | "subject" | "facultySubject" | "course" | "courseOffering" | "enrollment" | "attendanceSession" | "attendanceMark" | "libraryBook" | "libraryCopy" | "libraryIssue" | "request" | "studentSetting" | "feeAccount" | "feeCharge" | "feePayment" | "counter"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      FacultyProfile: {
        payload: Prisma.$FacultyProfilePayload<ExtArgs>
        fields: Prisma.FacultyProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultyProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultyProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload>
          }
          findFirst: {
            args: Prisma.FacultyProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultyProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload>
          }
          findMany: {
            args: Prisma.FacultyProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload>[]
          }
          create: {
            args: Prisma.FacultyProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload>
          }
          createMany: {
            args: Prisma.FacultyProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacultyProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload>[]
          }
          delete: {
            args: Prisma.FacultyProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload>
          }
          update: {
            args: Prisma.FacultyProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload>
          }
          deleteMany: {
            args: Prisma.FacultyProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacultyProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacultyProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload>[]
          }
          upsert: {
            args: Prisma.FacultyProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyProfilePayload>
          }
          aggregate: {
            args: Prisma.FacultyProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacultyProfile>
          }
          groupBy: {
            args: Prisma.FacultyProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultyProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultyProfileCountArgs<ExtArgs>
            result: $Utils.Optional<FacultyProfileCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Designation: {
        payload: Prisma.$DesignationPayload<ExtArgs>
        fields: Prisma.DesignationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesignationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesignationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          findFirst: {
            args: Prisma.DesignationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesignationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          findMany: {
            args: Prisma.DesignationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>[]
          }
          create: {
            args: Prisma.DesignationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          createMany: {
            args: Prisma.DesignationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DesignationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>[]
          }
          delete: {
            args: Prisma.DesignationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          update: {
            args: Prisma.DesignationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          deleteMany: {
            args: Prisma.DesignationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DesignationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DesignationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>[]
          }
          upsert: {
            args: Prisma.DesignationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DesignationPayload>
          }
          aggregate: {
            args: Prisma.DesignationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesignation>
          }
          groupBy: {
            args: Prisma.DesignationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesignationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesignationCountArgs<ExtArgs>
            result: $Utils.Optional<DesignationCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      FacultySubject: {
        payload: Prisma.$FacultySubjectPayload<ExtArgs>
        fields: Prisma.FacultySubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultySubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultySubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload>
          }
          findFirst: {
            args: Prisma.FacultySubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultySubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload>
          }
          findMany: {
            args: Prisma.FacultySubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload>[]
          }
          create: {
            args: Prisma.FacultySubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload>
          }
          createMany: {
            args: Prisma.FacultySubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacultySubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload>[]
          }
          delete: {
            args: Prisma.FacultySubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload>
          }
          update: {
            args: Prisma.FacultySubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload>
          }
          deleteMany: {
            args: Prisma.FacultySubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacultySubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacultySubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload>[]
          }
          upsert: {
            args: Prisma.FacultySubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultySubjectPayload>
          }
          aggregate: {
            args: Prisma.FacultySubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacultySubject>
          }
          groupBy: {
            args: Prisma.FacultySubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultySubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultySubjectCountArgs<ExtArgs>
            result: $Utils.Optional<FacultySubjectCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseOffering: {
        payload: Prisma.$CourseOfferingPayload<ExtArgs>
        fields: Prisma.CourseOfferingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseOfferingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseOfferingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          findFirst: {
            args: Prisma.CourseOfferingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseOfferingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          findMany: {
            args: Prisma.CourseOfferingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>[]
          }
          create: {
            args: Prisma.CourseOfferingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          createMany: {
            args: Prisma.CourseOfferingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseOfferingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>[]
          }
          delete: {
            args: Prisma.CourseOfferingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          update: {
            args: Prisma.CourseOfferingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          deleteMany: {
            args: Prisma.CourseOfferingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseOfferingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseOfferingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>[]
          }
          upsert: {
            args: Prisma.CourseOfferingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseOfferingPayload>
          }
          aggregate: {
            args: Prisma.CourseOfferingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseOffering>
          }
          groupBy: {
            args: Prisma.CourseOfferingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseOfferingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseOfferingCountArgs<ExtArgs>
            result: $Utils.Optional<CourseOfferingCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      AttendanceSession: {
        payload: Prisma.$AttendanceSessionPayload<ExtArgs>
        fields: Prisma.AttendanceSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload>
          }
          findFirst: {
            args: Prisma.AttendanceSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload>
          }
          findMany: {
            args: Prisma.AttendanceSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload>[]
          }
          create: {
            args: Prisma.AttendanceSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload>
          }
          createMany: {
            args: Prisma.AttendanceSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload>[]
          }
          delete: {
            args: Prisma.AttendanceSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload>
          }
          update: {
            args: Prisma.AttendanceSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSessionPayload>
          }
          aggregate: {
            args: Prisma.AttendanceSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceSession>
          }
          groupBy: {
            args: Prisma.AttendanceSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceSessionCountAggregateOutputType> | number
          }
        }
      }
      AttendanceMark: {
        payload: Prisma.$AttendanceMarkPayload<ExtArgs>
        fields: Prisma.AttendanceMarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceMarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceMarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload>
          }
          findFirst: {
            args: Prisma.AttendanceMarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceMarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload>
          }
          findMany: {
            args: Prisma.AttendanceMarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload>[]
          }
          create: {
            args: Prisma.AttendanceMarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload>
          }
          createMany: {
            args: Prisma.AttendanceMarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceMarkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload>[]
          }
          delete: {
            args: Prisma.AttendanceMarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload>
          }
          update: {
            args: Prisma.AttendanceMarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceMarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceMarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceMarkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceMarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceMarkPayload>
          }
          aggregate: {
            args: Prisma.AttendanceMarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceMark>
          }
          groupBy: {
            args: Prisma.AttendanceMarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceMarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceMarkCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceMarkCountAggregateOutputType> | number
          }
        }
      }
      LibraryBook: {
        payload: Prisma.$LibraryBookPayload<ExtArgs>
        fields: Prisma.LibraryBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LibraryBookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryBookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>
          }
          findFirst: {
            args: Prisma.LibraryBookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryBookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>
          }
          findMany: {
            args: Prisma.LibraryBookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>[]
          }
          create: {
            args: Prisma.LibraryBookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>
          }
          createMany: {
            args: Prisma.LibraryBookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LibraryBookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>[]
          }
          delete: {
            args: Prisma.LibraryBookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>
          }
          update: {
            args: Prisma.LibraryBookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>
          }
          deleteMany: {
            args: Prisma.LibraryBookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryBookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LibraryBookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>[]
          }
          upsert: {
            args: Prisma.LibraryBookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryBookPayload>
          }
          aggregate: {
            args: Prisma.LibraryBookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLibraryBook>
          }
          groupBy: {
            args: Prisma.LibraryBookGroupByArgs<ExtArgs>
            result: $Utils.Optional<LibraryBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryBookCountArgs<ExtArgs>
            result: $Utils.Optional<LibraryBookCountAggregateOutputType> | number
          }
        }
      }
      LibraryCopy: {
        payload: Prisma.$LibraryCopyPayload<ExtArgs>
        fields: Prisma.LibraryCopyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LibraryCopyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryCopyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload>
          }
          findFirst: {
            args: Prisma.LibraryCopyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryCopyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload>
          }
          findMany: {
            args: Prisma.LibraryCopyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload>[]
          }
          create: {
            args: Prisma.LibraryCopyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload>
          }
          createMany: {
            args: Prisma.LibraryCopyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LibraryCopyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload>[]
          }
          delete: {
            args: Prisma.LibraryCopyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload>
          }
          update: {
            args: Prisma.LibraryCopyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload>
          }
          deleteMany: {
            args: Prisma.LibraryCopyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryCopyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LibraryCopyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload>[]
          }
          upsert: {
            args: Prisma.LibraryCopyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryCopyPayload>
          }
          aggregate: {
            args: Prisma.LibraryCopyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLibraryCopy>
          }
          groupBy: {
            args: Prisma.LibraryCopyGroupByArgs<ExtArgs>
            result: $Utils.Optional<LibraryCopyGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryCopyCountArgs<ExtArgs>
            result: $Utils.Optional<LibraryCopyCountAggregateOutputType> | number
          }
        }
      }
      LibraryIssue: {
        payload: Prisma.$LibraryIssuePayload<ExtArgs>
        fields: Prisma.LibraryIssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LibraryIssueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryIssueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload>
          }
          findFirst: {
            args: Prisma.LibraryIssueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryIssueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload>
          }
          findMany: {
            args: Prisma.LibraryIssueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload>[]
          }
          create: {
            args: Prisma.LibraryIssueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload>
          }
          createMany: {
            args: Prisma.LibraryIssueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LibraryIssueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload>[]
          }
          delete: {
            args: Prisma.LibraryIssueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload>
          }
          update: {
            args: Prisma.LibraryIssueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload>
          }
          deleteMany: {
            args: Prisma.LibraryIssueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryIssueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LibraryIssueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload>[]
          }
          upsert: {
            args: Prisma.LibraryIssueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LibraryIssuePayload>
          }
          aggregate: {
            args: Prisma.LibraryIssueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLibraryIssue>
          }
          groupBy: {
            args: Prisma.LibraryIssueGroupByArgs<ExtArgs>
            result: $Utils.Optional<LibraryIssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryIssueCountArgs<ExtArgs>
            result: $Utils.Optional<LibraryIssueCountAggregateOutputType> | number
          }
        }
      }
      Request: {
        payload: Prisma.$RequestPayload<ExtArgs>
        fields: Prisma.RequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          findFirst: {
            args: Prisma.RequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          findMany: {
            args: Prisma.RequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          create: {
            args: Prisma.RequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          createMany: {
            args: Prisma.RequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          delete: {
            args: Prisma.RequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          update: {
            args: Prisma.RequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          deleteMany: {
            args: Prisma.RequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          upsert: {
            args: Prisma.RequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          aggregate: {
            args: Prisma.RequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequest>
          }
          groupBy: {
            args: Prisma.RequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestCountArgs<ExtArgs>
            result: $Utils.Optional<RequestCountAggregateOutputType> | number
          }
        }
      }
      StudentSetting: {
        payload: Prisma.$StudentSettingPayload<ExtArgs>
        fields: Prisma.StudentSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload>
          }
          findFirst: {
            args: Prisma.StudentSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload>
          }
          findMany: {
            args: Prisma.StudentSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload>[]
          }
          create: {
            args: Prisma.StudentSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload>
          }
          createMany: {
            args: Prisma.StudentSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload>[]
          }
          delete: {
            args: Prisma.StudentSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload>
          }
          update: {
            args: Prisma.StudentSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload>
          }
          deleteMany: {
            args: Prisma.StudentSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload>[]
          }
          upsert: {
            args: Prisma.StudentSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSettingPayload>
          }
          aggregate: {
            args: Prisma.StudentSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSetting>
          }
          groupBy: {
            args: Prisma.StudentSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSettingCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSettingCountAggregateOutputType> | number
          }
        }
      }
      FeeAccount: {
        payload: Prisma.$FeeAccountPayload<ExtArgs>
        fields: Prisma.FeeAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload>
          }
          findFirst: {
            args: Prisma.FeeAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload>
          }
          findMany: {
            args: Prisma.FeeAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload>[]
          }
          create: {
            args: Prisma.FeeAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload>
          }
          createMany: {
            args: Prisma.FeeAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload>[]
          }
          delete: {
            args: Prisma.FeeAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload>
          }
          update: {
            args: Prisma.FeeAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload>
          }
          deleteMany: {
            args: Prisma.FeeAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload>[]
          }
          upsert: {
            args: Prisma.FeeAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeAccountPayload>
          }
          aggregate: {
            args: Prisma.FeeAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeAccount>
          }
          groupBy: {
            args: Prisma.FeeAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeAccountCountArgs<ExtArgs>
            result: $Utils.Optional<FeeAccountCountAggregateOutputType> | number
          }
        }
      }
      FeeCharge: {
        payload: Prisma.$FeeChargePayload<ExtArgs>
        fields: Prisma.FeeChargeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeChargeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeChargeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload>
          }
          findFirst: {
            args: Prisma.FeeChargeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeChargeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload>
          }
          findMany: {
            args: Prisma.FeeChargeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload>[]
          }
          create: {
            args: Prisma.FeeChargeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload>
          }
          createMany: {
            args: Prisma.FeeChargeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeChargeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload>[]
          }
          delete: {
            args: Prisma.FeeChargeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload>
          }
          update: {
            args: Prisma.FeeChargeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload>
          }
          deleteMany: {
            args: Prisma.FeeChargeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeChargeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeChargeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload>[]
          }
          upsert: {
            args: Prisma.FeeChargeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeChargePayload>
          }
          aggregate: {
            args: Prisma.FeeChargeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeCharge>
          }
          groupBy: {
            args: Prisma.FeeChargeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeChargeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeChargeCountArgs<ExtArgs>
            result: $Utils.Optional<FeeChargeCountAggregateOutputType> | number
          }
        }
      }
      FeePayment: {
        payload: Prisma.$FeePaymentPayload<ExtArgs>
        fields: Prisma.FeePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          findFirst: {
            args: Prisma.FeePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          findMany: {
            args: Prisma.FeePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>[]
          }
          create: {
            args: Prisma.FeePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          createMany: {
            args: Prisma.FeePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>[]
          }
          delete: {
            args: Prisma.FeePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          update: {
            args: Prisma.FeePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          deleteMany: {
            args: Prisma.FeePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeePaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>[]
          }
          upsert: {
            args: Prisma.FeePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          aggregate: {
            args: Prisma.FeePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeePayment>
          }
          groupBy: {
            args: Prisma.FeePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<FeePaymentCountAggregateOutputType> | number
          }
        }
      }
      Counter: {
        payload: Prisma.$CounterPayload<ExtArgs>
        fields: Prisma.CounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload>
          }
          findFirst: {
            args: Prisma.CounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload>
          }
          findMany: {
            args: Prisma.CounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload>[]
          }
          create: {
            args: Prisma.CounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload>
          }
          createMany: {
            args: Prisma.CounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload>[]
          }
          delete: {
            args: Prisma.CounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload>
          }
          update: {
            args: Prisma.CounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload>
          }
          deleteMany: {
            args: Prisma.CounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CounterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload>[]
          }
          upsert: {
            args: Prisma.CounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterPayload>
          }
          aggregate: {
            args: Prisma.CounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounter>
          }
          groupBy: {
            args: Prisma.CounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CounterCountArgs<ExtArgs>
            result: $Utils.Optional<CounterCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    program?: ProgramOmit
    student?: StudentOmit
    facultyProfile?: FacultyProfileOmit
    department?: DepartmentOmit
    designation?: DesignationOmit
    subject?: SubjectOmit
    facultySubject?: FacultySubjectOmit
    course?: CourseOmit
    courseOffering?: CourseOfferingOmit
    enrollment?: EnrollmentOmit
    attendanceSession?: AttendanceSessionOmit
    attendanceMark?: AttendanceMarkOmit
    libraryBook?: LibraryBookOmit
    libraryCopy?: LibraryCopyOmit
    libraryIssue?: LibraryIssueOmit
    request?: RequestOmit
    studentSetting?: StudentSettingOmit
    feeAccount?: FeeAccountOmit
    feeCharge?: FeeChargeOmit
    feePayment?: FeePaymentOmit
    counter?: CounterOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    students: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | ProgramCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    enrollments: number
    attendanceMarks: number
    libraryIssues: number
    requests: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | StudentCountOutputTypeCountEnrollmentsArgs
    attendanceMarks?: boolean | StudentCountOutputTypeCountAttendanceMarksArgs
    libraryIssues?: boolean | StudentCountOutputTypeCountLibraryIssuesArgs
    requests?: boolean | StudentCountOutputTypeCountRequestsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendanceMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceMarkWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountLibraryIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryIssueWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
  }


  /**
   * Count Type FacultyProfileCountOutputType
   */

  export type FacultyProfileCountOutputType = {
    offerings: number
    subjects: number
  }

  export type FacultyProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offerings?: boolean | FacultyProfileCountOutputTypeCountOfferingsArgs
    subjects?: boolean | FacultyProfileCountOutputTypeCountSubjectsArgs
  }

  // Custom InputTypes
  /**
   * FacultyProfileCountOutputType without action
   */
  export type FacultyProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfileCountOutputType
     */
    select?: FacultyProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacultyProfileCountOutputType without action
   */
  export type FacultyProfileCountOutputTypeCountOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseOfferingWhereInput
  }

  /**
   * FacultyProfileCountOutputType without action
   */
  export type FacultyProfileCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultySubjectWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    designations: number
    subjects: number
    faculty: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designations?: boolean | DepartmentCountOutputTypeCountDesignationsArgs
    subjects?: boolean | DepartmentCountOutputTypeCountSubjectsArgs
    faculty?: boolean | DepartmentCountOutputTypeCountFacultyArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountDesignationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignationWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountFacultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyProfileWhereInput
  }


  /**
   * Count Type DesignationCountOutputType
   */

  export type DesignationCountOutputType = {
    faculty: number
  }

  export type DesignationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | DesignationCountOutputTypeCountFacultyArgs
  }

  // Custom InputTypes
  /**
   * DesignationCountOutputType without action
   */
  export type DesignationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesignationCountOutputType
     */
    select?: DesignationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DesignationCountOutputType without action
   */
  export type DesignationCountOutputTypeCountFacultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyProfileWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    faculty: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | SubjectCountOutputTypeCountFacultyArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountFacultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultySubjectWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    offerings: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offerings?: boolean | CourseCountOutputTypeCountOfferingsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountOfferingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseOfferingWhereInput
  }


  /**
   * Count Type CourseOfferingCountOutputType
   */

  export type CourseOfferingCountOutputType = {
    enrollments: number
    sessions: number
  }

  export type CourseOfferingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | CourseOfferingCountOutputTypeCountEnrollmentsArgs
    sessions?: boolean | CourseOfferingCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * CourseOfferingCountOutputType without action
   */
  export type CourseOfferingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOfferingCountOutputType
     */
    select?: CourseOfferingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseOfferingCountOutputType without action
   */
  export type CourseOfferingCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * CourseOfferingCountOutputType without action
   */
  export type CourseOfferingCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSessionWhereInput
  }


  /**
   * Count Type AttendanceSessionCountOutputType
   */

  export type AttendanceSessionCountOutputType = {
    marks: number
  }

  export type AttendanceSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marks?: boolean | AttendanceSessionCountOutputTypeCountMarksArgs
  }

  // Custom InputTypes
  /**
   * AttendanceSessionCountOutputType without action
   */
  export type AttendanceSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSessionCountOutputType
     */
    select?: AttendanceSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttendanceSessionCountOutputType without action
   */
  export type AttendanceSessionCountOutputTypeCountMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceMarkWhereInput
  }


  /**
   * Count Type LibraryBookCountOutputType
   */

  export type LibraryBookCountOutputType = {
    copies: number
  }

  export type LibraryBookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    copies?: boolean | LibraryBookCountOutputTypeCountCopiesArgs
  }

  // Custom InputTypes
  /**
   * LibraryBookCountOutputType without action
   */
  export type LibraryBookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBookCountOutputType
     */
    select?: LibraryBookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LibraryBookCountOutputType without action
   */
  export type LibraryBookCountOutputTypeCountCopiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryCopyWhereInput
  }


  /**
   * Count Type LibraryCopyCountOutputType
   */

  export type LibraryCopyCountOutputType = {
    issues: number
  }

  export type LibraryCopyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issues?: boolean | LibraryCopyCountOutputTypeCountIssuesArgs
  }

  // Custom InputTypes
  /**
   * LibraryCopyCountOutputType without action
   */
  export type LibraryCopyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopyCountOutputType
     */
    select?: LibraryCopyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LibraryCopyCountOutputType without action
   */
  export type LibraryCopyCountOutputTypeCountIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryIssueWhereInput
  }


  /**
   * Count Type FeeAccountCountOutputType
   */

  export type FeeAccountCountOutputType = {
    charges: number
    payments: number
  }

  export type FeeAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    charges?: boolean | FeeAccountCountOutputTypeCountChargesArgs
    payments?: boolean | FeeAccountCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * FeeAccountCountOutputType without action
   */
  export type FeeAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccountCountOutputType
     */
    select?: FeeAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeeAccountCountOutputType without action
   */
  export type FeeAccountCountOutputTypeCountChargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeChargeWhereInput
  }

  /**
   * FeeAccountCountOutputType without action
   */
  export type FeeAccountCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeePaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    role: $Enums.UserRole | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    role: $Enums.UserRole | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    role: number
    email: number
    phone: number
    passwordHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    role?: true
    email?: true
    phone?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    role?: true
    email?: true
    phone?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    role?: true
    email?: true
    phone?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    role: $Enums.UserRole
    email: string | null
    phone: string | null
    passwordHash: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | User$studentArgs<ExtArgs>
    faculty?: boolean | User$facultyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "email" | "phone" | "passwordHash" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | User$studentArgs<ExtArgs>
    faculty?: boolean | User$facultyArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
      faculty: Prisma.$FacultyProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.UserRole
      email: string | null
      phone: string | null
      passwordHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    faculty<T extends User$facultyArgs<ExtArgs> = {}>(args?: Subset<T, User$facultyArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.faculty
   */
  export type User$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    where?: FacultyProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ProgramCountAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    students?: boolean | Program$studentsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["program"]>
  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | Program$studentsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      students: Prisma.$StudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs and returns the data updated in the database.
     * @param {ProgramUpdateManyAndReturnArgs} args - Arguments to update many Programs.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends Program$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Program$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'String'>
    readonly name: FieldRef<"Program", 'String'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updatedAt: FieldRef<"Program", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
  }

  /**
   * Program createManyAndReturn
   */
  export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program updateManyAndReturn
   */
  export type ProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to delete.
     */
    limit?: number
  }

  /**
   * Program.students
   */
  export type Program$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    semester: number | null
  }

  export type StudentSumAggregateOutputType = {
    semester: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    displayId: string | null
    fullName: string | null
    programId: string | null
    semester: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    displayId: string | null
    fullName: string | null
    programId: string | null
    semester: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    displayId: number
    fullName: number
    programId: number
    semester: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    semester?: true
  }

  export type StudentSumAggregateInputType = {
    semester?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    displayId?: true
    fullName?: true
    programId?: true
    semester?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    displayId?: true
    fullName?: true
    programId?: true
    semester?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    displayId?: true
    fullName?: true
    programId?: true
    semester?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    displayId: string
    fullName: string
    programId: string
    semester: number
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayId?: boolean
    fullName?: boolean
    programId?: boolean
    semester?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    attendanceMarks?: boolean | Student$attendanceMarksArgs<ExtArgs>
    libraryIssues?: boolean | Student$libraryIssuesArgs<ExtArgs>
    requests?: boolean | Student$requestsArgs<ExtArgs>
    settings?: boolean | Student$settingsArgs<ExtArgs>
    feeAccount?: boolean | Student$feeAccountArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayId?: boolean
    fullName?: boolean
    programId?: boolean
    semester?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayId?: boolean
    fullName?: boolean
    programId?: boolean
    semester?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    displayId?: boolean
    fullName?: boolean
    programId?: boolean
    semester?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "displayId" | "fullName" | "programId" | "semester" | "createdAt" | "updatedAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    attendanceMarks?: boolean | Student$attendanceMarksArgs<ExtArgs>
    libraryIssues?: boolean | Student$libraryIssuesArgs<ExtArgs>
    requests?: boolean | Student$requestsArgs<ExtArgs>
    settings?: boolean | Student$settingsArgs<ExtArgs>
    feeAccount?: boolean | Student$feeAccountArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      program: Prisma.$ProgramPayload<ExtArgs>
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      attendanceMarks: Prisma.$AttendanceMarkPayload<ExtArgs>[]
      libraryIssues: Prisma.$LibraryIssuePayload<ExtArgs>[]
      requests: Prisma.$RequestPayload<ExtArgs>[]
      settings: Prisma.$StudentSettingPayload<ExtArgs> | null
      feeAccount: Prisma.$FeeAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      displayId: string
      fullName: string
      programId: string
      semester: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    enrollments<T extends Student$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceMarks<T extends Student$attendanceMarksArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendanceMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    libraryIssues<T extends Student$libraryIssuesArgs<ExtArgs> = {}>(args?: Subset<T, Student$libraryIssuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requests<T extends Student$requestsArgs<ExtArgs> = {}>(args?: Subset<T, Student$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends Student$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Student$settingsArgs<ExtArgs>>): Prisma__StudentSettingClient<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    feeAccount<T extends Student$feeAccountArgs<ExtArgs> = {}>(args?: Subset<T, Student$feeAccountArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly displayId: FieldRef<"Student", 'String'>
    readonly fullName: FieldRef<"Student", 'String'>
    readonly programId: FieldRef<"Student", 'String'>
    readonly semester: FieldRef<"Student", 'Int'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.enrollments
   */
  export type Student$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Student.attendanceMarks
   */
  export type Student$attendanceMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    where?: AttendanceMarkWhereInput
    orderBy?: AttendanceMarkOrderByWithRelationInput | AttendanceMarkOrderByWithRelationInput[]
    cursor?: AttendanceMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceMarkScalarFieldEnum | AttendanceMarkScalarFieldEnum[]
  }

  /**
   * Student.libraryIssues
   */
  export type Student$libraryIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    where?: LibraryIssueWhereInput
    orderBy?: LibraryIssueOrderByWithRelationInput | LibraryIssueOrderByWithRelationInput[]
    cursor?: LibraryIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LibraryIssueScalarFieldEnum | LibraryIssueScalarFieldEnum[]
  }

  /**
   * Student.requests
   */
  export type Student$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    cursor?: RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Student.settings
   */
  export type Student$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
    where?: StudentSettingWhereInput
  }

  /**
   * Student.feeAccount
   */
  export type Student$feeAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
    where?: FeeAccountWhereInput
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model FacultyProfile
   */

  export type AggregateFacultyProfile = {
    _count: FacultyProfileCountAggregateOutputType | null
    _min: FacultyProfileMinAggregateOutputType | null
    _max: FacultyProfileMaxAggregateOutputType | null
  }

  export type FacultyProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    employeeCode: string | null
    departmentId: string | null
    designationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacultyProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    employeeCode: string | null
    departmentId: string | null
    designationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacultyProfileCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    employeeCode: number
    departmentId: number
    designationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacultyProfileMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    employeeCode?: true
    departmentId?: true
    designationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacultyProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    employeeCode?: true
    departmentId?: true
    designationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacultyProfileCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    employeeCode?: true
    departmentId?: true
    designationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacultyProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacultyProfile to aggregate.
     */
    where?: FacultyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyProfiles to fetch.
     */
    orderBy?: FacultyProfileOrderByWithRelationInput | FacultyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacultyProfiles
    **/
    _count?: true | FacultyProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyProfileMaxAggregateInputType
  }

  export type GetFacultyProfileAggregateType<T extends FacultyProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateFacultyProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacultyProfile[P]>
      : GetScalarType<T[P], AggregateFacultyProfile[P]>
  }




  export type FacultyProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyProfileWhereInput
    orderBy?: FacultyProfileOrderByWithAggregationInput | FacultyProfileOrderByWithAggregationInput[]
    by: FacultyProfileScalarFieldEnum[] | FacultyProfileScalarFieldEnum
    having?: FacultyProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyProfileCountAggregateInputType | true
    _min?: FacultyProfileMinAggregateInputType
    _max?: FacultyProfileMaxAggregateInputType
  }

  export type FacultyProfileGroupByOutputType = {
    id: string
    userId: string
    fullName: string | null
    employeeCode: string | null
    departmentId: string | null
    designationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FacultyProfileCountAggregateOutputType | null
    _min: FacultyProfileMinAggregateOutputType | null
    _max: FacultyProfileMaxAggregateOutputType | null
  }

  type GetFacultyProfileGroupByPayload<T extends FacultyProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyProfileGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyProfileGroupByOutputType[P]>
        }
      >
    >


  export type FacultyProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    employeeCode?: boolean
    departmentId?: boolean
    designationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | FacultyProfile$departmentArgs<ExtArgs>
    designation?: boolean | FacultyProfile$designationArgs<ExtArgs>
    offerings?: boolean | FacultyProfile$offeringsArgs<ExtArgs>
    subjects?: boolean | FacultyProfile$subjectsArgs<ExtArgs>
    _count?: boolean | FacultyProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facultyProfile"]>

  export type FacultyProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    employeeCode?: boolean
    departmentId?: boolean
    designationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | FacultyProfile$departmentArgs<ExtArgs>
    designation?: boolean | FacultyProfile$designationArgs<ExtArgs>
  }, ExtArgs["result"]["facultyProfile"]>

  export type FacultyProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    employeeCode?: boolean
    departmentId?: boolean
    designationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | FacultyProfile$departmentArgs<ExtArgs>
    designation?: boolean | FacultyProfile$designationArgs<ExtArgs>
  }, ExtArgs["result"]["facultyProfile"]>

  export type FacultyProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    employeeCode?: boolean
    departmentId?: boolean
    designationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FacultyProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "fullName" | "employeeCode" | "departmentId" | "designationId" | "createdAt" | "updatedAt", ExtArgs["result"]["facultyProfile"]>
  export type FacultyProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | FacultyProfile$departmentArgs<ExtArgs>
    designation?: boolean | FacultyProfile$designationArgs<ExtArgs>
    offerings?: boolean | FacultyProfile$offeringsArgs<ExtArgs>
    subjects?: boolean | FacultyProfile$subjectsArgs<ExtArgs>
    _count?: boolean | FacultyProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacultyProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | FacultyProfile$departmentArgs<ExtArgs>
    designation?: boolean | FacultyProfile$designationArgs<ExtArgs>
  }
  export type FacultyProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | FacultyProfile$departmentArgs<ExtArgs>
    designation?: boolean | FacultyProfile$designationArgs<ExtArgs>
  }

  export type $FacultyProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacultyProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      designation: Prisma.$DesignationPayload<ExtArgs> | null
      offerings: Prisma.$CourseOfferingPayload<ExtArgs>[]
      subjects: Prisma.$FacultySubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fullName: string | null
      employeeCode: string | null
      departmentId: string | null
      designationId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["facultyProfile"]>
    composites: {}
  }

  type FacultyProfileGetPayload<S extends boolean | null | undefined | FacultyProfileDefaultArgs> = $Result.GetResult<Prisma.$FacultyProfilePayload, S>

  type FacultyProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacultyProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacultyProfileCountAggregateInputType | true
    }

  export interface FacultyProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacultyProfile'], meta: { name: 'FacultyProfile' } }
    /**
     * Find zero or one FacultyProfile that matches the filter.
     * @param {FacultyProfileFindUniqueArgs} args - Arguments to find a FacultyProfile
     * @example
     * // Get one FacultyProfile
     * const facultyProfile = await prisma.facultyProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultyProfileFindUniqueArgs>(args: SelectSubset<T, FacultyProfileFindUniqueArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacultyProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacultyProfileFindUniqueOrThrowArgs} args - Arguments to find a FacultyProfile
     * @example
     * // Get one FacultyProfile
     * const facultyProfile = await prisma.facultyProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultyProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, FacultyProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacultyProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyProfileFindFirstArgs} args - Arguments to find a FacultyProfile
     * @example
     * // Get one FacultyProfile
     * const facultyProfile = await prisma.facultyProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultyProfileFindFirstArgs>(args?: SelectSubset<T, FacultyProfileFindFirstArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacultyProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyProfileFindFirstOrThrowArgs} args - Arguments to find a FacultyProfile
     * @example
     * // Get one FacultyProfile
     * const facultyProfile = await prisma.facultyProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultyProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, FacultyProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacultyProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacultyProfiles
     * const facultyProfiles = await prisma.facultyProfile.findMany()
     * 
     * // Get first 10 FacultyProfiles
     * const facultyProfiles = await prisma.facultyProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facultyProfileWithIdOnly = await prisma.facultyProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacultyProfileFindManyArgs>(args?: SelectSubset<T, FacultyProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacultyProfile.
     * @param {FacultyProfileCreateArgs} args - Arguments to create a FacultyProfile.
     * @example
     * // Create one FacultyProfile
     * const FacultyProfile = await prisma.facultyProfile.create({
     *   data: {
     *     // ... data to create a FacultyProfile
     *   }
     * })
     * 
     */
    create<T extends FacultyProfileCreateArgs>(args: SelectSubset<T, FacultyProfileCreateArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacultyProfiles.
     * @param {FacultyProfileCreateManyArgs} args - Arguments to create many FacultyProfiles.
     * @example
     * // Create many FacultyProfiles
     * const facultyProfile = await prisma.facultyProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacultyProfileCreateManyArgs>(args?: SelectSubset<T, FacultyProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacultyProfiles and returns the data saved in the database.
     * @param {FacultyProfileCreateManyAndReturnArgs} args - Arguments to create many FacultyProfiles.
     * @example
     * // Create many FacultyProfiles
     * const facultyProfile = await prisma.facultyProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacultyProfiles and only return the `id`
     * const facultyProfileWithIdOnly = await prisma.facultyProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacultyProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, FacultyProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacultyProfile.
     * @param {FacultyProfileDeleteArgs} args - Arguments to delete one FacultyProfile.
     * @example
     * // Delete one FacultyProfile
     * const FacultyProfile = await prisma.facultyProfile.delete({
     *   where: {
     *     // ... filter to delete one FacultyProfile
     *   }
     * })
     * 
     */
    delete<T extends FacultyProfileDeleteArgs>(args: SelectSubset<T, FacultyProfileDeleteArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacultyProfile.
     * @param {FacultyProfileUpdateArgs} args - Arguments to update one FacultyProfile.
     * @example
     * // Update one FacultyProfile
     * const facultyProfile = await prisma.facultyProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacultyProfileUpdateArgs>(args: SelectSubset<T, FacultyProfileUpdateArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacultyProfiles.
     * @param {FacultyProfileDeleteManyArgs} args - Arguments to filter FacultyProfiles to delete.
     * @example
     * // Delete a few FacultyProfiles
     * const { count } = await prisma.facultyProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacultyProfileDeleteManyArgs>(args?: SelectSubset<T, FacultyProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacultyProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacultyProfiles
     * const facultyProfile = await prisma.facultyProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacultyProfileUpdateManyArgs>(args: SelectSubset<T, FacultyProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacultyProfiles and returns the data updated in the database.
     * @param {FacultyProfileUpdateManyAndReturnArgs} args - Arguments to update many FacultyProfiles.
     * @example
     * // Update many FacultyProfiles
     * const facultyProfile = await prisma.facultyProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacultyProfiles and only return the `id`
     * const facultyProfileWithIdOnly = await prisma.facultyProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacultyProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, FacultyProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacultyProfile.
     * @param {FacultyProfileUpsertArgs} args - Arguments to update or create a FacultyProfile.
     * @example
     * // Update or create a FacultyProfile
     * const facultyProfile = await prisma.facultyProfile.upsert({
     *   create: {
     *     // ... data to create a FacultyProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacultyProfile we want to update
     *   }
     * })
     */
    upsert<T extends FacultyProfileUpsertArgs>(args: SelectSubset<T, FacultyProfileUpsertArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacultyProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyProfileCountArgs} args - Arguments to filter FacultyProfiles to count.
     * @example
     * // Count the number of FacultyProfiles
     * const count = await prisma.facultyProfile.count({
     *   where: {
     *     // ... the filter for the FacultyProfiles we want to count
     *   }
     * })
    **/
    count<T extends FacultyProfileCountArgs>(
      args?: Subset<T, FacultyProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacultyProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyProfileAggregateArgs>(args: Subset<T, FacultyProfileAggregateArgs>): Prisma.PrismaPromise<GetFacultyProfileAggregateType<T>>

    /**
     * Group by FacultyProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyProfileGroupByArgs['orderBy'] }
        : { orderBy?: FacultyProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacultyProfile model
   */
  readonly fields: FacultyProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacultyProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends FacultyProfile$departmentArgs<ExtArgs> = {}>(args?: Subset<T, FacultyProfile$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    designation<T extends FacultyProfile$designationArgs<ExtArgs> = {}>(args?: Subset<T, FacultyProfile$designationArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    offerings<T extends FacultyProfile$offeringsArgs<ExtArgs> = {}>(args?: Subset<T, FacultyProfile$offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends FacultyProfile$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, FacultyProfile$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacultyProfile model
   */
  interface FacultyProfileFieldRefs {
    readonly id: FieldRef<"FacultyProfile", 'String'>
    readonly userId: FieldRef<"FacultyProfile", 'String'>
    readonly fullName: FieldRef<"FacultyProfile", 'String'>
    readonly employeeCode: FieldRef<"FacultyProfile", 'String'>
    readonly departmentId: FieldRef<"FacultyProfile", 'String'>
    readonly designationId: FieldRef<"FacultyProfile", 'String'>
    readonly createdAt: FieldRef<"FacultyProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"FacultyProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacultyProfile findUnique
   */
  export type FacultyProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    /**
     * Filter, which FacultyProfile to fetch.
     */
    where: FacultyProfileWhereUniqueInput
  }

  /**
   * FacultyProfile findUniqueOrThrow
   */
  export type FacultyProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    /**
     * Filter, which FacultyProfile to fetch.
     */
    where: FacultyProfileWhereUniqueInput
  }

  /**
   * FacultyProfile findFirst
   */
  export type FacultyProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    /**
     * Filter, which FacultyProfile to fetch.
     */
    where?: FacultyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyProfiles to fetch.
     */
    orderBy?: FacultyProfileOrderByWithRelationInput | FacultyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacultyProfiles.
     */
    cursor?: FacultyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacultyProfiles.
     */
    distinct?: FacultyProfileScalarFieldEnum | FacultyProfileScalarFieldEnum[]
  }

  /**
   * FacultyProfile findFirstOrThrow
   */
  export type FacultyProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    /**
     * Filter, which FacultyProfile to fetch.
     */
    where?: FacultyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyProfiles to fetch.
     */
    orderBy?: FacultyProfileOrderByWithRelationInput | FacultyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacultyProfiles.
     */
    cursor?: FacultyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacultyProfiles.
     */
    distinct?: FacultyProfileScalarFieldEnum | FacultyProfileScalarFieldEnum[]
  }

  /**
   * FacultyProfile findMany
   */
  export type FacultyProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    /**
     * Filter, which FacultyProfiles to fetch.
     */
    where?: FacultyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultyProfiles to fetch.
     */
    orderBy?: FacultyProfileOrderByWithRelationInput | FacultyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacultyProfiles.
     */
    cursor?: FacultyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultyProfiles.
     */
    skip?: number
    distinct?: FacultyProfileScalarFieldEnum | FacultyProfileScalarFieldEnum[]
  }

  /**
   * FacultyProfile create
   */
  export type FacultyProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a FacultyProfile.
     */
    data: XOR<FacultyProfileCreateInput, FacultyProfileUncheckedCreateInput>
  }

  /**
   * FacultyProfile createMany
   */
  export type FacultyProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacultyProfiles.
     */
    data: FacultyProfileCreateManyInput | FacultyProfileCreateManyInput[]
  }

  /**
   * FacultyProfile createManyAndReturn
   */
  export type FacultyProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * The data used to create many FacultyProfiles.
     */
    data: FacultyProfileCreateManyInput | FacultyProfileCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacultyProfile update
   */
  export type FacultyProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a FacultyProfile.
     */
    data: XOR<FacultyProfileUpdateInput, FacultyProfileUncheckedUpdateInput>
    /**
     * Choose, which FacultyProfile to update.
     */
    where: FacultyProfileWhereUniqueInput
  }

  /**
   * FacultyProfile updateMany
   */
  export type FacultyProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacultyProfiles.
     */
    data: XOR<FacultyProfileUpdateManyMutationInput, FacultyProfileUncheckedUpdateManyInput>
    /**
     * Filter which FacultyProfiles to update
     */
    where?: FacultyProfileWhereInput
    /**
     * Limit how many FacultyProfiles to update.
     */
    limit?: number
  }

  /**
   * FacultyProfile updateManyAndReturn
   */
  export type FacultyProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * The data used to update FacultyProfiles.
     */
    data: XOR<FacultyProfileUpdateManyMutationInput, FacultyProfileUncheckedUpdateManyInput>
    /**
     * Filter which FacultyProfiles to update
     */
    where?: FacultyProfileWhereInput
    /**
     * Limit how many FacultyProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacultyProfile upsert
   */
  export type FacultyProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the FacultyProfile to update in case it exists.
     */
    where: FacultyProfileWhereUniqueInput
    /**
     * In case the FacultyProfile found by the `where` argument doesn't exist, create a new FacultyProfile with this data.
     */
    create: XOR<FacultyProfileCreateInput, FacultyProfileUncheckedCreateInput>
    /**
     * In case the FacultyProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyProfileUpdateInput, FacultyProfileUncheckedUpdateInput>
  }

  /**
   * FacultyProfile delete
   */
  export type FacultyProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    /**
     * Filter which FacultyProfile to delete.
     */
    where: FacultyProfileWhereUniqueInput
  }

  /**
   * FacultyProfile deleteMany
   */
  export type FacultyProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacultyProfiles to delete
     */
    where?: FacultyProfileWhereInput
    /**
     * Limit how many FacultyProfiles to delete.
     */
    limit?: number
  }

  /**
   * FacultyProfile.department
   */
  export type FacultyProfile$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * FacultyProfile.designation
   */
  export type FacultyProfile$designationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    where?: DesignationWhereInput
  }

  /**
   * FacultyProfile.offerings
   */
  export type FacultyProfile$offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    where?: CourseOfferingWhereInput
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    cursor?: CourseOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * FacultyProfile.subjects
   */
  export type FacultyProfile$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    where?: FacultySubjectWhereInput
    orderBy?: FacultySubjectOrderByWithRelationInput | FacultySubjectOrderByWithRelationInput[]
    cursor?: FacultySubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultySubjectScalarFieldEnum | FacultySubjectScalarFieldEnum[]
  }

  /**
   * FacultyProfile without action
   */
  export type FacultyProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    code: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    code: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    designations?: boolean | Department$designationsArgs<ExtArgs>
    subjects?: boolean | Department$subjectsArgs<ExtArgs>
    faculty?: boolean | Department$facultyArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    designations?: boolean | Department$designationsArgs<ExtArgs>
    subjects?: boolean | Department$subjectsArgs<ExtArgs>
    faculty?: boolean | Department$facultyArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      designations: Prisma.$DesignationPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      faculty: Prisma.$FacultyProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    designations<T extends Department$designationsArgs<ExtArgs> = {}>(args?: Subset<T, Department$designationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends Department$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Department$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faculty<T extends Department$facultyArgs<ExtArgs> = {}>(args?: Subset<T, Department$facultyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
    readonly isActive: FieldRef<"Department", 'Boolean'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.designations
   */
  export type Department$designationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    where?: DesignationWhereInput
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    cursor?: DesignationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Department.subjects
   */
  export type Department$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Department.faculty
   */
  export type Department$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    where?: FacultyProfileWhereInput
    orderBy?: FacultyProfileOrderByWithRelationInput | FacultyProfileOrderByWithRelationInput[]
    cursor?: FacultyProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyProfileScalarFieldEnum | FacultyProfileScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Designation
   */

  export type AggregateDesignation = {
    _count: DesignationCountAggregateOutputType | null
    _avg: DesignationAvgAggregateOutputType | null
    _sum: DesignationSumAggregateOutputType | null
    _min: DesignationMinAggregateOutputType | null
    _max: DesignationMaxAggregateOutputType | null
  }

  export type DesignationAvgAggregateOutputType = {
    level: number | null
  }

  export type DesignationSumAggregateOutputType = {
    level: number | null
  }

  export type DesignationMinAggregateOutputType = {
    id: string | null
    departmentId: string | null
    title: string | null
    level: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignationMaxAggregateOutputType = {
    id: string | null
    departmentId: string | null
    title: string | null
    level: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DesignationCountAggregateOutputType = {
    id: number
    departmentId: number
    title: number
    level: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DesignationAvgAggregateInputType = {
    level?: true
  }

  export type DesignationSumAggregateInputType = {
    level?: true
  }

  export type DesignationMinAggregateInputType = {
    id?: true
    departmentId?: true
    title?: true
    level?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignationMaxAggregateInputType = {
    id?: true
    departmentId?: true
    title?: true
    level?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DesignationCountAggregateInputType = {
    id?: true
    departmentId?: true
    title?: true
    level?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DesignationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Designation to aggregate.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Designations
    **/
    _count?: true | DesignationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesignationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesignationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesignationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesignationMaxAggregateInputType
  }

  export type GetDesignationAggregateType<T extends DesignationAggregateArgs> = {
        [P in keyof T & keyof AggregateDesignation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesignation[P]>
      : GetScalarType<T[P], AggregateDesignation[P]>
  }




  export type DesignationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesignationWhereInput
    orderBy?: DesignationOrderByWithAggregationInput | DesignationOrderByWithAggregationInput[]
    by: DesignationScalarFieldEnum[] | DesignationScalarFieldEnum
    having?: DesignationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesignationCountAggregateInputType | true
    _avg?: DesignationAvgAggregateInputType
    _sum?: DesignationSumAggregateInputType
    _min?: DesignationMinAggregateInputType
    _max?: DesignationMaxAggregateInputType
  }

  export type DesignationGroupByOutputType = {
    id: string
    departmentId: string
    title: string
    level: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DesignationCountAggregateOutputType | null
    _avg: DesignationAvgAggregateOutputType | null
    _sum: DesignationSumAggregateOutputType | null
    _min: DesignationMinAggregateOutputType | null
    _max: DesignationMaxAggregateOutputType | null
  }

  type GetDesignationGroupByPayload<T extends DesignationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesignationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesignationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesignationGroupByOutputType[P]>
            : GetScalarType<T[P], DesignationGroupByOutputType[P]>
        }
      >
    >


  export type DesignationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    title?: boolean
    level?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    faculty?: boolean | Designation$facultyArgs<ExtArgs>
    _count?: boolean | DesignationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designation"]>

  export type DesignationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    title?: boolean
    level?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designation"]>

  export type DesignationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    title?: boolean
    level?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["designation"]>

  export type DesignationSelectScalar = {
    id?: boolean
    departmentId?: boolean
    title?: boolean
    level?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DesignationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "departmentId" | "title" | "level" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["designation"]>
  export type DesignationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    faculty?: boolean | Designation$facultyArgs<ExtArgs>
    _count?: boolean | DesignationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DesignationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type DesignationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $DesignationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Designation"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      faculty: Prisma.$FacultyProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      departmentId: string
      title: string
      level: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["designation"]>
    composites: {}
  }

  type DesignationGetPayload<S extends boolean | null | undefined | DesignationDefaultArgs> = $Result.GetResult<Prisma.$DesignationPayload, S>

  type DesignationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DesignationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesignationCountAggregateInputType | true
    }

  export interface DesignationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Designation'], meta: { name: 'Designation' } }
    /**
     * Find zero or one Designation that matches the filter.
     * @param {DesignationFindUniqueArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DesignationFindUniqueArgs>(args: SelectSubset<T, DesignationFindUniqueArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Designation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DesignationFindUniqueOrThrowArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DesignationFindUniqueOrThrowArgs>(args: SelectSubset<T, DesignationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Designation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindFirstArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DesignationFindFirstArgs>(args?: SelectSubset<T, DesignationFindFirstArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Designation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindFirstOrThrowArgs} args - Arguments to find a Designation
     * @example
     * // Get one Designation
     * const designation = await prisma.designation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DesignationFindFirstOrThrowArgs>(args?: SelectSubset<T, DesignationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Designations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Designations
     * const designations = await prisma.designation.findMany()
     * 
     * // Get first 10 Designations
     * const designations = await prisma.designation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const designationWithIdOnly = await prisma.designation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DesignationFindManyArgs>(args?: SelectSubset<T, DesignationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Designation.
     * @param {DesignationCreateArgs} args - Arguments to create a Designation.
     * @example
     * // Create one Designation
     * const Designation = await prisma.designation.create({
     *   data: {
     *     // ... data to create a Designation
     *   }
     * })
     * 
     */
    create<T extends DesignationCreateArgs>(args: SelectSubset<T, DesignationCreateArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Designations.
     * @param {DesignationCreateManyArgs} args - Arguments to create many Designations.
     * @example
     * // Create many Designations
     * const designation = await prisma.designation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DesignationCreateManyArgs>(args?: SelectSubset<T, DesignationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Designations and returns the data saved in the database.
     * @param {DesignationCreateManyAndReturnArgs} args - Arguments to create many Designations.
     * @example
     * // Create many Designations
     * const designation = await prisma.designation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Designations and only return the `id`
     * const designationWithIdOnly = await prisma.designation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DesignationCreateManyAndReturnArgs>(args?: SelectSubset<T, DesignationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Designation.
     * @param {DesignationDeleteArgs} args - Arguments to delete one Designation.
     * @example
     * // Delete one Designation
     * const Designation = await prisma.designation.delete({
     *   where: {
     *     // ... filter to delete one Designation
     *   }
     * })
     * 
     */
    delete<T extends DesignationDeleteArgs>(args: SelectSubset<T, DesignationDeleteArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Designation.
     * @param {DesignationUpdateArgs} args - Arguments to update one Designation.
     * @example
     * // Update one Designation
     * const designation = await prisma.designation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DesignationUpdateArgs>(args: SelectSubset<T, DesignationUpdateArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Designations.
     * @param {DesignationDeleteManyArgs} args - Arguments to filter Designations to delete.
     * @example
     * // Delete a few Designations
     * const { count } = await prisma.designation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DesignationDeleteManyArgs>(args?: SelectSubset<T, DesignationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Designations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Designations
     * const designation = await prisma.designation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DesignationUpdateManyArgs>(args: SelectSubset<T, DesignationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Designations and returns the data updated in the database.
     * @param {DesignationUpdateManyAndReturnArgs} args - Arguments to update many Designations.
     * @example
     * // Update many Designations
     * const designation = await prisma.designation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Designations and only return the `id`
     * const designationWithIdOnly = await prisma.designation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DesignationUpdateManyAndReturnArgs>(args: SelectSubset<T, DesignationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Designation.
     * @param {DesignationUpsertArgs} args - Arguments to update or create a Designation.
     * @example
     * // Update or create a Designation
     * const designation = await prisma.designation.upsert({
     *   create: {
     *     // ... data to create a Designation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Designation we want to update
     *   }
     * })
     */
    upsert<T extends DesignationUpsertArgs>(args: SelectSubset<T, DesignationUpsertArgs<ExtArgs>>): Prisma__DesignationClient<$Result.GetResult<Prisma.$DesignationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Designations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationCountArgs} args - Arguments to filter Designations to count.
     * @example
     * // Count the number of Designations
     * const count = await prisma.designation.count({
     *   where: {
     *     // ... the filter for the Designations we want to count
     *   }
     * })
    **/
    count<T extends DesignationCountArgs>(
      args?: Subset<T, DesignationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesignationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Designation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesignationAggregateArgs>(args: Subset<T, DesignationAggregateArgs>): Prisma.PrismaPromise<GetDesignationAggregateType<T>>

    /**
     * Group by Designation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesignationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesignationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesignationGroupByArgs['orderBy'] }
        : { orderBy?: DesignationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesignationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesignationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Designation model
   */
  readonly fields: DesignationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Designation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesignationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    faculty<T extends Designation$facultyArgs<ExtArgs> = {}>(args?: Subset<T, Designation$facultyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Designation model
   */
  interface DesignationFieldRefs {
    readonly id: FieldRef<"Designation", 'String'>
    readonly departmentId: FieldRef<"Designation", 'String'>
    readonly title: FieldRef<"Designation", 'String'>
    readonly level: FieldRef<"Designation", 'Int'>
    readonly isActive: FieldRef<"Designation", 'Boolean'>
    readonly createdAt: FieldRef<"Designation", 'DateTime'>
    readonly updatedAt: FieldRef<"Designation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Designation findUnique
   */
  export type DesignationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation findUniqueOrThrow
   */
  export type DesignationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation findFirst
   */
  export type DesignationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designations.
     */
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Designation findFirstOrThrow
   */
  export type DesignationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designation to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Designations.
     */
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Designation findMany
   */
  export type DesignationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter, which Designations to fetch.
     */
    where?: DesignationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Designations to fetch.
     */
    orderBy?: DesignationOrderByWithRelationInput | DesignationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Designations.
     */
    cursor?: DesignationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Designations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Designations.
     */
    skip?: number
    distinct?: DesignationScalarFieldEnum | DesignationScalarFieldEnum[]
  }

  /**
   * Designation create
   */
  export type DesignationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * The data needed to create a Designation.
     */
    data: XOR<DesignationCreateInput, DesignationUncheckedCreateInput>
  }

  /**
   * Designation createMany
   */
  export type DesignationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Designations.
     */
    data: DesignationCreateManyInput | DesignationCreateManyInput[]
  }

  /**
   * Designation createManyAndReturn
   */
  export type DesignationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * The data used to create many Designations.
     */
    data: DesignationCreateManyInput | DesignationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Designation update
   */
  export type DesignationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * The data needed to update a Designation.
     */
    data: XOR<DesignationUpdateInput, DesignationUncheckedUpdateInput>
    /**
     * Choose, which Designation to update.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation updateMany
   */
  export type DesignationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Designations.
     */
    data: XOR<DesignationUpdateManyMutationInput, DesignationUncheckedUpdateManyInput>
    /**
     * Filter which Designations to update
     */
    where?: DesignationWhereInput
    /**
     * Limit how many Designations to update.
     */
    limit?: number
  }

  /**
   * Designation updateManyAndReturn
   */
  export type DesignationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * The data used to update Designations.
     */
    data: XOR<DesignationUpdateManyMutationInput, DesignationUncheckedUpdateManyInput>
    /**
     * Filter which Designations to update
     */
    where?: DesignationWhereInput
    /**
     * Limit how many Designations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Designation upsert
   */
  export type DesignationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * The filter to search for the Designation to update in case it exists.
     */
    where: DesignationWhereUniqueInput
    /**
     * In case the Designation found by the `where` argument doesn't exist, create a new Designation with this data.
     */
    create: XOR<DesignationCreateInput, DesignationUncheckedCreateInput>
    /**
     * In case the Designation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesignationUpdateInput, DesignationUncheckedUpdateInput>
  }

  /**
   * Designation delete
   */
  export type DesignationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
    /**
     * Filter which Designation to delete.
     */
    where: DesignationWhereUniqueInput
  }

  /**
   * Designation deleteMany
   */
  export type DesignationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Designations to delete
     */
    where?: DesignationWhereInput
    /**
     * Limit how many Designations to delete.
     */
    limit?: number
  }

  /**
   * Designation.faculty
   */
  export type Designation$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyProfile
     */
    select?: FacultyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultyProfile
     */
    omit?: FacultyProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyProfileInclude<ExtArgs> | null
    where?: FacultyProfileWhereInput
    orderBy?: FacultyProfileOrderByWithRelationInput | FacultyProfileOrderByWithRelationInput[]
    cursor?: FacultyProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyProfileScalarFieldEnum | FacultyProfileScalarFieldEnum[]
  }

  /**
   * Designation without action
   */
  export type DesignationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Designation
     */
    select?: DesignationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Designation
     */
    omit?: DesignationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DesignationInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    departmentId: string | null
    name: string | null
    code: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    departmentId: string | null
    name: string | null
    code: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    departmentId: number
    name: number
    code: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    id?: true
    departmentId?: true
    name?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    departmentId?: true
    name?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    departmentId?: true
    name?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    departmentId: string
    name: string
    code: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    faculty?: boolean | Subject$facultyArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    departmentId?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "departmentId" | "name" | "code" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    faculty?: boolean | Subject$facultyArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      faculty: Prisma.$FacultySubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      departmentId: string
      name: string
      code: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    faculty<T extends Subject$facultyArgs<ExtArgs> = {}>(args?: Subset<T, Subject$facultyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly departmentId: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly isActive: FieldRef<"Subject", 'Boolean'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject.faculty
   */
  export type Subject$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    where?: FacultySubjectWhereInput
    orderBy?: FacultySubjectOrderByWithRelationInput | FacultySubjectOrderByWithRelationInput[]
    cursor?: FacultySubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultySubjectScalarFieldEnum | FacultySubjectScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model FacultySubject
   */

  export type AggregateFacultySubject = {
    _count: FacultySubjectCountAggregateOutputType | null
    _min: FacultySubjectMinAggregateOutputType | null
    _max: FacultySubjectMaxAggregateOutputType | null
  }

  export type FacultySubjectMinAggregateOutputType = {
    id: string | null
    facultyId: string | null
    subjectId: string | null
    createdAt: Date | null
  }

  export type FacultySubjectMaxAggregateOutputType = {
    id: string | null
    facultyId: string | null
    subjectId: string | null
    createdAt: Date | null
  }

  export type FacultySubjectCountAggregateOutputType = {
    id: number
    facultyId: number
    subjectId: number
    createdAt: number
    _all: number
  }


  export type FacultySubjectMinAggregateInputType = {
    id?: true
    facultyId?: true
    subjectId?: true
    createdAt?: true
  }

  export type FacultySubjectMaxAggregateInputType = {
    id?: true
    facultyId?: true
    subjectId?: true
    createdAt?: true
  }

  export type FacultySubjectCountAggregateInputType = {
    id?: true
    facultyId?: true
    subjectId?: true
    createdAt?: true
    _all?: true
  }

  export type FacultySubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacultySubject to aggregate.
     */
    where?: FacultySubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultySubjects to fetch.
     */
    orderBy?: FacultySubjectOrderByWithRelationInput | FacultySubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultySubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultySubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultySubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacultySubjects
    **/
    _count?: true | FacultySubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultySubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultySubjectMaxAggregateInputType
  }

  export type GetFacultySubjectAggregateType<T extends FacultySubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateFacultySubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacultySubject[P]>
      : GetScalarType<T[P], AggregateFacultySubject[P]>
  }




  export type FacultySubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultySubjectWhereInput
    orderBy?: FacultySubjectOrderByWithAggregationInput | FacultySubjectOrderByWithAggregationInput[]
    by: FacultySubjectScalarFieldEnum[] | FacultySubjectScalarFieldEnum
    having?: FacultySubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultySubjectCountAggregateInputType | true
    _min?: FacultySubjectMinAggregateInputType
    _max?: FacultySubjectMaxAggregateInputType
  }

  export type FacultySubjectGroupByOutputType = {
    id: string
    facultyId: string
    subjectId: string
    createdAt: Date
    _count: FacultySubjectCountAggregateOutputType | null
    _min: FacultySubjectMinAggregateOutputType | null
    _max: FacultySubjectMaxAggregateOutputType | null
  }

  type GetFacultySubjectGroupByPayload<T extends FacultySubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultySubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultySubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultySubjectGroupByOutputType[P]>
            : GetScalarType<T[P], FacultySubjectGroupByOutputType[P]>
        }
      >
    >


  export type FacultySubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facultySubject"]>

  export type FacultySubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facultySubject"]>

  export type FacultySubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facultySubject"]>

  export type FacultySubjectSelectScalar = {
    id?: boolean
    facultyId?: boolean
    subjectId?: boolean
    createdAt?: boolean
  }

  export type FacultySubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facultyId" | "subjectId" | "createdAt", ExtArgs["result"]["facultySubject"]>
  export type FacultySubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type FacultySubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type FacultySubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $FacultySubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacultySubject"
    objects: {
      faculty: Prisma.$FacultyProfilePayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      facultyId: string
      subjectId: string
      createdAt: Date
    }, ExtArgs["result"]["facultySubject"]>
    composites: {}
  }

  type FacultySubjectGetPayload<S extends boolean | null | undefined | FacultySubjectDefaultArgs> = $Result.GetResult<Prisma.$FacultySubjectPayload, S>

  type FacultySubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacultySubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacultySubjectCountAggregateInputType | true
    }

  export interface FacultySubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacultySubject'], meta: { name: 'FacultySubject' } }
    /**
     * Find zero or one FacultySubject that matches the filter.
     * @param {FacultySubjectFindUniqueArgs} args - Arguments to find a FacultySubject
     * @example
     * // Get one FacultySubject
     * const facultySubject = await prisma.facultySubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultySubjectFindUniqueArgs>(args: SelectSubset<T, FacultySubjectFindUniqueArgs<ExtArgs>>): Prisma__FacultySubjectClient<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacultySubject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacultySubjectFindUniqueOrThrowArgs} args - Arguments to find a FacultySubject
     * @example
     * // Get one FacultySubject
     * const facultySubject = await prisma.facultySubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultySubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, FacultySubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacultySubjectClient<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacultySubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultySubjectFindFirstArgs} args - Arguments to find a FacultySubject
     * @example
     * // Get one FacultySubject
     * const facultySubject = await prisma.facultySubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultySubjectFindFirstArgs>(args?: SelectSubset<T, FacultySubjectFindFirstArgs<ExtArgs>>): Prisma__FacultySubjectClient<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacultySubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultySubjectFindFirstOrThrowArgs} args - Arguments to find a FacultySubject
     * @example
     * // Get one FacultySubject
     * const facultySubject = await prisma.facultySubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultySubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, FacultySubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacultySubjectClient<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacultySubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultySubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacultySubjects
     * const facultySubjects = await prisma.facultySubject.findMany()
     * 
     * // Get first 10 FacultySubjects
     * const facultySubjects = await prisma.facultySubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facultySubjectWithIdOnly = await prisma.facultySubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacultySubjectFindManyArgs>(args?: SelectSubset<T, FacultySubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacultySubject.
     * @param {FacultySubjectCreateArgs} args - Arguments to create a FacultySubject.
     * @example
     * // Create one FacultySubject
     * const FacultySubject = await prisma.facultySubject.create({
     *   data: {
     *     // ... data to create a FacultySubject
     *   }
     * })
     * 
     */
    create<T extends FacultySubjectCreateArgs>(args: SelectSubset<T, FacultySubjectCreateArgs<ExtArgs>>): Prisma__FacultySubjectClient<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacultySubjects.
     * @param {FacultySubjectCreateManyArgs} args - Arguments to create many FacultySubjects.
     * @example
     * // Create many FacultySubjects
     * const facultySubject = await prisma.facultySubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacultySubjectCreateManyArgs>(args?: SelectSubset<T, FacultySubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacultySubjects and returns the data saved in the database.
     * @param {FacultySubjectCreateManyAndReturnArgs} args - Arguments to create many FacultySubjects.
     * @example
     * // Create many FacultySubjects
     * const facultySubject = await prisma.facultySubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacultySubjects and only return the `id`
     * const facultySubjectWithIdOnly = await prisma.facultySubject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacultySubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, FacultySubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacultySubject.
     * @param {FacultySubjectDeleteArgs} args - Arguments to delete one FacultySubject.
     * @example
     * // Delete one FacultySubject
     * const FacultySubject = await prisma.facultySubject.delete({
     *   where: {
     *     // ... filter to delete one FacultySubject
     *   }
     * })
     * 
     */
    delete<T extends FacultySubjectDeleteArgs>(args: SelectSubset<T, FacultySubjectDeleteArgs<ExtArgs>>): Prisma__FacultySubjectClient<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacultySubject.
     * @param {FacultySubjectUpdateArgs} args - Arguments to update one FacultySubject.
     * @example
     * // Update one FacultySubject
     * const facultySubject = await prisma.facultySubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacultySubjectUpdateArgs>(args: SelectSubset<T, FacultySubjectUpdateArgs<ExtArgs>>): Prisma__FacultySubjectClient<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacultySubjects.
     * @param {FacultySubjectDeleteManyArgs} args - Arguments to filter FacultySubjects to delete.
     * @example
     * // Delete a few FacultySubjects
     * const { count } = await prisma.facultySubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacultySubjectDeleteManyArgs>(args?: SelectSubset<T, FacultySubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacultySubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultySubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacultySubjects
     * const facultySubject = await prisma.facultySubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacultySubjectUpdateManyArgs>(args: SelectSubset<T, FacultySubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacultySubjects and returns the data updated in the database.
     * @param {FacultySubjectUpdateManyAndReturnArgs} args - Arguments to update many FacultySubjects.
     * @example
     * // Update many FacultySubjects
     * const facultySubject = await prisma.facultySubject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacultySubjects and only return the `id`
     * const facultySubjectWithIdOnly = await prisma.facultySubject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacultySubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, FacultySubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacultySubject.
     * @param {FacultySubjectUpsertArgs} args - Arguments to update or create a FacultySubject.
     * @example
     * // Update or create a FacultySubject
     * const facultySubject = await prisma.facultySubject.upsert({
     *   create: {
     *     // ... data to create a FacultySubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacultySubject we want to update
     *   }
     * })
     */
    upsert<T extends FacultySubjectUpsertArgs>(args: SelectSubset<T, FacultySubjectUpsertArgs<ExtArgs>>): Prisma__FacultySubjectClient<$Result.GetResult<Prisma.$FacultySubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacultySubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultySubjectCountArgs} args - Arguments to filter FacultySubjects to count.
     * @example
     * // Count the number of FacultySubjects
     * const count = await prisma.facultySubject.count({
     *   where: {
     *     // ... the filter for the FacultySubjects we want to count
     *   }
     * })
    **/
    count<T extends FacultySubjectCountArgs>(
      args?: Subset<T, FacultySubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultySubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacultySubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultySubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultySubjectAggregateArgs>(args: Subset<T, FacultySubjectAggregateArgs>): Prisma.PrismaPromise<GetFacultySubjectAggregateType<T>>

    /**
     * Group by FacultySubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultySubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultySubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultySubjectGroupByArgs['orderBy'] }
        : { orderBy?: FacultySubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultySubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultySubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacultySubject model
   */
  readonly fields: FacultySubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacultySubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultySubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    faculty<T extends FacultyProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyProfileDefaultArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacultySubject model
   */
  interface FacultySubjectFieldRefs {
    readonly id: FieldRef<"FacultySubject", 'String'>
    readonly facultyId: FieldRef<"FacultySubject", 'String'>
    readonly subjectId: FieldRef<"FacultySubject", 'String'>
    readonly createdAt: FieldRef<"FacultySubject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacultySubject findUnique
   */
  export type FacultySubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    /**
     * Filter, which FacultySubject to fetch.
     */
    where: FacultySubjectWhereUniqueInput
  }

  /**
   * FacultySubject findUniqueOrThrow
   */
  export type FacultySubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    /**
     * Filter, which FacultySubject to fetch.
     */
    where: FacultySubjectWhereUniqueInput
  }

  /**
   * FacultySubject findFirst
   */
  export type FacultySubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    /**
     * Filter, which FacultySubject to fetch.
     */
    where?: FacultySubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultySubjects to fetch.
     */
    orderBy?: FacultySubjectOrderByWithRelationInput | FacultySubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacultySubjects.
     */
    cursor?: FacultySubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultySubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultySubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacultySubjects.
     */
    distinct?: FacultySubjectScalarFieldEnum | FacultySubjectScalarFieldEnum[]
  }

  /**
   * FacultySubject findFirstOrThrow
   */
  export type FacultySubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    /**
     * Filter, which FacultySubject to fetch.
     */
    where?: FacultySubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultySubjects to fetch.
     */
    orderBy?: FacultySubjectOrderByWithRelationInput | FacultySubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacultySubjects.
     */
    cursor?: FacultySubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultySubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultySubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacultySubjects.
     */
    distinct?: FacultySubjectScalarFieldEnum | FacultySubjectScalarFieldEnum[]
  }

  /**
   * FacultySubject findMany
   */
  export type FacultySubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    /**
     * Filter, which FacultySubjects to fetch.
     */
    where?: FacultySubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacultySubjects to fetch.
     */
    orderBy?: FacultySubjectOrderByWithRelationInput | FacultySubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacultySubjects.
     */
    cursor?: FacultySubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacultySubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacultySubjects.
     */
    skip?: number
    distinct?: FacultySubjectScalarFieldEnum | FacultySubjectScalarFieldEnum[]
  }

  /**
   * FacultySubject create
   */
  export type FacultySubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a FacultySubject.
     */
    data: XOR<FacultySubjectCreateInput, FacultySubjectUncheckedCreateInput>
  }

  /**
   * FacultySubject createMany
   */
  export type FacultySubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacultySubjects.
     */
    data: FacultySubjectCreateManyInput | FacultySubjectCreateManyInput[]
  }

  /**
   * FacultySubject createManyAndReturn
   */
  export type FacultySubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * The data used to create many FacultySubjects.
     */
    data: FacultySubjectCreateManyInput | FacultySubjectCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacultySubject update
   */
  export type FacultySubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a FacultySubject.
     */
    data: XOR<FacultySubjectUpdateInput, FacultySubjectUncheckedUpdateInput>
    /**
     * Choose, which FacultySubject to update.
     */
    where: FacultySubjectWhereUniqueInput
  }

  /**
   * FacultySubject updateMany
   */
  export type FacultySubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacultySubjects.
     */
    data: XOR<FacultySubjectUpdateManyMutationInput, FacultySubjectUncheckedUpdateManyInput>
    /**
     * Filter which FacultySubjects to update
     */
    where?: FacultySubjectWhereInput
    /**
     * Limit how many FacultySubjects to update.
     */
    limit?: number
  }

  /**
   * FacultySubject updateManyAndReturn
   */
  export type FacultySubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * The data used to update FacultySubjects.
     */
    data: XOR<FacultySubjectUpdateManyMutationInput, FacultySubjectUncheckedUpdateManyInput>
    /**
     * Filter which FacultySubjects to update
     */
    where?: FacultySubjectWhereInput
    /**
     * Limit how many FacultySubjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacultySubject upsert
   */
  export type FacultySubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the FacultySubject to update in case it exists.
     */
    where: FacultySubjectWhereUniqueInput
    /**
     * In case the FacultySubject found by the `where` argument doesn't exist, create a new FacultySubject with this data.
     */
    create: XOR<FacultySubjectCreateInput, FacultySubjectUncheckedCreateInput>
    /**
     * In case the FacultySubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultySubjectUpdateInput, FacultySubjectUncheckedUpdateInput>
  }

  /**
   * FacultySubject delete
   */
  export type FacultySubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
    /**
     * Filter which FacultySubject to delete.
     */
    where: FacultySubjectWhereUniqueInput
  }

  /**
   * FacultySubject deleteMany
   */
  export type FacultySubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacultySubjects to delete
     */
    where?: FacultySubjectWhereInput
    /**
     * Limit how many FacultySubjects to delete.
     */
    limit?: number
  }

  /**
   * FacultySubject without action
   */
  export type FacultySubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultySubject
     */
    select?: FacultySubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacultySubject
     */
    omit?: FacultySubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultySubjectInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    credits: number | null
  }

  export type CourseSumAggregateOutputType = {
    credits: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    credits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    credits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    code: number
    title: number
    credits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    credits?: true
  }

  export type CourseSumAggregateInputType = {
    credits?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    code?: true
    title?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    code?: true
    title?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    code?: true
    title?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    code: string
    title: string
    credits: number
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offerings?: boolean | Course$offeringsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    code?: boolean
    title?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "title" | "credits" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offerings?: boolean | Course$offeringsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      offerings: Prisma.$CourseOfferingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      title: string
      credits: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offerings<T extends Course$offeringsArgs<ExtArgs> = {}>(args?: Subset<T, Course$offeringsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly code: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly credits: FieldRef<"Course", 'Int'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.offerings
   */
  export type Course$offeringsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    where?: CourseOfferingWhereInput
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    cursor?: CourseOfferingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseOffering
   */

  export type AggregateCourseOffering = {
    _count: CourseOfferingCountAggregateOutputType | null
    _avg: CourseOfferingAvgAggregateOutputType | null
    _sum: CourseOfferingSumAggregateOutputType | null
    _min: CourseOfferingMinAggregateOutputType | null
    _max: CourseOfferingMaxAggregateOutputType | null
  }

  export type CourseOfferingAvgAggregateOutputType = {
    semester: number | null
  }

  export type CourseOfferingSumAggregateOutputType = {
    semester: number | null
  }

  export type CourseOfferingMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    facultyId: string | null
    semester: number | null
    academicYear: string | null
    term: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseOfferingMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    facultyId: string | null
    semester: number | null
    academicYear: string | null
    term: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseOfferingCountAggregateOutputType = {
    id: number
    courseId: number
    facultyId: number
    semester: number
    academicYear: number
    term: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseOfferingAvgAggregateInputType = {
    semester?: true
  }

  export type CourseOfferingSumAggregateInputType = {
    semester?: true
  }

  export type CourseOfferingMinAggregateInputType = {
    id?: true
    courseId?: true
    facultyId?: true
    semester?: true
    academicYear?: true
    term?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseOfferingMaxAggregateInputType = {
    id?: true
    courseId?: true
    facultyId?: true
    semester?: true
    academicYear?: true
    term?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseOfferingCountAggregateInputType = {
    id?: true
    courseId?: true
    facultyId?: true
    semester?: true
    academicYear?: true
    term?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseOfferingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseOffering to aggregate.
     */
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
     */
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseOfferings
    **/
    _count?: true | CourseOfferingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseOfferingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseOfferingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseOfferingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseOfferingMaxAggregateInputType
  }

  export type GetCourseOfferingAggregateType<T extends CourseOfferingAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseOffering]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseOffering[P]>
      : GetScalarType<T[P], AggregateCourseOffering[P]>
  }




  export type CourseOfferingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseOfferingWhereInput
    orderBy?: CourseOfferingOrderByWithAggregationInput | CourseOfferingOrderByWithAggregationInput[]
    by: CourseOfferingScalarFieldEnum[] | CourseOfferingScalarFieldEnum
    having?: CourseOfferingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseOfferingCountAggregateInputType | true
    _avg?: CourseOfferingAvgAggregateInputType
    _sum?: CourseOfferingSumAggregateInputType
    _min?: CourseOfferingMinAggregateInputType
    _max?: CourseOfferingMaxAggregateInputType
  }

  export type CourseOfferingGroupByOutputType = {
    id: string
    courseId: string
    facultyId: string
    semester: number
    academicYear: string | null
    term: string | null
    createdAt: Date
    updatedAt: Date
    _count: CourseOfferingCountAggregateOutputType | null
    _avg: CourseOfferingAvgAggregateOutputType | null
    _sum: CourseOfferingSumAggregateOutputType | null
    _min: CourseOfferingMinAggregateOutputType | null
    _max: CourseOfferingMaxAggregateOutputType | null
  }

  type GetCourseOfferingGroupByPayload<T extends CourseOfferingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseOfferingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseOfferingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseOfferingGroupByOutputType[P]>
            : GetScalarType<T[P], CourseOfferingGroupByOutputType[P]>
        }
      >
    >


  export type CourseOfferingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    facultyId?: boolean
    semester?: boolean
    academicYear?: boolean
    term?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
    enrollments?: boolean | CourseOffering$enrollmentsArgs<ExtArgs>
    sessions?: boolean | CourseOffering$sessionsArgs<ExtArgs>
    _count?: boolean | CourseOfferingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseOffering"]>

  export type CourseOfferingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    facultyId?: boolean
    semester?: boolean
    academicYear?: boolean
    term?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseOffering"]>

  export type CourseOfferingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    facultyId?: boolean
    semester?: boolean
    academicYear?: boolean
    term?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseOffering"]>

  export type CourseOfferingSelectScalar = {
    id?: boolean
    courseId?: boolean
    facultyId?: boolean
    semester?: boolean
    academicYear?: boolean
    term?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOfferingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "facultyId" | "semester" | "academicYear" | "term" | "createdAt" | "updatedAt", ExtArgs["result"]["courseOffering"]>
  export type CourseOfferingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
    enrollments?: boolean | CourseOffering$enrollmentsArgs<ExtArgs>
    sessions?: boolean | CourseOffering$sessionsArgs<ExtArgs>
    _count?: boolean | CourseOfferingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseOfferingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
  }
  export type CourseOfferingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyProfileDefaultArgs<ExtArgs>
  }

  export type $CourseOfferingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseOffering"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      faculty: Prisma.$FacultyProfilePayload<ExtArgs>
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      sessions: Prisma.$AttendanceSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      facultyId: string
      semester: number
      academicYear: string | null
      term: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courseOffering"]>
    composites: {}
  }

  type CourseOfferingGetPayload<S extends boolean | null | undefined | CourseOfferingDefaultArgs> = $Result.GetResult<Prisma.$CourseOfferingPayload, S>

  type CourseOfferingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseOfferingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseOfferingCountAggregateInputType | true
    }

  export interface CourseOfferingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseOffering'], meta: { name: 'CourseOffering' } }
    /**
     * Find zero or one CourseOffering that matches the filter.
     * @param {CourseOfferingFindUniqueArgs} args - Arguments to find a CourseOffering
     * @example
     * // Get one CourseOffering
     * const courseOffering = await prisma.courseOffering.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseOfferingFindUniqueArgs>(args: SelectSubset<T, CourseOfferingFindUniqueArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseOffering that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseOfferingFindUniqueOrThrowArgs} args - Arguments to find a CourseOffering
     * @example
     * // Get one CourseOffering
     * const courseOffering = await prisma.courseOffering.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseOfferingFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseOfferingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseOffering that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingFindFirstArgs} args - Arguments to find a CourseOffering
     * @example
     * // Get one CourseOffering
     * const courseOffering = await prisma.courseOffering.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseOfferingFindFirstArgs>(args?: SelectSubset<T, CourseOfferingFindFirstArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseOffering that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingFindFirstOrThrowArgs} args - Arguments to find a CourseOffering
     * @example
     * // Get one CourseOffering
     * const courseOffering = await prisma.courseOffering.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseOfferingFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseOfferingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseOfferings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseOfferings
     * const courseOfferings = await prisma.courseOffering.findMany()
     * 
     * // Get first 10 CourseOfferings
     * const courseOfferings = await prisma.courseOffering.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseOfferingWithIdOnly = await prisma.courseOffering.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseOfferingFindManyArgs>(args?: SelectSubset<T, CourseOfferingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseOffering.
     * @param {CourseOfferingCreateArgs} args - Arguments to create a CourseOffering.
     * @example
     * // Create one CourseOffering
     * const CourseOffering = await prisma.courseOffering.create({
     *   data: {
     *     // ... data to create a CourseOffering
     *   }
     * })
     * 
     */
    create<T extends CourseOfferingCreateArgs>(args: SelectSubset<T, CourseOfferingCreateArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseOfferings.
     * @param {CourseOfferingCreateManyArgs} args - Arguments to create many CourseOfferings.
     * @example
     * // Create many CourseOfferings
     * const courseOffering = await prisma.courseOffering.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseOfferingCreateManyArgs>(args?: SelectSubset<T, CourseOfferingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseOfferings and returns the data saved in the database.
     * @param {CourseOfferingCreateManyAndReturnArgs} args - Arguments to create many CourseOfferings.
     * @example
     * // Create many CourseOfferings
     * const courseOffering = await prisma.courseOffering.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseOfferings and only return the `id`
     * const courseOfferingWithIdOnly = await prisma.courseOffering.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseOfferingCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseOfferingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseOffering.
     * @param {CourseOfferingDeleteArgs} args - Arguments to delete one CourseOffering.
     * @example
     * // Delete one CourseOffering
     * const CourseOffering = await prisma.courseOffering.delete({
     *   where: {
     *     // ... filter to delete one CourseOffering
     *   }
     * })
     * 
     */
    delete<T extends CourseOfferingDeleteArgs>(args: SelectSubset<T, CourseOfferingDeleteArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseOffering.
     * @param {CourseOfferingUpdateArgs} args - Arguments to update one CourseOffering.
     * @example
     * // Update one CourseOffering
     * const courseOffering = await prisma.courseOffering.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseOfferingUpdateArgs>(args: SelectSubset<T, CourseOfferingUpdateArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseOfferings.
     * @param {CourseOfferingDeleteManyArgs} args - Arguments to filter CourseOfferings to delete.
     * @example
     * // Delete a few CourseOfferings
     * const { count } = await prisma.courseOffering.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseOfferingDeleteManyArgs>(args?: SelectSubset<T, CourseOfferingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseOfferings
     * const courseOffering = await prisma.courseOffering.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseOfferingUpdateManyArgs>(args: SelectSubset<T, CourseOfferingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseOfferings and returns the data updated in the database.
     * @param {CourseOfferingUpdateManyAndReturnArgs} args - Arguments to update many CourseOfferings.
     * @example
     * // Update many CourseOfferings
     * const courseOffering = await prisma.courseOffering.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseOfferings and only return the `id`
     * const courseOfferingWithIdOnly = await prisma.courseOffering.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseOfferingUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseOfferingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseOffering.
     * @param {CourseOfferingUpsertArgs} args - Arguments to update or create a CourseOffering.
     * @example
     * // Update or create a CourseOffering
     * const courseOffering = await prisma.courseOffering.upsert({
     *   create: {
     *     // ... data to create a CourseOffering
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseOffering we want to update
     *   }
     * })
     */
    upsert<T extends CourseOfferingUpsertArgs>(args: SelectSubset<T, CourseOfferingUpsertArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseOfferings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingCountArgs} args - Arguments to filter CourseOfferings to count.
     * @example
     * // Count the number of CourseOfferings
     * const count = await prisma.courseOffering.count({
     *   where: {
     *     // ... the filter for the CourseOfferings we want to count
     *   }
     * })
    **/
    count<T extends CourseOfferingCountArgs>(
      args?: Subset<T, CourseOfferingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseOfferingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseOfferingAggregateArgs>(args: Subset<T, CourseOfferingAggregateArgs>): Prisma.PrismaPromise<GetCourseOfferingAggregateType<T>>

    /**
     * Group by CourseOffering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseOfferingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseOfferingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseOfferingGroupByArgs['orderBy'] }
        : { orderBy?: CourseOfferingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseOfferingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseOfferingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseOffering model
   */
  readonly fields: CourseOfferingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseOffering.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseOfferingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    faculty<T extends FacultyProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyProfileDefaultArgs<ExtArgs>>): Prisma__FacultyProfileClient<$Result.GetResult<Prisma.$FacultyProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    enrollments<T extends CourseOffering$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, CourseOffering$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends CourseOffering$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, CourseOffering$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseOffering model
   */
  interface CourseOfferingFieldRefs {
    readonly id: FieldRef<"CourseOffering", 'String'>
    readonly courseId: FieldRef<"CourseOffering", 'String'>
    readonly facultyId: FieldRef<"CourseOffering", 'String'>
    readonly semester: FieldRef<"CourseOffering", 'Int'>
    readonly academicYear: FieldRef<"CourseOffering", 'String'>
    readonly term: FieldRef<"CourseOffering", 'String'>
    readonly createdAt: FieldRef<"CourseOffering", 'DateTime'>
    readonly updatedAt: FieldRef<"CourseOffering", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseOffering findUnique
   */
  export type CourseOfferingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter, which CourseOffering to fetch.
     */
    where: CourseOfferingWhereUniqueInput
  }

  /**
   * CourseOffering findUniqueOrThrow
   */
  export type CourseOfferingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter, which CourseOffering to fetch.
     */
    where: CourseOfferingWhereUniqueInput
  }

  /**
   * CourseOffering findFirst
   */
  export type CourseOfferingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter, which CourseOffering to fetch.
     */
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
     */
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseOfferings.
     */
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseOfferings.
     */
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * CourseOffering findFirstOrThrow
   */
  export type CourseOfferingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter, which CourseOffering to fetch.
     */
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
     */
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseOfferings.
     */
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseOfferings.
     */
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * CourseOffering findMany
   */
  export type CourseOfferingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter, which CourseOfferings to fetch.
     */
    where?: CourseOfferingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseOfferings to fetch.
     */
    orderBy?: CourseOfferingOrderByWithRelationInput | CourseOfferingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseOfferings.
     */
    cursor?: CourseOfferingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseOfferings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseOfferings.
     */
    skip?: number
    distinct?: CourseOfferingScalarFieldEnum | CourseOfferingScalarFieldEnum[]
  }

  /**
   * CourseOffering create
   */
  export type CourseOfferingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseOffering.
     */
    data: XOR<CourseOfferingCreateInput, CourseOfferingUncheckedCreateInput>
  }

  /**
   * CourseOffering createMany
   */
  export type CourseOfferingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseOfferings.
     */
    data: CourseOfferingCreateManyInput | CourseOfferingCreateManyInput[]
  }

  /**
   * CourseOffering createManyAndReturn
   */
  export type CourseOfferingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * The data used to create many CourseOfferings.
     */
    data: CourseOfferingCreateManyInput | CourseOfferingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseOffering update
   */
  export type CourseOfferingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseOffering.
     */
    data: XOR<CourseOfferingUpdateInput, CourseOfferingUncheckedUpdateInput>
    /**
     * Choose, which CourseOffering to update.
     */
    where: CourseOfferingWhereUniqueInput
  }

  /**
   * CourseOffering updateMany
   */
  export type CourseOfferingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseOfferings.
     */
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyInput>
    /**
     * Filter which CourseOfferings to update
     */
    where?: CourseOfferingWhereInput
    /**
     * Limit how many CourseOfferings to update.
     */
    limit?: number
  }

  /**
   * CourseOffering updateManyAndReturn
   */
  export type CourseOfferingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * The data used to update CourseOfferings.
     */
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyInput>
    /**
     * Filter which CourseOfferings to update
     */
    where?: CourseOfferingWhereInput
    /**
     * Limit how many CourseOfferings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseOffering upsert
   */
  export type CourseOfferingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseOffering to update in case it exists.
     */
    where: CourseOfferingWhereUniqueInput
    /**
     * In case the CourseOffering found by the `where` argument doesn't exist, create a new CourseOffering with this data.
     */
    create: XOR<CourseOfferingCreateInput, CourseOfferingUncheckedCreateInput>
    /**
     * In case the CourseOffering was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseOfferingUpdateInput, CourseOfferingUncheckedUpdateInput>
  }

  /**
   * CourseOffering delete
   */
  export type CourseOfferingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
    /**
     * Filter which CourseOffering to delete.
     */
    where: CourseOfferingWhereUniqueInput
  }

  /**
   * CourseOffering deleteMany
   */
  export type CourseOfferingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseOfferings to delete
     */
    where?: CourseOfferingWhereInput
    /**
     * Limit how many CourseOfferings to delete.
     */
    limit?: number
  }

  /**
   * CourseOffering.enrollments
   */
  export type CourseOffering$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * CourseOffering.sessions
   */
  export type CourseOffering$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
    where?: AttendanceSessionWhereInput
    orderBy?: AttendanceSessionOrderByWithRelationInput | AttendanceSessionOrderByWithRelationInput[]
    cursor?: AttendanceSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceSessionScalarFieldEnum | AttendanceSessionScalarFieldEnum[]
  }

  /**
   * CourseOffering without action
   */
  export type CourseOfferingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseOffering
     */
    select?: CourseOfferingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseOffering
     */
    omit?: CourseOfferingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseOfferingInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    offeringId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    offeringId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    studentId: number
    offeringId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EnrollmentMinAggregateInputType = {
    id?: true
    studentId?: true
    offeringId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    studentId?: true
    offeringId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    studentId?: true
    offeringId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: string
    studentId: string
    offeringId: string
    createdAt: Date
    updatedAt: Date
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    offeringId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    offeringId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    offeringId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectScalar = {
    id?: boolean
    studentId?: boolean
    offeringId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "offeringId" | "createdAt" | "updatedAt", ExtArgs["result"]["enrollment"]>
  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      offering: Prisma.$CourseOfferingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      offeringId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {EnrollmentCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {EnrollmentUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offering<T extends CourseOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseOfferingDefaultArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'String'>
    readonly studentId: FieldRef<"Enrollment", 'String'>
    readonly offeringId: FieldRef<"Enrollment", 'String'>
    readonly createdAt: FieldRef<"Enrollment", 'DateTime'>
    readonly updatedAt: FieldRef<"Enrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
  }

  /**
   * Enrollment createManyAndReturn
   */
  export type EnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
  }

  /**
   * Enrollment updateManyAndReturn
   */
  export type EnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to delete.
     */
    limit?: number
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceSession
   */

  export type AggregateAttendanceSession = {
    _count: AttendanceSessionCountAggregateOutputType | null
    _min: AttendanceSessionMinAggregateOutputType | null
    _max: AttendanceSessionMaxAggregateOutputType | null
  }

  export type AttendanceSessionMinAggregateOutputType = {
    id: string | null
    offeringId: string | null
    sessionDate: Date | null
    createdAt: Date | null
  }

  export type AttendanceSessionMaxAggregateOutputType = {
    id: string | null
    offeringId: string | null
    sessionDate: Date | null
    createdAt: Date | null
  }

  export type AttendanceSessionCountAggregateOutputType = {
    id: number
    offeringId: number
    sessionDate: number
    createdAt: number
    _all: number
  }


  export type AttendanceSessionMinAggregateInputType = {
    id?: true
    offeringId?: true
    sessionDate?: true
    createdAt?: true
  }

  export type AttendanceSessionMaxAggregateInputType = {
    id?: true
    offeringId?: true
    sessionDate?: true
    createdAt?: true
  }

  export type AttendanceSessionCountAggregateInputType = {
    id?: true
    offeringId?: true
    sessionDate?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceSession to aggregate.
     */
    where?: AttendanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSessions to fetch.
     */
    orderBy?: AttendanceSessionOrderByWithRelationInput | AttendanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceSessions
    **/
    _count?: true | AttendanceSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceSessionMaxAggregateInputType
  }

  export type GetAttendanceSessionAggregateType<T extends AttendanceSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceSession[P]>
      : GetScalarType<T[P], AggregateAttendanceSession[P]>
  }




  export type AttendanceSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSessionWhereInput
    orderBy?: AttendanceSessionOrderByWithAggregationInput | AttendanceSessionOrderByWithAggregationInput[]
    by: AttendanceSessionScalarFieldEnum[] | AttendanceSessionScalarFieldEnum
    having?: AttendanceSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceSessionCountAggregateInputType | true
    _min?: AttendanceSessionMinAggregateInputType
    _max?: AttendanceSessionMaxAggregateInputType
  }

  export type AttendanceSessionGroupByOutputType = {
    id: string
    offeringId: string
    sessionDate: Date
    createdAt: Date
    _count: AttendanceSessionCountAggregateOutputType | null
    _min: AttendanceSessionMinAggregateOutputType | null
    _max: AttendanceSessionMaxAggregateOutputType | null
  }

  type GetAttendanceSessionGroupByPayload<T extends AttendanceSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceSessionGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offeringId?: boolean
    sessionDate?: boolean
    createdAt?: boolean
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
    marks?: boolean | AttendanceSession$marksArgs<ExtArgs>
    _count?: boolean | AttendanceSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSession"]>

  export type AttendanceSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offeringId?: boolean
    sessionDate?: boolean
    createdAt?: boolean
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSession"]>

  export type AttendanceSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offeringId?: boolean
    sessionDate?: boolean
    createdAt?: boolean
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSession"]>

  export type AttendanceSessionSelectScalar = {
    id?: boolean
    offeringId?: boolean
    sessionDate?: boolean
    createdAt?: boolean
  }

  export type AttendanceSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "offeringId" | "sessionDate" | "createdAt", ExtArgs["result"]["attendanceSession"]>
  export type AttendanceSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
    marks?: boolean | AttendanceSession$marksArgs<ExtArgs>
    _count?: boolean | AttendanceSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttendanceSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }
  export type AttendanceSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | CourseOfferingDefaultArgs<ExtArgs>
  }

  export type $AttendanceSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceSession"
    objects: {
      offering: Prisma.$CourseOfferingPayload<ExtArgs>
      marks: Prisma.$AttendanceMarkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      offeringId: string
      sessionDate: Date
      createdAt: Date
    }, ExtArgs["result"]["attendanceSession"]>
    composites: {}
  }

  type AttendanceSessionGetPayload<S extends boolean | null | undefined | AttendanceSessionDefaultArgs> = $Result.GetResult<Prisma.$AttendanceSessionPayload, S>

  type AttendanceSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceSessionCountAggregateInputType | true
    }

  export interface AttendanceSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceSession'], meta: { name: 'AttendanceSession' } }
    /**
     * Find zero or one AttendanceSession that matches the filter.
     * @param {AttendanceSessionFindUniqueArgs} args - Arguments to find a AttendanceSession
     * @example
     * // Get one AttendanceSession
     * const attendanceSession = await prisma.attendanceSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceSessionFindUniqueArgs>(args: SelectSubset<T, AttendanceSessionFindUniqueArgs<ExtArgs>>): Prisma__AttendanceSessionClient<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceSessionFindUniqueOrThrowArgs} args - Arguments to find a AttendanceSession
     * @example
     * // Get one AttendanceSession
     * const attendanceSession = await prisma.attendanceSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceSessionClient<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSessionFindFirstArgs} args - Arguments to find a AttendanceSession
     * @example
     * // Get one AttendanceSession
     * const attendanceSession = await prisma.attendanceSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceSessionFindFirstArgs>(args?: SelectSubset<T, AttendanceSessionFindFirstArgs<ExtArgs>>): Prisma__AttendanceSessionClient<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSessionFindFirstOrThrowArgs} args - Arguments to find a AttendanceSession
     * @example
     * // Get one AttendanceSession
     * const attendanceSession = await prisma.attendanceSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceSessionClient<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceSessions
     * const attendanceSessions = await prisma.attendanceSession.findMany()
     * 
     * // Get first 10 AttendanceSessions
     * const attendanceSessions = await prisma.attendanceSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceSessionWithIdOnly = await prisma.attendanceSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceSessionFindManyArgs>(args?: SelectSubset<T, AttendanceSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceSession.
     * @param {AttendanceSessionCreateArgs} args - Arguments to create a AttendanceSession.
     * @example
     * // Create one AttendanceSession
     * const AttendanceSession = await prisma.attendanceSession.create({
     *   data: {
     *     // ... data to create a AttendanceSession
     *   }
     * })
     * 
     */
    create<T extends AttendanceSessionCreateArgs>(args: SelectSubset<T, AttendanceSessionCreateArgs<ExtArgs>>): Prisma__AttendanceSessionClient<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceSessions.
     * @param {AttendanceSessionCreateManyArgs} args - Arguments to create many AttendanceSessions.
     * @example
     * // Create many AttendanceSessions
     * const attendanceSession = await prisma.attendanceSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceSessionCreateManyArgs>(args?: SelectSubset<T, AttendanceSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceSessions and returns the data saved in the database.
     * @param {AttendanceSessionCreateManyAndReturnArgs} args - Arguments to create many AttendanceSessions.
     * @example
     * // Create many AttendanceSessions
     * const attendanceSession = await prisma.attendanceSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceSessions and only return the `id`
     * const attendanceSessionWithIdOnly = await prisma.attendanceSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceSession.
     * @param {AttendanceSessionDeleteArgs} args - Arguments to delete one AttendanceSession.
     * @example
     * // Delete one AttendanceSession
     * const AttendanceSession = await prisma.attendanceSession.delete({
     *   where: {
     *     // ... filter to delete one AttendanceSession
     *   }
     * })
     * 
     */
    delete<T extends AttendanceSessionDeleteArgs>(args: SelectSubset<T, AttendanceSessionDeleteArgs<ExtArgs>>): Prisma__AttendanceSessionClient<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceSession.
     * @param {AttendanceSessionUpdateArgs} args - Arguments to update one AttendanceSession.
     * @example
     * // Update one AttendanceSession
     * const attendanceSession = await prisma.attendanceSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceSessionUpdateArgs>(args: SelectSubset<T, AttendanceSessionUpdateArgs<ExtArgs>>): Prisma__AttendanceSessionClient<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceSessions.
     * @param {AttendanceSessionDeleteManyArgs} args - Arguments to filter AttendanceSessions to delete.
     * @example
     * // Delete a few AttendanceSessions
     * const { count } = await prisma.attendanceSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceSessionDeleteManyArgs>(args?: SelectSubset<T, AttendanceSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceSessions
     * const attendanceSession = await prisma.attendanceSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceSessionUpdateManyArgs>(args: SelectSubset<T, AttendanceSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceSessions and returns the data updated in the database.
     * @param {AttendanceSessionUpdateManyAndReturnArgs} args - Arguments to update many AttendanceSessions.
     * @example
     * // Update many AttendanceSessions
     * const attendanceSession = await prisma.attendanceSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceSessions and only return the `id`
     * const attendanceSessionWithIdOnly = await prisma.attendanceSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceSession.
     * @param {AttendanceSessionUpsertArgs} args - Arguments to update or create a AttendanceSession.
     * @example
     * // Update or create a AttendanceSession
     * const attendanceSession = await prisma.attendanceSession.upsert({
     *   create: {
     *     // ... data to create a AttendanceSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceSession we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceSessionUpsertArgs>(args: SelectSubset<T, AttendanceSessionUpsertArgs<ExtArgs>>): Prisma__AttendanceSessionClient<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSessionCountArgs} args - Arguments to filter AttendanceSessions to count.
     * @example
     * // Count the number of AttendanceSessions
     * const count = await prisma.attendanceSession.count({
     *   where: {
     *     // ... the filter for the AttendanceSessions we want to count
     *   }
     * })
    **/
    count<T extends AttendanceSessionCountArgs>(
      args?: Subset<T, AttendanceSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceSessionAggregateArgs>(args: Subset<T, AttendanceSessionAggregateArgs>): Prisma.PrismaPromise<GetAttendanceSessionAggregateType<T>>

    /**
     * Group by AttendanceSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceSessionGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceSession model
   */
  readonly fields: AttendanceSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offering<T extends CourseOfferingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseOfferingDefaultArgs<ExtArgs>>): Prisma__CourseOfferingClient<$Result.GetResult<Prisma.$CourseOfferingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marks<T extends AttendanceSession$marksArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceSession$marksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceSession model
   */
  interface AttendanceSessionFieldRefs {
    readonly id: FieldRef<"AttendanceSession", 'String'>
    readonly offeringId: FieldRef<"AttendanceSession", 'String'>
    readonly sessionDate: FieldRef<"AttendanceSession", 'DateTime'>
    readonly createdAt: FieldRef<"AttendanceSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceSession findUnique
   */
  export type AttendanceSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSession to fetch.
     */
    where: AttendanceSessionWhereUniqueInput
  }

  /**
   * AttendanceSession findUniqueOrThrow
   */
  export type AttendanceSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSession to fetch.
     */
    where: AttendanceSessionWhereUniqueInput
  }

  /**
   * AttendanceSession findFirst
   */
  export type AttendanceSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSession to fetch.
     */
    where?: AttendanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSessions to fetch.
     */
    orderBy?: AttendanceSessionOrderByWithRelationInput | AttendanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceSessions.
     */
    cursor?: AttendanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceSessions.
     */
    distinct?: AttendanceSessionScalarFieldEnum | AttendanceSessionScalarFieldEnum[]
  }

  /**
   * AttendanceSession findFirstOrThrow
   */
  export type AttendanceSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSession to fetch.
     */
    where?: AttendanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSessions to fetch.
     */
    orderBy?: AttendanceSessionOrderByWithRelationInput | AttendanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceSessions.
     */
    cursor?: AttendanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceSessions.
     */
    distinct?: AttendanceSessionScalarFieldEnum | AttendanceSessionScalarFieldEnum[]
  }

  /**
   * AttendanceSession findMany
   */
  export type AttendanceSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSessions to fetch.
     */
    where?: AttendanceSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSessions to fetch.
     */
    orderBy?: AttendanceSessionOrderByWithRelationInput | AttendanceSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceSessions.
     */
    cursor?: AttendanceSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSessions.
     */
    skip?: number
    distinct?: AttendanceSessionScalarFieldEnum | AttendanceSessionScalarFieldEnum[]
  }

  /**
   * AttendanceSession create
   */
  export type AttendanceSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceSession.
     */
    data: XOR<AttendanceSessionCreateInput, AttendanceSessionUncheckedCreateInput>
  }

  /**
   * AttendanceSession createMany
   */
  export type AttendanceSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceSessions.
     */
    data: AttendanceSessionCreateManyInput | AttendanceSessionCreateManyInput[]
  }

  /**
   * AttendanceSession createManyAndReturn
   */
  export type AttendanceSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceSessions.
     */
    data: AttendanceSessionCreateManyInput | AttendanceSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceSession update
   */
  export type AttendanceSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceSession.
     */
    data: XOR<AttendanceSessionUpdateInput, AttendanceSessionUncheckedUpdateInput>
    /**
     * Choose, which AttendanceSession to update.
     */
    where: AttendanceSessionWhereUniqueInput
  }

  /**
   * AttendanceSession updateMany
   */
  export type AttendanceSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceSessions.
     */
    data: XOR<AttendanceSessionUpdateManyMutationInput, AttendanceSessionUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceSessions to update
     */
    where?: AttendanceSessionWhereInput
    /**
     * Limit how many AttendanceSessions to update.
     */
    limit?: number
  }

  /**
   * AttendanceSession updateManyAndReturn
   */
  export type AttendanceSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceSessions.
     */
    data: XOR<AttendanceSessionUpdateManyMutationInput, AttendanceSessionUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceSessions to update
     */
    where?: AttendanceSessionWhereInput
    /**
     * Limit how many AttendanceSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceSession upsert
   */
  export type AttendanceSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceSession to update in case it exists.
     */
    where: AttendanceSessionWhereUniqueInput
    /**
     * In case the AttendanceSession found by the `where` argument doesn't exist, create a new AttendanceSession with this data.
     */
    create: XOR<AttendanceSessionCreateInput, AttendanceSessionUncheckedCreateInput>
    /**
     * In case the AttendanceSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceSessionUpdateInput, AttendanceSessionUncheckedUpdateInput>
  }

  /**
   * AttendanceSession delete
   */
  export type AttendanceSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
    /**
     * Filter which AttendanceSession to delete.
     */
    where: AttendanceSessionWhereUniqueInput
  }

  /**
   * AttendanceSession deleteMany
   */
  export type AttendanceSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceSessions to delete
     */
    where?: AttendanceSessionWhereInput
    /**
     * Limit how many AttendanceSessions to delete.
     */
    limit?: number
  }

  /**
   * AttendanceSession.marks
   */
  export type AttendanceSession$marksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    where?: AttendanceMarkWhereInput
    orderBy?: AttendanceMarkOrderByWithRelationInput | AttendanceMarkOrderByWithRelationInput[]
    cursor?: AttendanceMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceMarkScalarFieldEnum | AttendanceMarkScalarFieldEnum[]
  }

  /**
   * AttendanceSession without action
   */
  export type AttendanceSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSession
     */
    select?: AttendanceSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSession
     */
    omit?: AttendanceSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSessionInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceMark
   */

  export type AggregateAttendanceMark = {
    _count: AttendanceMarkCountAggregateOutputType | null
    _min: AttendanceMarkMinAggregateOutputType | null
    _max: AttendanceMarkMaxAggregateOutputType | null
  }

  export type AttendanceMarkMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    studentId: string | null
    status: $Enums.AttendanceMarkStatus | null
    note: string | null
    createdAt: Date | null
  }

  export type AttendanceMarkMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    studentId: string | null
    status: $Enums.AttendanceMarkStatus | null
    note: string | null
    createdAt: Date | null
  }

  export type AttendanceMarkCountAggregateOutputType = {
    id: number
    sessionId: number
    studentId: number
    status: number
    note: number
    createdAt: number
    _all: number
  }


  export type AttendanceMarkMinAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    status?: true
    note?: true
    createdAt?: true
  }

  export type AttendanceMarkMaxAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    status?: true
    note?: true
    createdAt?: true
  }

  export type AttendanceMarkCountAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    status?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceMarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceMark to aggregate.
     */
    where?: AttendanceMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceMarks to fetch.
     */
    orderBy?: AttendanceMarkOrderByWithRelationInput | AttendanceMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceMarks
    **/
    _count?: true | AttendanceMarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMarkMaxAggregateInputType
  }

  export type GetAttendanceMarkAggregateType<T extends AttendanceMarkAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceMark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceMark[P]>
      : GetScalarType<T[P], AggregateAttendanceMark[P]>
  }




  export type AttendanceMarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceMarkWhereInput
    orderBy?: AttendanceMarkOrderByWithAggregationInput | AttendanceMarkOrderByWithAggregationInput[]
    by: AttendanceMarkScalarFieldEnum[] | AttendanceMarkScalarFieldEnum
    having?: AttendanceMarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceMarkCountAggregateInputType | true
    _min?: AttendanceMarkMinAggregateInputType
    _max?: AttendanceMarkMaxAggregateInputType
  }

  export type AttendanceMarkGroupByOutputType = {
    id: string
    sessionId: string
    studentId: string
    status: $Enums.AttendanceMarkStatus
    note: string | null
    createdAt: Date
    _count: AttendanceMarkCountAggregateOutputType | null
    _min: AttendanceMarkMinAggregateOutputType | null
    _max: AttendanceMarkMaxAggregateOutputType | null
  }

  type GetAttendanceMarkGroupByPayload<T extends AttendanceMarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceMarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceMarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceMarkGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceMarkGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceMarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    session?: boolean | AttendanceSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceMark"]>

  export type AttendanceMarkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    session?: boolean | AttendanceSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceMark"]>

  export type AttendanceMarkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    session?: boolean | AttendanceSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceMark"]>

  export type AttendanceMarkSelectScalar = {
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type AttendanceMarkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "studentId" | "status" | "note" | "createdAt", ExtArgs["result"]["attendanceMark"]>
  export type AttendanceMarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AttendanceSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type AttendanceMarkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AttendanceSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type AttendanceMarkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AttendanceSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $AttendanceMarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceMark"
    objects: {
      session: Prisma.$AttendanceSessionPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      studentId: string
      status: $Enums.AttendanceMarkStatus
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["attendanceMark"]>
    composites: {}
  }

  type AttendanceMarkGetPayload<S extends boolean | null | undefined | AttendanceMarkDefaultArgs> = $Result.GetResult<Prisma.$AttendanceMarkPayload, S>

  type AttendanceMarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceMarkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceMarkCountAggregateInputType | true
    }

  export interface AttendanceMarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceMark'], meta: { name: 'AttendanceMark' } }
    /**
     * Find zero or one AttendanceMark that matches the filter.
     * @param {AttendanceMarkFindUniqueArgs} args - Arguments to find a AttendanceMark
     * @example
     * // Get one AttendanceMark
     * const attendanceMark = await prisma.attendanceMark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceMarkFindUniqueArgs>(args: SelectSubset<T, AttendanceMarkFindUniqueArgs<ExtArgs>>): Prisma__AttendanceMarkClient<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceMark that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceMarkFindUniqueOrThrowArgs} args - Arguments to find a AttendanceMark
     * @example
     * // Get one AttendanceMark
     * const attendanceMark = await prisma.attendanceMark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceMarkFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceMarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceMarkClient<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceMark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceMarkFindFirstArgs} args - Arguments to find a AttendanceMark
     * @example
     * // Get one AttendanceMark
     * const attendanceMark = await prisma.attendanceMark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceMarkFindFirstArgs>(args?: SelectSubset<T, AttendanceMarkFindFirstArgs<ExtArgs>>): Prisma__AttendanceMarkClient<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceMark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceMarkFindFirstOrThrowArgs} args - Arguments to find a AttendanceMark
     * @example
     * // Get one AttendanceMark
     * const attendanceMark = await prisma.attendanceMark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceMarkFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceMarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceMarkClient<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceMarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceMarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceMarks
     * const attendanceMarks = await prisma.attendanceMark.findMany()
     * 
     * // Get first 10 AttendanceMarks
     * const attendanceMarks = await prisma.attendanceMark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceMarkWithIdOnly = await prisma.attendanceMark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceMarkFindManyArgs>(args?: SelectSubset<T, AttendanceMarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceMark.
     * @param {AttendanceMarkCreateArgs} args - Arguments to create a AttendanceMark.
     * @example
     * // Create one AttendanceMark
     * const AttendanceMark = await prisma.attendanceMark.create({
     *   data: {
     *     // ... data to create a AttendanceMark
     *   }
     * })
     * 
     */
    create<T extends AttendanceMarkCreateArgs>(args: SelectSubset<T, AttendanceMarkCreateArgs<ExtArgs>>): Prisma__AttendanceMarkClient<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceMarks.
     * @param {AttendanceMarkCreateManyArgs} args - Arguments to create many AttendanceMarks.
     * @example
     * // Create many AttendanceMarks
     * const attendanceMark = await prisma.attendanceMark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceMarkCreateManyArgs>(args?: SelectSubset<T, AttendanceMarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceMarks and returns the data saved in the database.
     * @param {AttendanceMarkCreateManyAndReturnArgs} args - Arguments to create many AttendanceMarks.
     * @example
     * // Create many AttendanceMarks
     * const attendanceMark = await prisma.attendanceMark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceMarks and only return the `id`
     * const attendanceMarkWithIdOnly = await prisma.attendanceMark.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceMarkCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceMarkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceMark.
     * @param {AttendanceMarkDeleteArgs} args - Arguments to delete one AttendanceMark.
     * @example
     * // Delete one AttendanceMark
     * const AttendanceMark = await prisma.attendanceMark.delete({
     *   where: {
     *     // ... filter to delete one AttendanceMark
     *   }
     * })
     * 
     */
    delete<T extends AttendanceMarkDeleteArgs>(args: SelectSubset<T, AttendanceMarkDeleteArgs<ExtArgs>>): Prisma__AttendanceMarkClient<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceMark.
     * @param {AttendanceMarkUpdateArgs} args - Arguments to update one AttendanceMark.
     * @example
     * // Update one AttendanceMark
     * const attendanceMark = await prisma.attendanceMark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceMarkUpdateArgs>(args: SelectSubset<T, AttendanceMarkUpdateArgs<ExtArgs>>): Prisma__AttendanceMarkClient<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceMarks.
     * @param {AttendanceMarkDeleteManyArgs} args - Arguments to filter AttendanceMarks to delete.
     * @example
     * // Delete a few AttendanceMarks
     * const { count } = await prisma.attendanceMark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceMarkDeleteManyArgs>(args?: SelectSubset<T, AttendanceMarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceMarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceMarks
     * const attendanceMark = await prisma.attendanceMark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceMarkUpdateManyArgs>(args: SelectSubset<T, AttendanceMarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceMarks and returns the data updated in the database.
     * @param {AttendanceMarkUpdateManyAndReturnArgs} args - Arguments to update many AttendanceMarks.
     * @example
     * // Update many AttendanceMarks
     * const attendanceMark = await prisma.attendanceMark.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceMarks and only return the `id`
     * const attendanceMarkWithIdOnly = await prisma.attendanceMark.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceMarkUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceMarkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceMark.
     * @param {AttendanceMarkUpsertArgs} args - Arguments to update or create a AttendanceMark.
     * @example
     * // Update or create a AttendanceMark
     * const attendanceMark = await prisma.attendanceMark.upsert({
     *   create: {
     *     // ... data to create a AttendanceMark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceMark we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceMarkUpsertArgs>(args: SelectSubset<T, AttendanceMarkUpsertArgs<ExtArgs>>): Prisma__AttendanceMarkClient<$Result.GetResult<Prisma.$AttendanceMarkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceMarkCountArgs} args - Arguments to filter AttendanceMarks to count.
     * @example
     * // Count the number of AttendanceMarks
     * const count = await prisma.attendanceMark.count({
     *   where: {
     *     // ... the filter for the AttendanceMarks we want to count
     *   }
     * })
    **/
    count<T extends AttendanceMarkCountArgs>(
      args?: Subset<T, AttendanceMarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceMarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceMarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceMarkAggregateArgs>(args: Subset<T, AttendanceMarkAggregateArgs>): Prisma.PrismaPromise<GetAttendanceMarkAggregateType<T>>

    /**
     * Group by AttendanceMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceMarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceMarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceMarkGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceMarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceMarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceMarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceMark model
   */
  readonly fields: AttendanceMarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceMark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceMarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends AttendanceSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceSessionDefaultArgs<ExtArgs>>): Prisma__AttendanceSessionClient<$Result.GetResult<Prisma.$AttendanceSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceMark model
   */
  interface AttendanceMarkFieldRefs {
    readonly id: FieldRef<"AttendanceMark", 'String'>
    readonly sessionId: FieldRef<"AttendanceMark", 'String'>
    readonly studentId: FieldRef<"AttendanceMark", 'String'>
    readonly status: FieldRef<"AttendanceMark", 'AttendanceMarkStatus'>
    readonly note: FieldRef<"AttendanceMark", 'String'>
    readonly createdAt: FieldRef<"AttendanceMark", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceMark findUnique
   */
  export type AttendanceMarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceMark to fetch.
     */
    where: AttendanceMarkWhereUniqueInput
  }

  /**
   * AttendanceMark findUniqueOrThrow
   */
  export type AttendanceMarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceMark to fetch.
     */
    where: AttendanceMarkWhereUniqueInput
  }

  /**
   * AttendanceMark findFirst
   */
  export type AttendanceMarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceMark to fetch.
     */
    where?: AttendanceMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceMarks to fetch.
     */
    orderBy?: AttendanceMarkOrderByWithRelationInput | AttendanceMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceMarks.
     */
    cursor?: AttendanceMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceMarks.
     */
    distinct?: AttendanceMarkScalarFieldEnum | AttendanceMarkScalarFieldEnum[]
  }

  /**
   * AttendanceMark findFirstOrThrow
   */
  export type AttendanceMarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceMark to fetch.
     */
    where?: AttendanceMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceMarks to fetch.
     */
    orderBy?: AttendanceMarkOrderByWithRelationInput | AttendanceMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceMarks.
     */
    cursor?: AttendanceMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceMarks.
     */
    distinct?: AttendanceMarkScalarFieldEnum | AttendanceMarkScalarFieldEnum[]
  }

  /**
   * AttendanceMark findMany
   */
  export type AttendanceMarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceMarks to fetch.
     */
    where?: AttendanceMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceMarks to fetch.
     */
    orderBy?: AttendanceMarkOrderByWithRelationInput | AttendanceMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceMarks.
     */
    cursor?: AttendanceMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceMarks.
     */
    skip?: number
    distinct?: AttendanceMarkScalarFieldEnum | AttendanceMarkScalarFieldEnum[]
  }

  /**
   * AttendanceMark create
   */
  export type AttendanceMarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceMark.
     */
    data: XOR<AttendanceMarkCreateInput, AttendanceMarkUncheckedCreateInput>
  }

  /**
   * AttendanceMark createMany
   */
  export type AttendanceMarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceMarks.
     */
    data: AttendanceMarkCreateManyInput | AttendanceMarkCreateManyInput[]
  }

  /**
   * AttendanceMark createManyAndReturn
   */
  export type AttendanceMarkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceMarks.
     */
    data: AttendanceMarkCreateManyInput | AttendanceMarkCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceMark update
   */
  export type AttendanceMarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceMark.
     */
    data: XOR<AttendanceMarkUpdateInput, AttendanceMarkUncheckedUpdateInput>
    /**
     * Choose, which AttendanceMark to update.
     */
    where: AttendanceMarkWhereUniqueInput
  }

  /**
   * AttendanceMark updateMany
   */
  export type AttendanceMarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceMarks.
     */
    data: XOR<AttendanceMarkUpdateManyMutationInput, AttendanceMarkUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceMarks to update
     */
    where?: AttendanceMarkWhereInput
    /**
     * Limit how many AttendanceMarks to update.
     */
    limit?: number
  }

  /**
   * AttendanceMark updateManyAndReturn
   */
  export type AttendanceMarkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceMarks.
     */
    data: XOR<AttendanceMarkUpdateManyMutationInput, AttendanceMarkUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceMarks to update
     */
    where?: AttendanceMarkWhereInput
    /**
     * Limit how many AttendanceMarks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceMark upsert
   */
  export type AttendanceMarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceMark to update in case it exists.
     */
    where: AttendanceMarkWhereUniqueInput
    /**
     * In case the AttendanceMark found by the `where` argument doesn't exist, create a new AttendanceMark with this data.
     */
    create: XOR<AttendanceMarkCreateInput, AttendanceMarkUncheckedCreateInput>
    /**
     * In case the AttendanceMark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceMarkUpdateInput, AttendanceMarkUncheckedUpdateInput>
  }

  /**
   * AttendanceMark delete
   */
  export type AttendanceMarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
    /**
     * Filter which AttendanceMark to delete.
     */
    where: AttendanceMarkWhereUniqueInput
  }

  /**
   * AttendanceMark deleteMany
   */
  export type AttendanceMarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceMarks to delete
     */
    where?: AttendanceMarkWhereInput
    /**
     * Limit how many AttendanceMarks to delete.
     */
    limit?: number
  }

  /**
   * AttendanceMark without action
   */
  export type AttendanceMarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceMark
     */
    select?: AttendanceMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceMark
     */
    omit?: AttendanceMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceMarkInclude<ExtArgs> | null
  }


  /**
   * Model LibraryBook
   */

  export type AggregateLibraryBook = {
    _count: LibraryBookCountAggregateOutputType | null
    _min: LibraryBookMinAggregateOutputType | null
    _max: LibraryBookMaxAggregateOutputType | null
  }

  export type LibraryBookMinAggregateOutputType = {
    id: string | null
    title: string | null
    author: string | null
    isbn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookMaxAggregateOutputType = {
    id: string | null
    title: string | null
    author: string | null
    isbn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookCountAggregateOutputType = {
    id: number
    title: number
    author: number
    isbn: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryBookMinAggregateInputType = {
    id?: true
    title?: true
    author?: true
    isbn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookMaxAggregateInputType = {
    id?: true
    title?: true
    author?: true
    isbn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookCountAggregateInputType = {
    id?: true
    title?: true
    author?: true
    isbn?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryBook to aggregate.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: LibraryBookOrderByWithRelationInput | LibraryBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBooks
    **/
    _count?: true | LibraryBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBookMaxAggregateInputType
  }

  export type GetLibraryBookAggregateType<T extends LibraryBookAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBook[P]>
      : GetScalarType<T[P], AggregateLibraryBook[P]>
  }




  export type LibraryBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryBookWhereInput
    orderBy?: LibraryBookOrderByWithAggregationInput | LibraryBookOrderByWithAggregationInput[]
    by: LibraryBookScalarFieldEnum[] | LibraryBookScalarFieldEnum
    having?: LibraryBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBookCountAggregateInputType | true
    _min?: LibraryBookMinAggregateInputType
    _max?: LibraryBookMaxAggregateInputType
  }

  export type LibraryBookGroupByOutputType = {
    id: string
    title: string
    author: string
    isbn: string | null
    createdAt: Date
    updatedAt: Date
    _count: LibraryBookCountAggregateOutputType | null
    _min: LibraryBookMinAggregateOutputType | null
    _max: LibraryBookMaxAggregateOutputType | null
  }

  type GetLibraryBookGroupByPayload<T extends LibraryBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    isbn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    copies?: boolean | LibraryBook$copiesArgs<ExtArgs>
    _count?: boolean | LibraryBookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryBook"]>

  export type LibraryBookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    isbn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["libraryBook"]>

  export type LibraryBookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    isbn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["libraryBook"]>

  export type LibraryBookSelectScalar = {
    id?: boolean
    title?: boolean
    author?: boolean
    isbn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LibraryBookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "author" | "isbn" | "createdAt" | "updatedAt", ExtArgs["result"]["libraryBook"]>
  export type LibraryBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    copies?: boolean | LibraryBook$copiesArgs<ExtArgs>
    _count?: boolean | LibraryBookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LibraryBookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LibraryBookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LibraryBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LibraryBook"
    objects: {
      copies: Prisma.$LibraryCopyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      author: string
      isbn: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["libraryBook"]>
    composites: {}
  }

  type LibraryBookGetPayload<S extends boolean | null | undefined | LibraryBookDefaultArgs> = $Result.GetResult<Prisma.$LibraryBookPayload, S>

  type LibraryBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LibraryBookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LibraryBookCountAggregateInputType | true
    }

  export interface LibraryBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LibraryBook'], meta: { name: 'LibraryBook' } }
    /**
     * Find zero or one LibraryBook that matches the filter.
     * @param {LibraryBookFindUniqueArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LibraryBookFindUniqueArgs>(args: SelectSubset<T, LibraryBookFindUniqueArgs<ExtArgs>>): Prisma__LibraryBookClient<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LibraryBook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LibraryBookFindUniqueOrThrowArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LibraryBookFindUniqueOrThrowArgs>(args: SelectSubset<T, LibraryBookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LibraryBookClient<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LibraryBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindFirstArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LibraryBookFindFirstArgs>(args?: SelectSubset<T, LibraryBookFindFirstArgs<ExtArgs>>): Prisma__LibraryBookClient<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LibraryBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindFirstOrThrowArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LibraryBookFindFirstOrThrowArgs>(args?: SelectSubset<T, LibraryBookFindFirstOrThrowArgs<ExtArgs>>): Prisma__LibraryBookClient<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LibraryBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBooks
     * const libraryBooks = await prisma.libraryBook.findMany()
     * 
     * // Get first 10 LibraryBooks
     * const libraryBooks = await prisma.libraryBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBookWithIdOnly = await prisma.libraryBook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LibraryBookFindManyArgs>(args?: SelectSubset<T, LibraryBookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LibraryBook.
     * @param {LibraryBookCreateArgs} args - Arguments to create a LibraryBook.
     * @example
     * // Create one LibraryBook
     * const LibraryBook = await prisma.libraryBook.create({
     *   data: {
     *     // ... data to create a LibraryBook
     *   }
     * })
     * 
     */
    create<T extends LibraryBookCreateArgs>(args: SelectSubset<T, LibraryBookCreateArgs<ExtArgs>>): Prisma__LibraryBookClient<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LibraryBooks.
     * @param {LibraryBookCreateManyArgs} args - Arguments to create many LibraryBooks.
     * @example
     * // Create many LibraryBooks
     * const libraryBook = await prisma.libraryBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LibraryBookCreateManyArgs>(args?: SelectSubset<T, LibraryBookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LibraryBooks and returns the data saved in the database.
     * @param {LibraryBookCreateManyAndReturnArgs} args - Arguments to create many LibraryBooks.
     * @example
     * // Create many LibraryBooks
     * const libraryBook = await prisma.libraryBook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LibraryBooks and only return the `id`
     * const libraryBookWithIdOnly = await prisma.libraryBook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LibraryBookCreateManyAndReturnArgs>(args?: SelectSubset<T, LibraryBookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LibraryBook.
     * @param {LibraryBookDeleteArgs} args - Arguments to delete one LibraryBook.
     * @example
     * // Delete one LibraryBook
     * const LibraryBook = await prisma.libraryBook.delete({
     *   where: {
     *     // ... filter to delete one LibraryBook
     *   }
     * })
     * 
     */
    delete<T extends LibraryBookDeleteArgs>(args: SelectSubset<T, LibraryBookDeleteArgs<ExtArgs>>): Prisma__LibraryBookClient<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LibraryBook.
     * @param {LibraryBookUpdateArgs} args - Arguments to update one LibraryBook.
     * @example
     * // Update one LibraryBook
     * const libraryBook = await prisma.libraryBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LibraryBookUpdateArgs>(args: SelectSubset<T, LibraryBookUpdateArgs<ExtArgs>>): Prisma__LibraryBookClient<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LibraryBooks.
     * @param {LibraryBookDeleteManyArgs} args - Arguments to filter LibraryBooks to delete.
     * @example
     * // Delete a few LibraryBooks
     * const { count } = await prisma.libraryBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LibraryBookDeleteManyArgs>(args?: SelectSubset<T, LibraryBookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBooks
     * const libraryBook = await prisma.libraryBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LibraryBookUpdateManyArgs>(args: SelectSubset<T, LibraryBookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBooks and returns the data updated in the database.
     * @param {LibraryBookUpdateManyAndReturnArgs} args - Arguments to update many LibraryBooks.
     * @example
     * // Update many LibraryBooks
     * const libraryBook = await prisma.libraryBook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LibraryBooks and only return the `id`
     * const libraryBookWithIdOnly = await prisma.libraryBook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LibraryBookUpdateManyAndReturnArgs>(args: SelectSubset<T, LibraryBookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LibraryBook.
     * @param {LibraryBookUpsertArgs} args - Arguments to update or create a LibraryBook.
     * @example
     * // Update or create a LibraryBook
     * const libraryBook = await prisma.libraryBook.upsert({
     *   create: {
     *     // ... data to create a LibraryBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBook we want to update
     *   }
     * })
     */
    upsert<T extends LibraryBookUpsertArgs>(args: SelectSubset<T, LibraryBookUpsertArgs<ExtArgs>>): Prisma__LibraryBookClient<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LibraryBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCountArgs} args - Arguments to filter LibraryBooks to count.
     * @example
     * // Count the number of LibraryBooks
     * const count = await prisma.libraryBook.count({
     *   where: {
     *     // ... the filter for the LibraryBooks we want to count
     *   }
     * })
    **/
    count<T extends LibraryBookCountArgs>(
      args?: Subset<T, LibraryBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBookAggregateArgs>(args: Subset<T, LibraryBookAggregateArgs>): Prisma.PrismaPromise<GetLibraryBookAggregateType<T>>

    /**
     * Group by LibraryBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LibraryBook model
   */
  readonly fields: LibraryBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LibraryBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    copies<T extends LibraryBook$copiesArgs<ExtArgs> = {}>(args?: Subset<T, LibraryBook$copiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LibraryBook model
   */
  interface LibraryBookFieldRefs {
    readonly id: FieldRef<"LibraryBook", 'String'>
    readonly title: FieldRef<"LibraryBook", 'String'>
    readonly author: FieldRef<"LibraryBook", 'String'>
    readonly isbn: FieldRef<"LibraryBook", 'String'>
    readonly createdAt: FieldRef<"LibraryBook", 'DateTime'>
    readonly updatedAt: FieldRef<"LibraryBook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LibraryBook findUnique
   */
  export type LibraryBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where: LibraryBookWhereUniqueInput
  }

  /**
   * LibraryBook findUniqueOrThrow
   */
  export type LibraryBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where: LibraryBookWhereUniqueInput
  }

  /**
   * LibraryBook findFirst
   */
  export type LibraryBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: LibraryBookOrderByWithRelationInput | LibraryBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBooks.
     */
    distinct?: LibraryBookScalarFieldEnum | LibraryBookScalarFieldEnum[]
  }

  /**
   * LibraryBook findFirstOrThrow
   */
  export type LibraryBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: LibraryBookOrderByWithRelationInput | LibraryBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBooks.
     */
    distinct?: LibraryBookScalarFieldEnum | LibraryBookScalarFieldEnum[]
  }

  /**
   * LibraryBook findMany
   */
  export type LibraryBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null
    /**
     * Filter, which LibraryBooks to fetch.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: LibraryBookOrderByWithRelationInput | LibraryBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    distinct?: LibraryBookScalarFieldEnum | LibraryBookScalarFieldEnum[]
  }

  /**
   * LibraryBook create
   */
  export type LibraryBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null
    /**
     * The data needed to create a LibraryBook.
     */
    data: XOR<LibraryBookCreateInput, LibraryBookUncheckedCreateInput>
  }

  /**
   * LibraryBook createMany
   */
  export type LibraryBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LibraryBooks.
     */
    data: LibraryBookCreateManyInput | LibraryBookCreateManyInput[]
  }

  /**
   * LibraryBook createManyAndReturn
   */
  export type LibraryBookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * The data used to create many LibraryBooks.
     */
    data: LibraryBookCreateManyInput | LibraryBookCreateManyInput[]
  }

  /**
   * LibraryBook update
   */
  export type LibraryBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null
    /**
     * The data needed to update a LibraryBook.
     */
    data: XOR<LibraryBookUpdateInput, LibraryBookUncheckedUpdateInput>
    /**
     * Choose, which LibraryBook to update.
     */
    where: LibraryBookWhereUniqueInput
  }

  /**
   * LibraryBook updateMany
   */
  export type LibraryBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LibraryBooks.
     */
    data: XOR<LibraryBookUpdateManyMutationInput, LibraryBookUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBooks to update
     */
    where?: LibraryBookWhereInput
    /**
     * Limit how many LibraryBooks to update.
     */
    limit?: number
  }

  /**
   * LibraryBook updateManyAndReturn
   */
  export type LibraryBookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * The data used to update LibraryBooks.
     */
    data: XOR<LibraryBookUpdateManyMutationInput, LibraryBookUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBooks to update
     */
    where?: LibraryBookWhereInput
    /**
     * Limit how many LibraryBooks to update.
     */
    limit?: number
  }

  /**
   * LibraryBook upsert
   */
  export type LibraryBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null
    /**
     * The filter to search for the LibraryBook to update in case it exists.
     */
    where: LibraryBookWhereUniqueInput
    /**
     * In case the LibraryBook found by the `where` argument doesn't exist, create a new LibraryBook with this data.
     */
    create: XOR<LibraryBookCreateInput, LibraryBookUncheckedCreateInput>
    /**
     * In case the LibraryBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookUpdateInput, LibraryBookUncheckedUpdateInput>
  }

  /**
   * LibraryBook delete
   */
  export type LibraryBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null
    /**
     * Filter which LibraryBook to delete.
     */
    where: LibraryBookWhereUniqueInput
  }

  /**
   * LibraryBook deleteMany
   */
  export type LibraryBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryBooks to delete
     */
    where?: LibraryBookWhereInput
    /**
     * Limit how many LibraryBooks to delete.
     */
    limit?: number
  }

  /**
   * LibraryBook.copies
   */
  export type LibraryBook$copiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
    where?: LibraryCopyWhereInput
    orderBy?: LibraryCopyOrderByWithRelationInput | LibraryCopyOrderByWithRelationInput[]
    cursor?: LibraryCopyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LibraryCopyScalarFieldEnum | LibraryCopyScalarFieldEnum[]
  }

  /**
   * LibraryBook without action
   */
  export type LibraryBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryBook
     */
    omit?: LibraryBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryBookInclude<ExtArgs> | null
  }


  /**
   * Model LibraryCopy
   */

  export type AggregateLibraryCopy = {
    _count: LibraryCopyCountAggregateOutputType | null
    _min: LibraryCopyMinAggregateOutputType | null
    _max: LibraryCopyMaxAggregateOutputType | null
  }

  export type LibraryCopyMinAggregateOutputType = {
    id: string | null
    bookId: string | null
    barcode: string | null
    status: $Enums.LibraryCopyStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryCopyMaxAggregateOutputType = {
    id: string | null
    bookId: string | null
    barcode: string | null
    status: $Enums.LibraryCopyStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryCopyCountAggregateOutputType = {
    id: number
    bookId: number
    barcode: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryCopyMinAggregateInputType = {
    id?: true
    bookId?: true
    barcode?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryCopyMaxAggregateInputType = {
    id?: true
    bookId?: true
    barcode?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryCopyCountAggregateInputType = {
    id?: true
    bookId?: true
    barcode?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryCopyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryCopy to aggregate.
     */
    where?: LibraryCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCopies to fetch.
     */
    orderBy?: LibraryCopyOrderByWithRelationInput | LibraryCopyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryCopies
    **/
    _count?: true | LibraryCopyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryCopyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryCopyMaxAggregateInputType
  }

  export type GetLibraryCopyAggregateType<T extends LibraryCopyAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryCopy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryCopy[P]>
      : GetScalarType<T[P], AggregateLibraryCopy[P]>
  }




  export type LibraryCopyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryCopyWhereInput
    orderBy?: LibraryCopyOrderByWithAggregationInput | LibraryCopyOrderByWithAggregationInput[]
    by: LibraryCopyScalarFieldEnum[] | LibraryCopyScalarFieldEnum
    having?: LibraryCopyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryCopyCountAggregateInputType | true
    _min?: LibraryCopyMinAggregateInputType
    _max?: LibraryCopyMaxAggregateInputType
  }

  export type LibraryCopyGroupByOutputType = {
    id: string
    bookId: string
    barcode: string
    status: $Enums.LibraryCopyStatus
    createdAt: Date
    updatedAt: Date
    _count: LibraryCopyCountAggregateOutputType | null
    _min: LibraryCopyMinAggregateOutputType | null
    _max: LibraryCopyMaxAggregateOutputType | null
  }

  type GetLibraryCopyGroupByPayload<T extends LibraryCopyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryCopyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryCopyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryCopyGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryCopyGroupByOutputType[P]>
        }
      >
    >


  export type LibraryCopySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    barcode?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    book?: boolean | LibraryBookDefaultArgs<ExtArgs>
    issues?: boolean | LibraryCopy$issuesArgs<ExtArgs>
    _count?: boolean | LibraryCopyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryCopy"]>

  export type LibraryCopySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    barcode?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    book?: boolean | LibraryBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryCopy"]>

  export type LibraryCopySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    barcode?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    book?: boolean | LibraryBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryCopy"]>

  export type LibraryCopySelectScalar = {
    id?: boolean
    bookId?: boolean
    barcode?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LibraryCopyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookId" | "barcode" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["libraryCopy"]>
  export type LibraryCopyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | LibraryBookDefaultArgs<ExtArgs>
    issues?: boolean | LibraryCopy$issuesArgs<ExtArgs>
    _count?: boolean | LibraryCopyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LibraryCopyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | LibraryBookDefaultArgs<ExtArgs>
  }
  export type LibraryCopyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | LibraryBookDefaultArgs<ExtArgs>
  }

  export type $LibraryCopyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LibraryCopy"
    objects: {
      book: Prisma.$LibraryBookPayload<ExtArgs>
      issues: Prisma.$LibraryIssuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookId: string
      barcode: string
      status: $Enums.LibraryCopyStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["libraryCopy"]>
    composites: {}
  }

  type LibraryCopyGetPayload<S extends boolean | null | undefined | LibraryCopyDefaultArgs> = $Result.GetResult<Prisma.$LibraryCopyPayload, S>

  type LibraryCopyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LibraryCopyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LibraryCopyCountAggregateInputType | true
    }

  export interface LibraryCopyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LibraryCopy'], meta: { name: 'LibraryCopy' } }
    /**
     * Find zero or one LibraryCopy that matches the filter.
     * @param {LibraryCopyFindUniqueArgs} args - Arguments to find a LibraryCopy
     * @example
     * // Get one LibraryCopy
     * const libraryCopy = await prisma.libraryCopy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LibraryCopyFindUniqueArgs>(args: SelectSubset<T, LibraryCopyFindUniqueArgs<ExtArgs>>): Prisma__LibraryCopyClient<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LibraryCopy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LibraryCopyFindUniqueOrThrowArgs} args - Arguments to find a LibraryCopy
     * @example
     * // Get one LibraryCopy
     * const libraryCopy = await prisma.libraryCopy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LibraryCopyFindUniqueOrThrowArgs>(args: SelectSubset<T, LibraryCopyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LibraryCopyClient<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LibraryCopy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCopyFindFirstArgs} args - Arguments to find a LibraryCopy
     * @example
     * // Get one LibraryCopy
     * const libraryCopy = await prisma.libraryCopy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LibraryCopyFindFirstArgs>(args?: SelectSubset<T, LibraryCopyFindFirstArgs<ExtArgs>>): Prisma__LibraryCopyClient<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LibraryCopy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCopyFindFirstOrThrowArgs} args - Arguments to find a LibraryCopy
     * @example
     * // Get one LibraryCopy
     * const libraryCopy = await prisma.libraryCopy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LibraryCopyFindFirstOrThrowArgs>(args?: SelectSubset<T, LibraryCopyFindFirstOrThrowArgs<ExtArgs>>): Prisma__LibraryCopyClient<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LibraryCopies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCopyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryCopies
     * const libraryCopies = await prisma.libraryCopy.findMany()
     * 
     * // Get first 10 LibraryCopies
     * const libraryCopies = await prisma.libraryCopy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryCopyWithIdOnly = await prisma.libraryCopy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LibraryCopyFindManyArgs>(args?: SelectSubset<T, LibraryCopyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LibraryCopy.
     * @param {LibraryCopyCreateArgs} args - Arguments to create a LibraryCopy.
     * @example
     * // Create one LibraryCopy
     * const LibraryCopy = await prisma.libraryCopy.create({
     *   data: {
     *     // ... data to create a LibraryCopy
     *   }
     * })
     * 
     */
    create<T extends LibraryCopyCreateArgs>(args: SelectSubset<T, LibraryCopyCreateArgs<ExtArgs>>): Prisma__LibraryCopyClient<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LibraryCopies.
     * @param {LibraryCopyCreateManyArgs} args - Arguments to create many LibraryCopies.
     * @example
     * // Create many LibraryCopies
     * const libraryCopy = await prisma.libraryCopy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LibraryCopyCreateManyArgs>(args?: SelectSubset<T, LibraryCopyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LibraryCopies and returns the data saved in the database.
     * @param {LibraryCopyCreateManyAndReturnArgs} args - Arguments to create many LibraryCopies.
     * @example
     * // Create many LibraryCopies
     * const libraryCopy = await prisma.libraryCopy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LibraryCopies and only return the `id`
     * const libraryCopyWithIdOnly = await prisma.libraryCopy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LibraryCopyCreateManyAndReturnArgs>(args?: SelectSubset<T, LibraryCopyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LibraryCopy.
     * @param {LibraryCopyDeleteArgs} args - Arguments to delete one LibraryCopy.
     * @example
     * // Delete one LibraryCopy
     * const LibraryCopy = await prisma.libraryCopy.delete({
     *   where: {
     *     // ... filter to delete one LibraryCopy
     *   }
     * })
     * 
     */
    delete<T extends LibraryCopyDeleteArgs>(args: SelectSubset<T, LibraryCopyDeleteArgs<ExtArgs>>): Prisma__LibraryCopyClient<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LibraryCopy.
     * @param {LibraryCopyUpdateArgs} args - Arguments to update one LibraryCopy.
     * @example
     * // Update one LibraryCopy
     * const libraryCopy = await prisma.libraryCopy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LibraryCopyUpdateArgs>(args: SelectSubset<T, LibraryCopyUpdateArgs<ExtArgs>>): Prisma__LibraryCopyClient<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LibraryCopies.
     * @param {LibraryCopyDeleteManyArgs} args - Arguments to filter LibraryCopies to delete.
     * @example
     * // Delete a few LibraryCopies
     * const { count } = await prisma.libraryCopy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LibraryCopyDeleteManyArgs>(args?: SelectSubset<T, LibraryCopyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryCopies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCopyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryCopies
     * const libraryCopy = await prisma.libraryCopy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LibraryCopyUpdateManyArgs>(args: SelectSubset<T, LibraryCopyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryCopies and returns the data updated in the database.
     * @param {LibraryCopyUpdateManyAndReturnArgs} args - Arguments to update many LibraryCopies.
     * @example
     * // Update many LibraryCopies
     * const libraryCopy = await prisma.libraryCopy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LibraryCopies and only return the `id`
     * const libraryCopyWithIdOnly = await prisma.libraryCopy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LibraryCopyUpdateManyAndReturnArgs>(args: SelectSubset<T, LibraryCopyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LibraryCopy.
     * @param {LibraryCopyUpsertArgs} args - Arguments to update or create a LibraryCopy.
     * @example
     * // Update or create a LibraryCopy
     * const libraryCopy = await prisma.libraryCopy.upsert({
     *   create: {
     *     // ... data to create a LibraryCopy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryCopy we want to update
     *   }
     * })
     */
    upsert<T extends LibraryCopyUpsertArgs>(args: SelectSubset<T, LibraryCopyUpsertArgs<ExtArgs>>): Prisma__LibraryCopyClient<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LibraryCopies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCopyCountArgs} args - Arguments to filter LibraryCopies to count.
     * @example
     * // Count the number of LibraryCopies
     * const count = await prisma.libraryCopy.count({
     *   where: {
     *     // ... the filter for the LibraryCopies we want to count
     *   }
     * })
    **/
    count<T extends LibraryCopyCountArgs>(
      args?: Subset<T, LibraryCopyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryCopyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryCopy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCopyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryCopyAggregateArgs>(args: Subset<T, LibraryCopyAggregateArgs>): Prisma.PrismaPromise<GetLibraryCopyAggregateType<T>>

    /**
     * Group by LibraryCopy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCopyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryCopyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryCopyGroupByArgs['orderBy'] }
        : { orderBy?: LibraryCopyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryCopyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryCopyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LibraryCopy model
   */
  readonly fields: LibraryCopyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryCopy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LibraryCopyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends LibraryBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LibraryBookDefaultArgs<ExtArgs>>): Prisma__LibraryBookClient<$Result.GetResult<Prisma.$LibraryBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    issues<T extends LibraryCopy$issuesArgs<ExtArgs> = {}>(args?: Subset<T, LibraryCopy$issuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LibraryCopy model
   */
  interface LibraryCopyFieldRefs {
    readonly id: FieldRef<"LibraryCopy", 'String'>
    readonly bookId: FieldRef<"LibraryCopy", 'String'>
    readonly barcode: FieldRef<"LibraryCopy", 'String'>
    readonly status: FieldRef<"LibraryCopy", 'LibraryCopyStatus'>
    readonly createdAt: FieldRef<"LibraryCopy", 'DateTime'>
    readonly updatedAt: FieldRef<"LibraryCopy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LibraryCopy findUnique
   */
  export type LibraryCopyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
    /**
     * Filter, which LibraryCopy to fetch.
     */
    where: LibraryCopyWhereUniqueInput
  }

  /**
   * LibraryCopy findUniqueOrThrow
   */
  export type LibraryCopyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
    /**
     * Filter, which LibraryCopy to fetch.
     */
    where: LibraryCopyWhereUniqueInput
  }

  /**
   * LibraryCopy findFirst
   */
  export type LibraryCopyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
    /**
     * Filter, which LibraryCopy to fetch.
     */
    where?: LibraryCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCopies to fetch.
     */
    orderBy?: LibraryCopyOrderByWithRelationInput | LibraryCopyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryCopies.
     */
    cursor?: LibraryCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryCopies.
     */
    distinct?: LibraryCopyScalarFieldEnum | LibraryCopyScalarFieldEnum[]
  }

  /**
   * LibraryCopy findFirstOrThrow
   */
  export type LibraryCopyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
    /**
     * Filter, which LibraryCopy to fetch.
     */
    where?: LibraryCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCopies to fetch.
     */
    orderBy?: LibraryCopyOrderByWithRelationInput | LibraryCopyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryCopies.
     */
    cursor?: LibraryCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryCopies.
     */
    distinct?: LibraryCopyScalarFieldEnum | LibraryCopyScalarFieldEnum[]
  }

  /**
   * LibraryCopy findMany
   */
  export type LibraryCopyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
    /**
     * Filter, which LibraryCopies to fetch.
     */
    where?: LibraryCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCopies to fetch.
     */
    orderBy?: LibraryCopyOrderByWithRelationInput | LibraryCopyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryCopies.
     */
    cursor?: LibraryCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCopies.
     */
    skip?: number
    distinct?: LibraryCopyScalarFieldEnum | LibraryCopyScalarFieldEnum[]
  }

  /**
   * LibraryCopy create
   */
  export type LibraryCopyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
    /**
     * The data needed to create a LibraryCopy.
     */
    data: XOR<LibraryCopyCreateInput, LibraryCopyUncheckedCreateInput>
  }

  /**
   * LibraryCopy createMany
   */
  export type LibraryCopyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LibraryCopies.
     */
    data: LibraryCopyCreateManyInput | LibraryCopyCreateManyInput[]
  }

  /**
   * LibraryCopy createManyAndReturn
   */
  export type LibraryCopyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * The data used to create many LibraryCopies.
     */
    data: LibraryCopyCreateManyInput | LibraryCopyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LibraryCopy update
   */
  export type LibraryCopyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
    /**
     * The data needed to update a LibraryCopy.
     */
    data: XOR<LibraryCopyUpdateInput, LibraryCopyUncheckedUpdateInput>
    /**
     * Choose, which LibraryCopy to update.
     */
    where: LibraryCopyWhereUniqueInput
  }

  /**
   * LibraryCopy updateMany
   */
  export type LibraryCopyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LibraryCopies.
     */
    data: XOR<LibraryCopyUpdateManyMutationInput, LibraryCopyUncheckedUpdateManyInput>
    /**
     * Filter which LibraryCopies to update
     */
    where?: LibraryCopyWhereInput
    /**
     * Limit how many LibraryCopies to update.
     */
    limit?: number
  }

  /**
   * LibraryCopy updateManyAndReturn
   */
  export type LibraryCopyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * The data used to update LibraryCopies.
     */
    data: XOR<LibraryCopyUpdateManyMutationInput, LibraryCopyUncheckedUpdateManyInput>
    /**
     * Filter which LibraryCopies to update
     */
    where?: LibraryCopyWhereInput
    /**
     * Limit how many LibraryCopies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LibraryCopy upsert
   */
  export type LibraryCopyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
    /**
     * The filter to search for the LibraryCopy to update in case it exists.
     */
    where: LibraryCopyWhereUniqueInput
    /**
     * In case the LibraryCopy found by the `where` argument doesn't exist, create a new LibraryCopy with this data.
     */
    create: XOR<LibraryCopyCreateInput, LibraryCopyUncheckedCreateInput>
    /**
     * In case the LibraryCopy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryCopyUpdateInput, LibraryCopyUncheckedUpdateInput>
  }

  /**
   * LibraryCopy delete
   */
  export type LibraryCopyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
    /**
     * Filter which LibraryCopy to delete.
     */
    where: LibraryCopyWhereUniqueInput
  }

  /**
   * LibraryCopy deleteMany
   */
  export type LibraryCopyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryCopies to delete
     */
    where?: LibraryCopyWhereInput
    /**
     * Limit how many LibraryCopies to delete.
     */
    limit?: number
  }

  /**
   * LibraryCopy.issues
   */
  export type LibraryCopy$issuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    where?: LibraryIssueWhereInput
    orderBy?: LibraryIssueOrderByWithRelationInput | LibraryIssueOrderByWithRelationInput[]
    cursor?: LibraryIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LibraryIssueScalarFieldEnum | LibraryIssueScalarFieldEnum[]
  }

  /**
   * LibraryCopy without action
   */
  export type LibraryCopyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCopy
     */
    select?: LibraryCopySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryCopy
     */
    omit?: LibraryCopyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryCopyInclude<ExtArgs> | null
  }


  /**
   * Model LibraryIssue
   */

  export type AggregateLibraryIssue = {
    _count: LibraryIssueCountAggregateOutputType | null
    _min: LibraryIssueMinAggregateOutputType | null
    _max: LibraryIssueMaxAggregateOutputType | null
  }

  export type LibraryIssueMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    copyId: string | null
    issueDate: Date | null
    dueDate: Date | null
    returnDate: Date | null
    status: $Enums.LibraryIssueStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryIssueMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    copyId: string | null
    issueDate: Date | null
    dueDate: Date | null
    returnDate: Date | null
    status: $Enums.LibraryIssueStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryIssueCountAggregateOutputType = {
    id: number
    studentId: number
    copyId: number
    issueDate: number
    dueDate: number
    returnDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryIssueMinAggregateInputType = {
    id?: true
    studentId?: true
    copyId?: true
    issueDate?: true
    dueDate?: true
    returnDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryIssueMaxAggregateInputType = {
    id?: true
    studentId?: true
    copyId?: true
    issueDate?: true
    dueDate?: true
    returnDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryIssueCountAggregateInputType = {
    id?: true
    studentId?: true
    copyId?: true
    issueDate?: true
    dueDate?: true
    returnDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryIssueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryIssue to aggregate.
     */
    where?: LibraryIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryIssues to fetch.
     */
    orderBy?: LibraryIssueOrderByWithRelationInput | LibraryIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryIssues
    **/
    _count?: true | LibraryIssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryIssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryIssueMaxAggregateInputType
  }

  export type GetLibraryIssueAggregateType<T extends LibraryIssueAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryIssue[P]>
      : GetScalarType<T[P], AggregateLibraryIssue[P]>
  }




  export type LibraryIssueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LibraryIssueWhereInput
    orderBy?: LibraryIssueOrderByWithAggregationInput | LibraryIssueOrderByWithAggregationInput[]
    by: LibraryIssueScalarFieldEnum[] | LibraryIssueScalarFieldEnum
    having?: LibraryIssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryIssueCountAggregateInputType | true
    _min?: LibraryIssueMinAggregateInputType
    _max?: LibraryIssueMaxAggregateInputType
  }

  export type LibraryIssueGroupByOutputType = {
    id: string
    studentId: string
    copyId: string
    issueDate: Date
    dueDate: Date
    returnDate: Date | null
    status: $Enums.LibraryIssueStatus
    createdAt: Date
    updatedAt: Date
    _count: LibraryIssueCountAggregateOutputType | null
    _min: LibraryIssueMinAggregateOutputType | null
    _max: LibraryIssueMaxAggregateOutputType | null
  }

  type GetLibraryIssueGroupByPayload<T extends LibraryIssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryIssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryIssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryIssueGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryIssueGroupByOutputType[P]>
        }
      >
    >


  export type LibraryIssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    copyId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    returnDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    copy?: boolean | LibraryCopyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryIssue"]>

  export type LibraryIssueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    copyId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    returnDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    copy?: boolean | LibraryCopyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryIssue"]>

  export type LibraryIssueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    copyId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    returnDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    copy?: boolean | LibraryCopyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["libraryIssue"]>

  export type LibraryIssueSelectScalar = {
    id?: boolean
    studentId?: boolean
    copyId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    returnDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LibraryIssueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "copyId" | "issueDate" | "dueDate" | "returnDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["libraryIssue"]>
  export type LibraryIssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    copy?: boolean | LibraryCopyDefaultArgs<ExtArgs>
  }
  export type LibraryIssueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    copy?: boolean | LibraryCopyDefaultArgs<ExtArgs>
  }
  export type LibraryIssueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    copy?: boolean | LibraryCopyDefaultArgs<ExtArgs>
  }

  export type $LibraryIssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LibraryIssue"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      copy: Prisma.$LibraryCopyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      copyId: string
      issueDate: Date
      dueDate: Date
      returnDate: Date | null
      status: $Enums.LibraryIssueStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["libraryIssue"]>
    composites: {}
  }

  type LibraryIssueGetPayload<S extends boolean | null | undefined | LibraryIssueDefaultArgs> = $Result.GetResult<Prisma.$LibraryIssuePayload, S>

  type LibraryIssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LibraryIssueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LibraryIssueCountAggregateInputType | true
    }

  export interface LibraryIssueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LibraryIssue'], meta: { name: 'LibraryIssue' } }
    /**
     * Find zero or one LibraryIssue that matches the filter.
     * @param {LibraryIssueFindUniqueArgs} args - Arguments to find a LibraryIssue
     * @example
     * // Get one LibraryIssue
     * const libraryIssue = await prisma.libraryIssue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LibraryIssueFindUniqueArgs>(args: SelectSubset<T, LibraryIssueFindUniqueArgs<ExtArgs>>): Prisma__LibraryIssueClient<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LibraryIssue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LibraryIssueFindUniqueOrThrowArgs} args - Arguments to find a LibraryIssue
     * @example
     * // Get one LibraryIssue
     * const libraryIssue = await prisma.libraryIssue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LibraryIssueFindUniqueOrThrowArgs>(args: SelectSubset<T, LibraryIssueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LibraryIssueClient<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LibraryIssue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryIssueFindFirstArgs} args - Arguments to find a LibraryIssue
     * @example
     * // Get one LibraryIssue
     * const libraryIssue = await prisma.libraryIssue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LibraryIssueFindFirstArgs>(args?: SelectSubset<T, LibraryIssueFindFirstArgs<ExtArgs>>): Prisma__LibraryIssueClient<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LibraryIssue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryIssueFindFirstOrThrowArgs} args - Arguments to find a LibraryIssue
     * @example
     * // Get one LibraryIssue
     * const libraryIssue = await prisma.libraryIssue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LibraryIssueFindFirstOrThrowArgs>(args?: SelectSubset<T, LibraryIssueFindFirstOrThrowArgs<ExtArgs>>): Prisma__LibraryIssueClient<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LibraryIssues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryIssueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryIssues
     * const libraryIssues = await prisma.libraryIssue.findMany()
     * 
     * // Get first 10 LibraryIssues
     * const libraryIssues = await prisma.libraryIssue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryIssueWithIdOnly = await prisma.libraryIssue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LibraryIssueFindManyArgs>(args?: SelectSubset<T, LibraryIssueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LibraryIssue.
     * @param {LibraryIssueCreateArgs} args - Arguments to create a LibraryIssue.
     * @example
     * // Create one LibraryIssue
     * const LibraryIssue = await prisma.libraryIssue.create({
     *   data: {
     *     // ... data to create a LibraryIssue
     *   }
     * })
     * 
     */
    create<T extends LibraryIssueCreateArgs>(args: SelectSubset<T, LibraryIssueCreateArgs<ExtArgs>>): Prisma__LibraryIssueClient<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LibraryIssues.
     * @param {LibraryIssueCreateManyArgs} args - Arguments to create many LibraryIssues.
     * @example
     * // Create many LibraryIssues
     * const libraryIssue = await prisma.libraryIssue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LibraryIssueCreateManyArgs>(args?: SelectSubset<T, LibraryIssueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LibraryIssues and returns the data saved in the database.
     * @param {LibraryIssueCreateManyAndReturnArgs} args - Arguments to create many LibraryIssues.
     * @example
     * // Create many LibraryIssues
     * const libraryIssue = await prisma.libraryIssue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LibraryIssues and only return the `id`
     * const libraryIssueWithIdOnly = await prisma.libraryIssue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LibraryIssueCreateManyAndReturnArgs>(args?: SelectSubset<T, LibraryIssueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LibraryIssue.
     * @param {LibraryIssueDeleteArgs} args - Arguments to delete one LibraryIssue.
     * @example
     * // Delete one LibraryIssue
     * const LibraryIssue = await prisma.libraryIssue.delete({
     *   where: {
     *     // ... filter to delete one LibraryIssue
     *   }
     * })
     * 
     */
    delete<T extends LibraryIssueDeleteArgs>(args: SelectSubset<T, LibraryIssueDeleteArgs<ExtArgs>>): Prisma__LibraryIssueClient<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LibraryIssue.
     * @param {LibraryIssueUpdateArgs} args - Arguments to update one LibraryIssue.
     * @example
     * // Update one LibraryIssue
     * const libraryIssue = await prisma.libraryIssue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LibraryIssueUpdateArgs>(args: SelectSubset<T, LibraryIssueUpdateArgs<ExtArgs>>): Prisma__LibraryIssueClient<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LibraryIssues.
     * @param {LibraryIssueDeleteManyArgs} args - Arguments to filter LibraryIssues to delete.
     * @example
     * // Delete a few LibraryIssues
     * const { count } = await prisma.libraryIssue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LibraryIssueDeleteManyArgs>(args?: SelectSubset<T, LibraryIssueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryIssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryIssues
     * const libraryIssue = await prisma.libraryIssue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LibraryIssueUpdateManyArgs>(args: SelectSubset<T, LibraryIssueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryIssues and returns the data updated in the database.
     * @param {LibraryIssueUpdateManyAndReturnArgs} args - Arguments to update many LibraryIssues.
     * @example
     * // Update many LibraryIssues
     * const libraryIssue = await prisma.libraryIssue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LibraryIssues and only return the `id`
     * const libraryIssueWithIdOnly = await prisma.libraryIssue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LibraryIssueUpdateManyAndReturnArgs>(args: SelectSubset<T, LibraryIssueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LibraryIssue.
     * @param {LibraryIssueUpsertArgs} args - Arguments to update or create a LibraryIssue.
     * @example
     * // Update or create a LibraryIssue
     * const libraryIssue = await prisma.libraryIssue.upsert({
     *   create: {
     *     // ... data to create a LibraryIssue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryIssue we want to update
     *   }
     * })
     */
    upsert<T extends LibraryIssueUpsertArgs>(args: SelectSubset<T, LibraryIssueUpsertArgs<ExtArgs>>): Prisma__LibraryIssueClient<$Result.GetResult<Prisma.$LibraryIssuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LibraryIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryIssueCountArgs} args - Arguments to filter LibraryIssues to count.
     * @example
     * // Count the number of LibraryIssues
     * const count = await prisma.libraryIssue.count({
     *   where: {
     *     // ... the filter for the LibraryIssues we want to count
     *   }
     * })
    **/
    count<T extends LibraryIssueCountArgs>(
      args?: Subset<T, LibraryIssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryIssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryIssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryIssueAggregateArgs>(args: Subset<T, LibraryIssueAggregateArgs>): Prisma.PrismaPromise<GetLibraryIssueAggregateType<T>>

    /**
     * Group by LibraryIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryIssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryIssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryIssueGroupByArgs['orderBy'] }
        : { orderBy?: LibraryIssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryIssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LibraryIssue model
   */
  readonly fields: LibraryIssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryIssue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LibraryIssueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    copy<T extends LibraryCopyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LibraryCopyDefaultArgs<ExtArgs>>): Prisma__LibraryCopyClient<$Result.GetResult<Prisma.$LibraryCopyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LibraryIssue model
   */
  interface LibraryIssueFieldRefs {
    readonly id: FieldRef<"LibraryIssue", 'String'>
    readonly studentId: FieldRef<"LibraryIssue", 'String'>
    readonly copyId: FieldRef<"LibraryIssue", 'String'>
    readonly issueDate: FieldRef<"LibraryIssue", 'DateTime'>
    readonly dueDate: FieldRef<"LibraryIssue", 'DateTime'>
    readonly returnDate: FieldRef<"LibraryIssue", 'DateTime'>
    readonly status: FieldRef<"LibraryIssue", 'LibraryIssueStatus'>
    readonly createdAt: FieldRef<"LibraryIssue", 'DateTime'>
    readonly updatedAt: FieldRef<"LibraryIssue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LibraryIssue findUnique
   */
  export type LibraryIssueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    /**
     * Filter, which LibraryIssue to fetch.
     */
    where: LibraryIssueWhereUniqueInput
  }

  /**
   * LibraryIssue findUniqueOrThrow
   */
  export type LibraryIssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    /**
     * Filter, which LibraryIssue to fetch.
     */
    where: LibraryIssueWhereUniqueInput
  }

  /**
   * LibraryIssue findFirst
   */
  export type LibraryIssueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    /**
     * Filter, which LibraryIssue to fetch.
     */
    where?: LibraryIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryIssues to fetch.
     */
    orderBy?: LibraryIssueOrderByWithRelationInput | LibraryIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryIssues.
     */
    cursor?: LibraryIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryIssues.
     */
    distinct?: LibraryIssueScalarFieldEnum | LibraryIssueScalarFieldEnum[]
  }

  /**
   * LibraryIssue findFirstOrThrow
   */
  export type LibraryIssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    /**
     * Filter, which LibraryIssue to fetch.
     */
    where?: LibraryIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryIssues to fetch.
     */
    orderBy?: LibraryIssueOrderByWithRelationInput | LibraryIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryIssues.
     */
    cursor?: LibraryIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryIssues.
     */
    distinct?: LibraryIssueScalarFieldEnum | LibraryIssueScalarFieldEnum[]
  }

  /**
   * LibraryIssue findMany
   */
  export type LibraryIssueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    /**
     * Filter, which LibraryIssues to fetch.
     */
    where?: LibraryIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryIssues to fetch.
     */
    orderBy?: LibraryIssueOrderByWithRelationInput | LibraryIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryIssues.
     */
    cursor?: LibraryIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryIssues.
     */
    skip?: number
    distinct?: LibraryIssueScalarFieldEnum | LibraryIssueScalarFieldEnum[]
  }

  /**
   * LibraryIssue create
   */
  export type LibraryIssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    /**
     * The data needed to create a LibraryIssue.
     */
    data: XOR<LibraryIssueCreateInput, LibraryIssueUncheckedCreateInput>
  }

  /**
   * LibraryIssue createMany
   */
  export type LibraryIssueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LibraryIssues.
     */
    data: LibraryIssueCreateManyInput | LibraryIssueCreateManyInput[]
  }

  /**
   * LibraryIssue createManyAndReturn
   */
  export type LibraryIssueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * The data used to create many LibraryIssues.
     */
    data: LibraryIssueCreateManyInput | LibraryIssueCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LibraryIssue update
   */
  export type LibraryIssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    /**
     * The data needed to update a LibraryIssue.
     */
    data: XOR<LibraryIssueUpdateInput, LibraryIssueUncheckedUpdateInput>
    /**
     * Choose, which LibraryIssue to update.
     */
    where: LibraryIssueWhereUniqueInput
  }

  /**
   * LibraryIssue updateMany
   */
  export type LibraryIssueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LibraryIssues.
     */
    data: XOR<LibraryIssueUpdateManyMutationInput, LibraryIssueUncheckedUpdateManyInput>
    /**
     * Filter which LibraryIssues to update
     */
    where?: LibraryIssueWhereInput
    /**
     * Limit how many LibraryIssues to update.
     */
    limit?: number
  }

  /**
   * LibraryIssue updateManyAndReturn
   */
  export type LibraryIssueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * The data used to update LibraryIssues.
     */
    data: XOR<LibraryIssueUpdateManyMutationInput, LibraryIssueUncheckedUpdateManyInput>
    /**
     * Filter which LibraryIssues to update
     */
    where?: LibraryIssueWhereInput
    /**
     * Limit how many LibraryIssues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LibraryIssue upsert
   */
  export type LibraryIssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    /**
     * The filter to search for the LibraryIssue to update in case it exists.
     */
    where: LibraryIssueWhereUniqueInput
    /**
     * In case the LibraryIssue found by the `where` argument doesn't exist, create a new LibraryIssue with this data.
     */
    create: XOR<LibraryIssueCreateInput, LibraryIssueUncheckedCreateInput>
    /**
     * In case the LibraryIssue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryIssueUpdateInput, LibraryIssueUncheckedUpdateInput>
  }

  /**
   * LibraryIssue delete
   */
  export type LibraryIssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
    /**
     * Filter which LibraryIssue to delete.
     */
    where: LibraryIssueWhereUniqueInput
  }

  /**
   * LibraryIssue deleteMany
   */
  export type LibraryIssueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryIssues to delete
     */
    where?: LibraryIssueWhereInput
    /**
     * Limit how many LibraryIssues to delete.
     */
    limit?: number
  }

  /**
   * LibraryIssue without action
   */
  export type LibraryIssueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryIssue
     */
    select?: LibraryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LibraryIssue
     */
    omit?: LibraryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LibraryIssueInclude<ExtArgs> | null
  }


  /**
   * Model Request
   */

  export type AggregateRequest = {
    _count: RequestCountAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  export type RequestMinAggregateOutputType = {
    id: string | null
    displayId: string | null
    studentId: string | null
    title: string | null
    description: string | null
    status: $Enums.RequestStatus | null
    submittedAt: Date | null
    updatedAt: Date | null
  }

  export type RequestMaxAggregateOutputType = {
    id: string | null
    displayId: string | null
    studentId: string | null
    title: string | null
    description: string | null
    status: $Enums.RequestStatus | null
    submittedAt: Date | null
    updatedAt: Date | null
  }

  export type RequestCountAggregateOutputType = {
    id: number
    displayId: number
    studentId: number
    title: number
    description: number
    status: number
    submittedAt: number
    updatedAt: number
    _all: number
  }


  export type RequestMinAggregateInputType = {
    id?: true
    displayId?: true
    studentId?: true
    title?: true
    description?: true
    status?: true
    submittedAt?: true
    updatedAt?: true
  }

  export type RequestMaxAggregateInputType = {
    id?: true
    displayId?: true
    studentId?: true
    title?: true
    description?: true
    status?: true
    submittedAt?: true
    updatedAt?: true
  }

  export type RequestCountAggregateInputType = {
    id?: true
    displayId?: true
    studentId?: true
    title?: true
    description?: true
    status?: true
    submittedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Request to aggregate.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requests
    **/
    _count?: true | RequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestMaxAggregateInputType
  }

  export type GetRequestAggregateType<T extends RequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequest[P]>
      : GetScalarType<T[P], AggregateRequest[P]>
  }




  export type RequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithAggregationInput | RequestOrderByWithAggregationInput[]
    by: RequestScalarFieldEnum[] | RequestScalarFieldEnum
    having?: RequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCountAggregateInputType | true
    _min?: RequestMinAggregateInputType
    _max?: RequestMaxAggregateInputType
  }

  export type RequestGroupByOutputType = {
    id: string
    displayId: string
    studentId: string
    title: string
    description: string | null
    status: $Enums.RequestStatus
    submittedAt: Date
    updatedAt: Date
    _count: RequestCountAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  type GetRequestGroupByPayload<T extends RequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestGroupByOutputType[P]>
            : GetScalarType<T[P], RequestGroupByOutputType[P]>
        }
      >
    >


  export type RequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayId?: boolean
    studentId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayId?: boolean
    studentId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayId?: boolean
    studentId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectScalar = {
    id?: boolean
    displayId?: boolean
    studentId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
  }

  export type RequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "displayId" | "studentId" | "title" | "description" | "status" | "submittedAt" | "updatedAt", ExtArgs["result"]["request"]>
  export type RequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type RequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type RequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $RequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Request"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      displayId: string
      studentId: string
      title: string
      description: string | null
      status: $Enums.RequestStatus
      submittedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["request"]>
    composites: {}
  }

  type RequestGetPayload<S extends boolean | null | undefined | RequestDefaultArgs> = $Result.GetResult<Prisma.$RequestPayload, S>

  type RequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestCountAggregateInputType | true
    }

  export interface RequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Request'], meta: { name: 'Request' } }
    /**
     * Find zero or one Request that matches the filter.
     * @param {RequestFindUniqueArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestFindUniqueArgs>(args: SelectSubset<T, RequestFindUniqueArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Request that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestFindUniqueOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestFindFirstArgs>(args?: SelectSubset<T, RequestFindFirstArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.request.findMany()
     * 
     * // Get first 10 Requests
     * const requests = await prisma.request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestWithIdOnly = await prisma.request.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestFindManyArgs>(args?: SelectSubset<T, RequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Request.
     * @param {RequestCreateArgs} args - Arguments to create a Request.
     * @example
     * // Create one Request
     * const Request = await prisma.request.create({
     *   data: {
     *     // ... data to create a Request
     *   }
     * })
     * 
     */
    create<T extends RequestCreateArgs>(args: SelectSubset<T, RequestCreateArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requests.
     * @param {RequestCreateManyArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const request = await prisma.request.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestCreateManyArgs>(args?: SelectSubset<T, RequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requests and returns the data saved in the database.
     * @param {RequestCreateManyAndReturnArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const request = await prisma.request.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requests and only return the `id`
     * const requestWithIdOnly = await prisma.request.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Request.
     * @param {RequestDeleteArgs} args - Arguments to delete one Request.
     * @example
     * // Delete one Request
     * const Request = await prisma.request.delete({
     *   where: {
     *     // ... filter to delete one Request
     *   }
     * })
     * 
     */
    delete<T extends RequestDeleteArgs>(args: SelectSubset<T, RequestDeleteArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Request.
     * @param {RequestUpdateArgs} args - Arguments to update one Request.
     * @example
     * // Update one Request
     * const request = await prisma.request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestUpdateArgs>(args: SelectSubset<T, RequestUpdateArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requests.
     * @param {RequestDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestDeleteManyArgs>(args?: SelectSubset<T, RequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestUpdateManyArgs>(args: SelectSubset<T, RequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests and returns the data updated in the database.
     * @param {RequestUpdateManyAndReturnArgs} args - Arguments to update many Requests.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Requests and only return the `id`
     * const requestWithIdOnly = await prisma.request.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Request.
     * @param {RequestUpsertArgs} args - Arguments to update or create a Request.
     * @example
     * // Update or create a Request
     * const request = await prisma.request.upsert({
     *   create: {
     *     // ... data to create a Request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Request we want to update
     *   }
     * })
     */
    upsert<T extends RequestUpsertArgs>(args: SelectSubset<T, RequestUpsertArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.request.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
    **/
    count<T extends RequestCountArgs>(
      args?: Subset<T, RequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestAggregateArgs>(args: Subset<T, RequestAggregateArgs>): Prisma.PrismaPromise<GetRequestAggregateType<T>>

    /**
     * Group by Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestGroupByArgs['orderBy'] }
        : { orderBy?: RequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Request model
   */
  readonly fields: RequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Request model
   */
  interface RequestFieldRefs {
    readonly id: FieldRef<"Request", 'String'>
    readonly displayId: FieldRef<"Request", 'String'>
    readonly studentId: FieldRef<"Request", 'String'>
    readonly title: FieldRef<"Request", 'String'>
    readonly description: FieldRef<"Request", 'String'>
    readonly status: FieldRef<"Request", 'RequestStatus'>
    readonly submittedAt: FieldRef<"Request", 'DateTime'>
    readonly updatedAt: FieldRef<"Request", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Request findUnique
   */
  export type RequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request findUniqueOrThrow
   */
  export type RequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request findFirst
   */
  export type RequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request findFirstOrThrow
   */
  export type RequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request findMany
   */
  export type RequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request create
   */
  export type RequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The data needed to create a Request.
     */
    data: XOR<RequestCreateInput, RequestUncheckedCreateInput>
  }

  /**
   * Request createMany
   */
  export type RequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requests.
     */
    data: RequestCreateManyInput | RequestCreateManyInput[]
  }

  /**
   * Request createManyAndReturn
   */
  export type RequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * The data used to create many Requests.
     */
    data: RequestCreateManyInput | RequestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Request update
   */
  export type RequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The data needed to update a Request.
     */
    data: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
    /**
     * Choose, which Request to update.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request updateMany
   */
  export type RequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to update.
     */
    limit?: number
  }

  /**
   * Request updateManyAndReturn
   */
  export type RequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Request upsert
   */
  export type RequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The filter to search for the Request to update in case it exists.
     */
    where: RequestWhereUniqueInput
    /**
     * In case the Request found by the `where` argument doesn't exist, create a new Request with this data.
     */
    create: XOR<RequestCreateInput, RequestUncheckedCreateInput>
    /**
     * In case the Request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
  }

  /**
   * Request delete
   */
  export type RequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter which Request to delete.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request deleteMany
   */
  export type RequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requests to delete
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to delete.
     */
    limit?: number
  }

  /**
   * Request without action
   */
  export type RequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
  }


  /**
   * Model StudentSetting
   */

  export type AggregateStudentSetting = {
    _count: StudentSettingCountAggregateOutputType | null
    _min: StudentSettingMinAggregateOutputType | null
    _max: StudentSettingMaxAggregateOutputType | null
  }

  export type StudentSettingMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    theme: $Enums.Theme | null
    notificationsEnabled: boolean | null
    language: string | null
    profileVisibility: $Enums.ProfileVisibility | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSettingMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    theme: $Enums.Theme | null
    notificationsEnabled: boolean | null
    language: string | null
    profileVisibility: $Enums.ProfileVisibility | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSettingCountAggregateOutputType = {
    id: number
    studentId: number
    theme: number
    notificationsEnabled: number
    language: number
    profileVisibility: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentSettingMinAggregateInputType = {
    id?: true
    studentId?: true
    theme?: true
    notificationsEnabled?: true
    language?: true
    profileVisibility?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSettingMaxAggregateInputType = {
    id?: true
    studentId?: true
    theme?: true
    notificationsEnabled?: true
    language?: true
    profileVisibility?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSettingCountAggregateInputType = {
    id?: true
    studentId?: true
    theme?: true
    notificationsEnabled?: true
    language?: true
    profileVisibility?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSetting to aggregate.
     */
    where?: StudentSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSettings to fetch.
     */
    orderBy?: StudentSettingOrderByWithRelationInput | StudentSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSettings
    **/
    _count?: true | StudentSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSettingMaxAggregateInputType
  }

  export type GetStudentSettingAggregateType<T extends StudentSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSetting[P]>
      : GetScalarType<T[P], AggregateStudentSetting[P]>
  }




  export type StudentSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSettingWhereInput
    orderBy?: StudentSettingOrderByWithAggregationInput | StudentSettingOrderByWithAggregationInput[]
    by: StudentSettingScalarFieldEnum[] | StudentSettingScalarFieldEnum
    having?: StudentSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSettingCountAggregateInputType | true
    _min?: StudentSettingMinAggregateInputType
    _max?: StudentSettingMaxAggregateInputType
  }

  export type StudentSettingGroupByOutputType = {
    id: string
    studentId: string
    theme: $Enums.Theme
    notificationsEnabled: boolean
    language: string
    profileVisibility: $Enums.ProfileVisibility
    createdAt: Date
    updatedAt: Date
    _count: StudentSettingCountAggregateOutputType | null
    _min: StudentSettingMinAggregateOutputType | null
    _max: StudentSettingMaxAggregateOutputType | null
  }

  type GetStudentSettingGroupByPayload<T extends StudentSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSettingGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSettingGroupByOutputType[P]>
        }
      >
    >


  export type StudentSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    theme?: boolean
    notificationsEnabled?: boolean
    language?: boolean
    profileVisibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSetting"]>

  export type StudentSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    theme?: boolean
    notificationsEnabled?: boolean
    language?: boolean
    profileVisibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSetting"]>

  export type StudentSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    theme?: boolean
    notificationsEnabled?: boolean
    language?: boolean
    profileVisibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSetting"]>

  export type StudentSettingSelectScalar = {
    id?: boolean
    studentId?: boolean
    theme?: boolean
    notificationsEnabled?: boolean
    language?: boolean
    profileVisibility?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "theme" | "notificationsEnabled" | "language" | "profileVisibility" | "createdAt" | "updatedAt", ExtArgs["result"]["studentSetting"]>
  export type StudentSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentSettingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSetting"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      theme: $Enums.Theme
      notificationsEnabled: boolean
      language: string
      profileVisibility: $Enums.ProfileVisibility
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentSetting"]>
    composites: {}
  }

  type StudentSettingGetPayload<S extends boolean | null | undefined | StudentSettingDefaultArgs> = $Result.GetResult<Prisma.$StudentSettingPayload, S>

  type StudentSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentSettingCountAggregateInputType | true
    }

  export interface StudentSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSetting'], meta: { name: 'StudentSetting' } }
    /**
     * Find zero or one StudentSetting that matches the filter.
     * @param {StudentSettingFindUniqueArgs} args - Arguments to find a StudentSetting
     * @example
     * // Get one StudentSetting
     * const studentSetting = await prisma.studentSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSettingFindUniqueArgs>(args: SelectSubset<T, StudentSettingFindUniqueArgs<ExtArgs>>): Prisma__StudentSettingClient<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentSettingFindUniqueOrThrowArgs} args - Arguments to find a StudentSetting
     * @example
     * // Get one StudentSetting
     * const studentSetting = await prisma.studentSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSettingClient<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSettingFindFirstArgs} args - Arguments to find a StudentSetting
     * @example
     * // Get one StudentSetting
     * const studentSetting = await prisma.studentSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSettingFindFirstArgs>(args?: SelectSubset<T, StudentSettingFindFirstArgs<ExtArgs>>): Prisma__StudentSettingClient<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSettingFindFirstOrThrowArgs} args - Arguments to find a StudentSetting
     * @example
     * // Get one StudentSetting
     * const studentSetting = await prisma.studentSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSettingClient<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSettings
     * const studentSettings = await prisma.studentSetting.findMany()
     * 
     * // Get first 10 StudentSettings
     * const studentSettings = await prisma.studentSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSettingWithIdOnly = await prisma.studentSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSettingFindManyArgs>(args?: SelectSubset<T, StudentSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentSetting.
     * @param {StudentSettingCreateArgs} args - Arguments to create a StudentSetting.
     * @example
     * // Create one StudentSetting
     * const StudentSetting = await prisma.studentSetting.create({
     *   data: {
     *     // ... data to create a StudentSetting
     *   }
     * })
     * 
     */
    create<T extends StudentSettingCreateArgs>(args: SelectSubset<T, StudentSettingCreateArgs<ExtArgs>>): Prisma__StudentSettingClient<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentSettings.
     * @param {StudentSettingCreateManyArgs} args - Arguments to create many StudentSettings.
     * @example
     * // Create many StudentSettings
     * const studentSetting = await prisma.studentSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSettingCreateManyArgs>(args?: SelectSubset<T, StudentSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentSettings and returns the data saved in the database.
     * @param {StudentSettingCreateManyAndReturnArgs} args - Arguments to create many StudentSettings.
     * @example
     * // Create many StudentSettings
     * const studentSetting = await prisma.studentSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentSettings and only return the `id`
     * const studentSettingWithIdOnly = await prisma.studentSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentSetting.
     * @param {StudentSettingDeleteArgs} args - Arguments to delete one StudentSetting.
     * @example
     * // Delete one StudentSetting
     * const StudentSetting = await prisma.studentSetting.delete({
     *   where: {
     *     // ... filter to delete one StudentSetting
     *   }
     * })
     * 
     */
    delete<T extends StudentSettingDeleteArgs>(args: SelectSubset<T, StudentSettingDeleteArgs<ExtArgs>>): Prisma__StudentSettingClient<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentSetting.
     * @param {StudentSettingUpdateArgs} args - Arguments to update one StudentSetting.
     * @example
     * // Update one StudentSetting
     * const studentSetting = await prisma.studentSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSettingUpdateArgs>(args: SelectSubset<T, StudentSettingUpdateArgs<ExtArgs>>): Prisma__StudentSettingClient<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentSettings.
     * @param {StudentSettingDeleteManyArgs} args - Arguments to filter StudentSettings to delete.
     * @example
     * // Delete a few StudentSettings
     * const { count } = await prisma.studentSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSettingDeleteManyArgs>(args?: SelectSubset<T, StudentSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSettings
     * const studentSetting = await prisma.studentSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSettingUpdateManyArgs>(args: SelectSubset<T, StudentSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSettings and returns the data updated in the database.
     * @param {StudentSettingUpdateManyAndReturnArgs} args - Arguments to update many StudentSettings.
     * @example
     * // Update many StudentSettings
     * const studentSetting = await prisma.studentSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentSettings and only return the `id`
     * const studentSettingWithIdOnly = await prisma.studentSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentSetting.
     * @param {StudentSettingUpsertArgs} args - Arguments to update or create a StudentSetting.
     * @example
     * // Update or create a StudentSetting
     * const studentSetting = await prisma.studentSetting.upsert({
     *   create: {
     *     // ... data to create a StudentSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSetting we want to update
     *   }
     * })
     */
    upsert<T extends StudentSettingUpsertArgs>(args: SelectSubset<T, StudentSettingUpsertArgs<ExtArgs>>): Prisma__StudentSettingClient<$Result.GetResult<Prisma.$StudentSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSettingCountArgs} args - Arguments to filter StudentSettings to count.
     * @example
     * // Count the number of StudentSettings
     * const count = await prisma.studentSetting.count({
     *   where: {
     *     // ... the filter for the StudentSettings we want to count
     *   }
     * })
    **/
    count<T extends StudentSettingCountArgs>(
      args?: Subset<T, StudentSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSettingAggregateArgs>(args: Subset<T, StudentSettingAggregateArgs>): Prisma.PrismaPromise<GetStudentSettingAggregateType<T>>

    /**
     * Group by StudentSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSettingGroupByArgs['orderBy'] }
        : { orderBy?: StudentSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSetting model
   */
  readonly fields: StudentSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSetting model
   */
  interface StudentSettingFieldRefs {
    readonly id: FieldRef<"StudentSetting", 'String'>
    readonly studentId: FieldRef<"StudentSetting", 'String'>
    readonly theme: FieldRef<"StudentSetting", 'Theme'>
    readonly notificationsEnabled: FieldRef<"StudentSetting", 'Boolean'>
    readonly language: FieldRef<"StudentSetting", 'String'>
    readonly profileVisibility: FieldRef<"StudentSetting", 'ProfileVisibility'>
    readonly createdAt: FieldRef<"StudentSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentSetting findUnique
   */
  export type StudentSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
    /**
     * Filter, which StudentSetting to fetch.
     */
    where: StudentSettingWhereUniqueInput
  }

  /**
   * StudentSetting findUniqueOrThrow
   */
  export type StudentSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
    /**
     * Filter, which StudentSetting to fetch.
     */
    where: StudentSettingWhereUniqueInput
  }

  /**
   * StudentSetting findFirst
   */
  export type StudentSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
    /**
     * Filter, which StudentSetting to fetch.
     */
    where?: StudentSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSettings to fetch.
     */
    orderBy?: StudentSettingOrderByWithRelationInput | StudentSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSettings.
     */
    cursor?: StudentSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSettings.
     */
    distinct?: StudentSettingScalarFieldEnum | StudentSettingScalarFieldEnum[]
  }

  /**
   * StudentSetting findFirstOrThrow
   */
  export type StudentSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
    /**
     * Filter, which StudentSetting to fetch.
     */
    where?: StudentSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSettings to fetch.
     */
    orderBy?: StudentSettingOrderByWithRelationInput | StudentSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSettings.
     */
    cursor?: StudentSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSettings.
     */
    distinct?: StudentSettingScalarFieldEnum | StudentSettingScalarFieldEnum[]
  }

  /**
   * StudentSetting findMany
   */
  export type StudentSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
    /**
     * Filter, which StudentSettings to fetch.
     */
    where?: StudentSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSettings to fetch.
     */
    orderBy?: StudentSettingOrderByWithRelationInput | StudentSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSettings.
     */
    cursor?: StudentSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSettings.
     */
    skip?: number
    distinct?: StudentSettingScalarFieldEnum | StudentSettingScalarFieldEnum[]
  }

  /**
   * StudentSetting create
   */
  export type StudentSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSetting.
     */
    data: XOR<StudentSettingCreateInput, StudentSettingUncheckedCreateInput>
  }

  /**
   * StudentSetting createMany
   */
  export type StudentSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSettings.
     */
    data: StudentSettingCreateManyInput | StudentSettingCreateManyInput[]
  }

  /**
   * StudentSetting createManyAndReturn
   */
  export type StudentSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * The data used to create many StudentSettings.
     */
    data: StudentSettingCreateManyInput | StudentSettingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSetting update
   */
  export type StudentSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSetting.
     */
    data: XOR<StudentSettingUpdateInput, StudentSettingUncheckedUpdateInput>
    /**
     * Choose, which StudentSetting to update.
     */
    where: StudentSettingWhereUniqueInput
  }

  /**
   * StudentSetting updateMany
   */
  export type StudentSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSettings.
     */
    data: XOR<StudentSettingUpdateManyMutationInput, StudentSettingUncheckedUpdateManyInput>
    /**
     * Filter which StudentSettings to update
     */
    where?: StudentSettingWhereInput
    /**
     * Limit how many StudentSettings to update.
     */
    limit?: number
  }

  /**
   * StudentSetting updateManyAndReturn
   */
  export type StudentSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * The data used to update StudentSettings.
     */
    data: XOR<StudentSettingUpdateManyMutationInput, StudentSettingUncheckedUpdateManyInput>
    /**
     * Filter which StudentSettings to update
     */
    where?: StudentSettingWhereInput
    /**
     * Limit how many StudentSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSetting upsert
   */
  export type StudentSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSetting to update in case it exists.
     */
    where: StudentSettingWhereUniqueInput
    /**
     * In case the StudentSetting found by the `where` argument doesn't exist, create a new StudentSetting with this data.
     */
    create: XOR<StudentSettingCreateInput, StudentSettingUncheckedCreateInput>
    /**
     * In case the StudentSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSettingUpdateInput, StudentSettingUncheckedUpdateInput>
  }

  /**
   * StudentSetting delete
   */
  export type StudentSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
    /**
     * Filter which StudentSetting to delete.
     */
    where: StudentSettingWhereUniqueInput
  }

  /**
   * StudentSetting deleteMany
   */
  export type StudentSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSettings to delete
     */
    where?: StudentSettingWhereInput
    /**
     * Limit how many StudentSettings to delete.
     */
    limit?: number
  }

  /**
   * StudentSetting without action
   */
  export type StudentSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSetting
     */
    select?: StudentSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSetting
     */
    omit?: StudentSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSettingInclude<ExtArgs> | null
  }


  /**
   * Model FeeAccount
   */

  export type AggregateFeeAccount = {
    _count: FeeAccountCountAggregateOutputType | null
    _min: FeeAccountMinAggregateOutputType | null
    _max: FeeAccountMaxAggregateOutputType | null
  }

  export type FeeAccountMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeAccountMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeAccountCountAggregateOutputType = {
    id: number
    studentId: number
    currency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeeAccountMinAggregateInputType = {
    id?: true
    studentId?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeAccountMaxAggregateInputType = {
    id?: true
    studentId?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeAccountCountAggregateInputType = {
    id?: true
    studentId?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeeAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeAccount to aggregate.
     */
    where?: FeeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeAccounts to fetch.
     */
    orderBy?: FeeAccountOrderByWithRelationInput | FeeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeAccounts
    **/
    _count?: true | FeeAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeAccountMaxAggregateInputType
  }

  export type GetFeeAccountAggregateType<T extends FeeAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeAccount[P]>
      : GetScalarType<T[P], AggregateFeeAccount[P]>
  }




  export type FeeAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeAccountWhereInput
    orderBy?: FeeAccountOrderByWithAggregationInput | FeeAccountOrderByWithAggregationInput[]
    by: FeeAccountScalarFieldEnum[] | FeeAccountScalarFieldEnum
    having?: FeeAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeAccountCountAggregateInputType | true
    _min?: FeeAccountMinAggregateInputType
    _max?: FeeAccountMaxAggregateInputType
  }

  export type FeeAccountGroupByOutputType = {
    id: string
    studentId: string
    currency: string
    createdAt: Date
    updatedAt: Date
    _count: FeeAccountCountAggregateOutputType | null
    _min: FeeAccountMinAggregateOutputType | null
    _max: FeeAccountMaxAggregateOutputType | null
  }

  type GetFeeAccountGroupByPayload<T extends FeeAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeAccountGroupByOutputType[P]>
            : GetScalarType<T[P], FeeAccountGroupByOutputType[P]>
        }
      >
    >


  export type FeeAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    charges?: boolean | FeeAccount$chargesArgs<ExtArgs>
    payments?: boolean | FeeAccount$paymentsArgs<ExtArgs>
    _count?: boolean | FeeAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeAccount"]>

  export type FeeAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeAccount"]>

  export type FeeAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeAccount"]>

  export type FeeAccountSelectScalar = {
    id?: boolean
    studentId?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeeAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "currency" | "createdAt" | "updatedAt", ExtArgs["result"]["feeAccount"]>
  export type FeeAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    charges?: boolean | FeeAccount$chargesArgs<ExtArgs>
    payments?: boolean | FeeAccount$paymentsArgs<ExtArgs>
    _count?: boolean | FeeAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeeAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type FeeAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $FeeAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeAccount"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      charges: Prisma.$FeeChargePayload<ExtArgs>[]
      payments: Prisma.$FeePaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      currency: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feeAccount"]>
    composites: {}
  }

  type FeeAccountGetPayload<S extends boolean | null | undefined | FeeAccountDefaultArgs> = $Result.GetResult<Prisma.$FeeAccountPayload, S>

  type FeeAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeAccountCountAggregateInputType | true
    }

  export interface FeeAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeAccount'], meta: { name: 'FeeAccount' } }
    /**
     * Find zero or one FeeAccount that matches the filter.
     * @param {FeeAccountFindUniqueArgs} args - Arguments to find a FeeAccount
     * @example
     * // Get one FeeAccount
     * const feeAccount = await prisma.feeAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeAccountFindUniqueArgs>(args: SelectSubset<T, FeeAccountFindUniqueArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeAccountFindUniqueOrThrowArgs} args - Arguments to find a FeeAccount
     * @example
     * // Get one FeeAccount
     * const feeAccount = await prisma.feeAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeAccountFindFirstArgs} args - Arguments to find a FeeAccount
     * @example
     * // Get one FeeAccount
     * const feeAccount = await prisma.feeAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeAccountFindFirstArgs>(args?: SelectSubset<T, FeeAccountFindFirstArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeAccountFindFirstOrThrowArgs} args - Arguments to find a FeeAccount
     * @example
     * // Get one FeeAccount
     * const feeAccount = await prisma.feeAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeAccounts
     * const feeAccounts = await prisma.feeAccount.findMany()
     * 
     * // Get first 10 FeeAccounts
     * const feeAccounts = await prisma.feeAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeAccountWithIdOnly = await prisma.feeAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeAccountFindManyArgs>(args?: SelectSubset<T, FeeAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeAccount.
     * @param {FeeAccountCreateArgs} args - Arguments to create a FeeAccount.
     * @example
     * // Create one FeeAccount
     * const FeeAccount = await prisma.feeAccount.create({
     *   data: {
     *     // ... data to create a FeeAccount
     *   }
     * })
     * 
     */
    create<T extends FeeAccountCreateArgs>(args: SelectSubset<T, FeeAccountCreateArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeAccounts.
     * @param {FeeAccountCreateManyArgs} args - Arguments to create many FeeAccounts.
     * @example
     * // Create many FeeAccounts
     * const feeAccount = await prisma.feeAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeAccountCreateManyArgs>(args?: SelectSubset<T, FeeAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeAccounts and returns the data saved in the database.
     * @param {FeeAccountCreateManyAndReturnArgs} args - Arguments to create many FeeAccounts.
     * @example
     * // Create many FeeAccounts
     * const feeAccount = await prisma.feeAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeAccounts and only return the `id`
     * const feeAccountWithIdOnly = await prisma.feeAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeAccount.
     * @param {FeeAccountDeleteArgs} args - Arguments to delete one FeeAccount.
     * @example
     * // Delete one FeeAccount
     * const FeeAccount = await prisma.feeAccount.delete({
     *   where: {
     *     // ... filter to delete one FeeAccount
     *   }
     * })
     * 
     */
    delete<T extends FeeAccountDeleteArgs>(args: SelectSubset<T, FeeAccountDeleteArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeAccount.
     * @param {FeeAccountUpdateArgs} args - Arguments to update one FeeAccount.
     * @example
     * // Update one FeeAccount
     * const feeAccount = await prisma.feeAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeAccountUpdateArgs>(args: SelectSubset<T, FeeAccountUpdateArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeAccounts.
     * @param {FeeAccountDeleteManyArgs} args - Arguments to filter FeeAccounts to delete.
     * @example
     * // Delete a few FeeAccounts
     * const { count } = await prisma.feeAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeAccountDeleteManyArgs>(args?: SelectSubset<T, FeeAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeAccounts
     * const feeAccount = await prisma.feeAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeAccountUpdateManyArgs>(args: SelectSubset<T, FeeAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeAccounts and returns the data updated in the database.
     * @param {FeeAccountUpdateManyAndReturnArgs} args - Arguments to update many FeeAccounts.
     * @example
     * // Update many FeeAccounts
     * const feeAccount = await prisma.feeAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeAccounts and only return the `id`
     * const feeAccountWithIdOnly = await prisma.feeAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeAccount.
     * @param {FeeAccountUpsertArgs} args - Arguments to update or create a FeeAccount.
     * @example
     * // Update or create a FeeAccount
     * const feeAccount = await prisma.feeAccount.upsert({
     *   create: {
     *     // ... data to create a FeeAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeAccount we want to update
     *   }
     * })
     */
    upsert<T extends FeeAccountUpsertArgs>(args: SelectSubset<T, FeeAccountUpsertArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeAccountCountArgs} args - Arguments to filter FeeAccounts to count.
     * @example
     * // Count the number of FeeAccounts
     * const count = await prisma.feeAccount.count({
     *   where: {
     *     // ... the filter for the FeeAccounts we want to count
     *   }
     * })
    **/
    count<T extends FeeAccountCountArgs>(
      args?: Subset<T, FeeAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeAccountAggregateArgs>(args: Subset<T, FeeAccountAggregateArgs>): Prisma.PrismaPromise<GetFeeAccountAggregateType<T>>

    /**
     * Group by FeeAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeAccountGroupByArgs['orderBy'] }
        : { orderBy?: FeeAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeAccount model
   */
  readonly fields: FeeAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    charges<T extends FeeAccount$chargesArgs<ExtArgs> = {}>(args?: Subset<T, FeeAccount$chargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends FeeAccount$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, FeeAccount$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeAccount model
   */
  interface FeeAccountFieldRefs {
    readonly id: FieldRef<"FeeAccount", 'String'>
    readonly studentId: FieldRef<"FeeAccount", 'String'>
    readonly currency: FieldRef<"FeeAccount", 'String'>
    readonly createdAt: FieldRef<"FeeAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"FeeAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeeAccount findUnique
   */
  export type FeeAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
    /**
     * Filter, which FeeAccount to fetch.
     */
    where: FeeAccountWhereUniqueInput
  }

  /**
   * FeeAccount findUniqueOrThrow
   */
  export type FeeAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
    /**
     * Filter, which FeeAccount to fetch.
     */
    where: FeeAccountWhereUniqueInput
  }

  /**
   * FeeAccount findFirst
   */
  export type FeeAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
    /**
     * Filter, which FeeAccount to fetch.
     */
    where?: FeeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeAccounts to fetch.
     */
    orderBy?: FeeAccountOrderByWithRelationInput | FeeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeAccounts.
     */
    cursor?: FeeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeAccounts.
     */
    distinct?: FeeAccountScalarFieldEnum | FeeAccountScalarFieldEnum[]
  }

  /**
   * FeeAccount findFirstOrThrow
   */
  export type FeeAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
    /**
     * Filter, which FeeAccount to fetch.
     */
    where?: FeeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeAccounts to fetch.
     */
    orderBy?: FeeAccountOrderByWithRelationInput | FeeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeAccounts.
     */
    cursor?: FeeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeAccounts.
     */
    distinct?: FeeAccountScalarFieldEnum | FeeAccountScalarFieldEnum[]
  }

  /**
   * FeeAccount findMany
   */
  export type FeeAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
    /**
     * Filter, which FeeAccounts to fetch.
     */
    where?: FeeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeAccounts to fetch.
     */
    orderBy?: FeeAccountOrderByWithRelationInput | FeeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeAccounts.
     */
    cursor?: FeeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeAccounts.
     */
    skip?: number
    distinct?: FeeAccountScalarFieldEnum | FeeAccountScalarFieldEnum[]
  }

  /**
   * FeeAccount create
   */
  export type FeeAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeAccount.
     */
    data: XOR<FeeAccountCreateInput, FeeAccountUncheckedCreateInput>
  }

  /**
   * FeeAccount createMany
   */
  export type FeeAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeAccounts.
     */
    data: FeeAccountCreateManyInput | FeeAccountCreateManyInput[]
  }

  /**
   * FeeAccount createManyAndReturn
   */
  export type FeeAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * The data used to create many FeeAccounts.
     */
    data: FeeAccountCreateManyInput | FeeAccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeAccount update
   */
  export type FeeAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeAccount.
     */
    data: XOR<FeeAccountUpdateInput, FeeAccountUncheckedUpdateInput>
    /**
     * Choose, which FeeAccount to update.
     */
    where: FeeAccountWhereUniqueInput
  }

  /**
   * FeeAccount updateMany
   */
  export type FeeAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeAccounts.
     */
    data: XOR<FeeAccountUpdateManyMutationInput, FeeAccountUncheckedUpdateManyInput>
    /**
     * Filter which FeeAccounts to update
     */
    where?: FeeAccountWhereInput
    /**
     * Limit how many FeeAccounts to update.
     */
    limit?: number
  }

  /**
   * FeeAccount updateManyAndReturn
   */
  export type FeeAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * The data used to update FeeAccounts.
     */
    data: XOR<FeeAccountUpdateManyMutationInput, FeeAccountUncheckedUpdateManyInput>
    /**
     * Filter which FeeAccounts to update
     */
    where?: FeeAccountWhereInput
    /**
     * Limit how many FeeAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeAccount upsert
   */
  export type FeeAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeAccount to update in case it exists.
     */
    where: FeeAccountWhereUniqueInput
    /**
     * In case the FeeAccount found by the `where` argument doesn't exist, create a new FeeAccount with this data.
     */
    create: XOR<FeeAccountCreateInput, FeeAccountUncheckedCreateInput>
    /**
     * In case the FeeAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeAccountUpdateInput, FeeAccountUncheckedUpdateInput>
  }

  /**
   * FeeAccount delete
   */
  export type FeeAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
    /**
     * Filter which FeeAccount to delete.
     */
    where: FeeAccountWhereUniqueInput
  }

  /**
   * FeeAccount deleteMany
   */
  export type FeeAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeAccounts to delete
     */
    where?: FeeAccountWhereInput
    /**
     * Limit how many FeeAccounts to delete.
     */
    limit?: number
  }

  /**
   * FeeAccount.charges
   */
  export type FeeAccount$chargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
    where?: FeeChargeWhereInput
    orderBy?: FeeChargeOrderByWithRelationInput | FeeChargeOrderByWithRelationInput[]
    cursor?: FeeChargeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeChargeScalarFieldEnum | FeeChargeScalarFieldEnum[]
  }

  /**
   * FeeAccount.payments
   */
  export type FeeAccount$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    where?: FeePaymentWhereInput
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    cursor?: FeePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * FeeAccount without action
   */
  export type FeeAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeAccount
     */
    select?: FeeAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeAccount
     */
    omit?: FeeAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeAccountInclude<ExtArgs> | null
  }


  /**
   * Model FeeCharge
   */

  export type AggregateFeeCharge = {
    _count: FeeChargeCountAggregateOutputType | null
    _avg: FeeChargeAvgAggregateOutputType | null
    _sum: FeeChargeSumAggregateOutputType | null
    _min: FeeChargeMinAggregateOutputType | null
    _max: FeeChargeMaxAggregateOutputType | null
  }

  export type FeeChargeAvgAggregateOutputType = {
    amount: number | null
  }

  export type FeeChargeSumAggregateOutputType = {
    amount: number | null
  }

  export type FeeChargeMinAggregateOutputType = {
    id: string | null
    feeAccountId: string | null
    title: string | null
    amount: number | null
    dueDate: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type FeeChargeMaxAggregateOutputType = {
    id: string | null
    feeAccountId: string | null
    title: string | null
    amount: number | null
    dueDate: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type FeeChargeCountAggregateOutputType = {
    id: number
    feeAccountId: number
    title: number
    amount: number
    dueDate: number
    status: number
    createdAt: number
    _all: number
  }


  export type FeeChargeAvgAggregateInputType = {
    amount?: true
  }

  export type FeeChargeSumAggregateInputType = {
    amount?: true
  }

  export type FeeChargeMinAggregateInputType = {
    id?: true
    feeAccountId?: true
    title?: true
    amount?: true
    dueDate?: true
    status?: true
    createdAt?: true
  }

  export type FeeChargeMaxAggregateInputType = {
    id?: true
    feeAccountId?: true
    title?: true
    amount?: true
    dueDate?: true
    status?: true
    createdAt?: true
  }

  export type FeeChargeCountAggregateInputType = {
    id?: true
    feeAccountId?: true
    title?: true
    amount?: true
    dueDate?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type FeeChargeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeCharge to aggregate.
     */
    where?: FeeChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeCharges to fetch.
     */
    orderBy?: FeeChargeOrderByWithRelationInput | FeeChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeCharges
    **/
    _count?: true | FeeChargeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeChargeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeChargeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeChargeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeChargeMaxAggregateInputType
  }

  export type GetFeeChargeAggregateType<T extends FeeChargeAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeCharge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeCharge[P]>
      : GetScalarType<T[P], AggregateFeeCharge[P]>
  }




  export type FeeChargeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeChargeWhereInput
    orderBy?: FeeChargeOrderByWithAggregationInput | FeeChargeOrderByWithAggregationInput[]
    by: FeeChargeScalarFieldEnum[] | FeeChargeScalarFieldEnum
    having?: FeeChargeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeChargeCountAggregateInputType | true
    _avg?: FeeChargeAvgAggregateInputType
    _sum?: FeeChargeSumAggregateInputType
    _min?: FeeChargeMinAggregateInputType
    _max?: FeeChargeMaxAggregateInputType
  }

  export type FeeChargeGroupByOutputType = {
    id: string
    feeAccountId: string
    title: string
    amount: number
    dueDate: Date | null
    status: string
    createdAt: Date
    _count: FeeChargeCountAggregateOutputType | null
    _avg: FeeChargeAvgAggregateOutputType | null
    _sum: FeeChargeSumAggregateOutputType | null
    _min: FeeChargeMinAggregateOutputType | null
    _max: FeeChargeMaxAggregateOutputType | null
  }

  type GetFeeChargeGroupByPayload<T extends FeeChargeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeChargeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeChargeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeChargeGroupByOutputType[P]>
            : GetScalarType<T[P], FeeChargeGroupByOutputType[P]>
        }
      >
    >


  export type FeeChargeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeAccountId?: boolean
    title?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeCharge"]>

  export type FeeChargeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeAccountId?: boolean
    title?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeCharge"]>

  export type FeeChargeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeAccountId?: boolean
    title?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeCharge"]>

  export type FeeChargeSelectScalar = {
    id?: boolean
    feeAccountId?: boolean
    title?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type FeeChargeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feeAccountId" | "title" | "amount" | "dueDate" | "status" | "createdAt", ExtArgs["result"]["feeCharge"]>
  export type FeeChargeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }
  export type FeeChargeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }
  export type FeeChargeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }

  export type $FeeChargePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeCharge"
    objects: {
      feeAccount: Prisma.$FeeAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feeAccountId: string
      title: string
      amount: number
      dueDate: Date | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["feeCharge"]>
    composites: {}
  }

  type FeeChargeGetPayload<S extends boolean | null | undefined | FeeChargeDefaultArgs> = $Result.GetResult<Prisma.$FeeChargePayload, S>

  type FeeChargeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeChargeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeChargeCountAggregateInputType | true
    }

  export interface FeeChargeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeCharge'], meta: { name: 'FeeCharge' } }
    /**
     * Find zero or one FeeCharge that matches the filter.
     * @param {FeeChargeFindUniqueArgs} args - Arguments to find a FeeCharge
     * @example
     * // Get one FeeCharge
     * const feeCharge = await prisma.feeCharge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeChargeFindUniqueArgs>(args: SelectSubset<T, FeeChargeFindUniqueArgs<ExtArgs>>): Prisma__FeeChargeClient<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeCharge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeChargeFindUniqueOrThrowArgs} args - Arguments to find a FeeCharge
     * @example
     * // Get one FeeCharge
     * const feeCharge = await prisma.feeCharge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeChargeFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeChargeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeChargeClient<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeCharge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeChargeFindFirstArgs} args - Arguments to find a FeeCharge
     * @example
     * // Get one FeeCharge
     * const feeCharge = await prisma.feeCharge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeChargeFindFirstArgs>(args?: SelectSubset<T, FeeChargeFindFirstArgs<ExtArgs>>): Prisma__FeeChargeClient<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeCharge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeChargeFindFirstOrThrowArgs} args - Arguments to find a FeeCharge
     * @example
     * // Get one FeeCharge
     * const feeCharge = await prisma.feeCharge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeChargeFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeChargeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeChargeClient<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeCharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeChargeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeCharges
     * const feeCharges = await prisma.feeCharge.findMany()
     * 
     * // Get first 10 FeeCharges
     * const feeCharges = await prisma.feeCharge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeChargeWithIdOnly = await prisma.feeCharge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeChargeFindManyArgs>(args?: SelectSubset<T, FeeChargeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeCharge.
     * @param {FeeChargeCreateArgs} args - Arguments to create a FeeCharge.
     * @example
     * // Create one FeeCharge
     * const FeeCharge = await prisma.feeCharge.create({
     *   data: {
     *     // ... data to create a FeeCharge
     *   }
     * })
     * 
     */
    create<T extends FeeChargeCreateArgs>(args: SelectSubset<T, FeeChargeCreateArgs<ExtArgs>>): Prisma__FeeChargeClient<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeCharges.
     * @param {FeeChargeCreateManyArgs} args - Arguments to create many FeeCharges.
     * @example
     * // Create many FeeCharges
     * const feeCharge = await prisma.feeCharge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeChargeCreateManyArgs>(args?: SelectSubset<T, FeeChargeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeCharges and returns the data saved in the database.
     * @param {FeeChargeCreateManyAndReturnArgs} args - Arguments to create many FeeCharges.
     * @example
     * // Create many FeeCharges
     * const feeCharge = await prisma.feeCharge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeCharges and only return the `id`
     * const feeChargeWithIdOnly = await prisma.feeCharge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeChargeCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeChargeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeCharge.
     * @param {FeeChargeDeleteArgs} args - Arguments to delete one FeeCharge.
     * @example
     * // Delete one FeeCharge
     * const FeeCharge = await prisma.feeCharge.delete({
     *   where: {
     *     // ... filter to delete one FeeCharge
     *   }
     * })
     * 
     */
    delete<T extends FeeChargeDeleteArgs>(args: SelectSubset<T, FeeChargeDeleteArgs<ExtArgs>>): Prisma__FeeChargeClient<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeCharge.
     * @param {FeeChargeUpdateArgs} args - Arguments to update one FeeCharge.
     * @example
     * // Update one FeeCharge
     * const feeCharge = await prisma.feeCharge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeChargeUpdateArgs>(args: SelectSubset<T, FeeChargeUpdateArgs<ExtArgs>>): Prisma__FeeChargeClient<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeCharges.
     * @param {FeeChargeDeleteManyArgs} args - Arguments to filter FeeCharges to delete.
     * @example
     * // Delete a few FeeCharges
     * const { count } = await prisma.feeCharge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeChargeDeleteManyArgs>(args?: SelectSubset<T, FeeChargeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeCharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeChargeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeCharges
     * const feeCharge = await prisma.feeCharge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeChargeUpdateManyArgs>(args: SelectSubset<T, FeeChargeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeCharges and returns the data updated in the database.
     * @param {FeeChargeUpdateManyAndReturnArgs} args - Arguments to update many FeeCharges.
     * @example
     * // Update many FeeCharges
     * const feeCharge = await prisma.feeCharge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeCharges and only return the `id`
     * const feeChargeWithIdOnly = await prisma.feeCharge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeChargeUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeChargeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeCharge.
     * @param {FeeChargeUpsertArgs} args - Arguments to update or create a FeeCharge.
     * @example
     * // Update or create a FeeCharge
     * const feeCharge = await prisma.feeCharge.upsert({
     *   create: {
     *     // ... data to create a FeeCharge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeCharge we want to update
     *   }
     * })
     */
    upsert<T extends FeeChargeUpsertArgs>(args: SelectSubset<T, FeeChargeUpsertArgs<ExtArgs>>): Prisma__FeeChargeClient<$Result.GetResult<Prisma.$FeeChargePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeCharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeChargeCountArgs} args - Arguments to filter FeeCharges to count.
     * @example
     * // Count the number of FeeCharges
     * const count = await prisma.feeCharge.count({
     *   where: {
     *     // ... the filter for the FeeCharges we want to count
     *   }
     * })
    **/
    count<T extends FeeChargeCountArgs>(
      args?: Subset<T, FeeChargeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeChargeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeCharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeChargeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeChargeAggregateArgs>(args: Subset<T, FeeChargeAggregateArgs>): Prisma.PrismaPromise<GetFeeChargeAggregateType<T>>

    /**
     * Group by FeeCharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeChargeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeChargeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeChargeGroupByArgs['orderBy'] }
        : { orderBy?: FeeChargeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeChargeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeChargeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeCharge model
   */
  readonly fields: FeeChargeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeCharge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeChargeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feeAccount<T extends FeeAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeeAccountDefaultArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeCharge model
   */
  interface FeeChargeFieldRefs {
    readonly id: FieldRef<"FeeCharge", 'String'>
    readonly feeAccountId: FieldRef<"FeeCharge", 'String'>
    readonly title: FieldRef<"FeeCharge", 'String'>
    readonly amount: FieldRef<"FeeCharge", 'Int'>
    readonly dueDate: FieldRef<"FeeCharge", 'DateTime'>
    readonly status: FieldRef<"FeeCharge", 'String'>
    readonly createdAt: FieldRef<"FeeCharge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeeCharge findUnique
   */
  export type FeeChargeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
    /**
     * Filter, which FeeCharge to fetch.
     */
    where: FeeChargeWhereUniqueInput
  }

  /**
   * FeeCharge findUniqueOrThrow
   */
  export type FeeChargeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
    /**
     * Filter, which FeeCharge to fetch.
     */
    where: FeeChargeWhereUniqueInput
  }

  /**
   * FeeCharge findFirst
   */
  export type FeeChargeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
    /**
     * Filter, which FeeCharge to fetch.
     */
    where?: FeeChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeCharges to fetch.
     */
    orderBy?: FeeChargeOrderByWithRelationInput | FeeChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeCharges.
     */
    cursor?: FeeChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeCharges.
     */
    distinct?: FeeChargeScalarFieldEnum | FeeChargeScalarFieldEnum[]
  }

  /**
   * FeeCharge findFirstOrThrow
   */
  export type FeeChargeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
    /**
     * Filter, which FeeCharge to fetch.
     */
    where?: FeeChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeCharges to fetch.
     */
    orderBy?: FeeChargeOrderByWithRelationInput | FeeChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeCharges.
     */
    cursor?: FeeChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeCharges.
     */
    distinct?: FeeChargeScalarFieldEnum | FeeChargeScalarFieldEnum[]
  }

  /**
   * FeeCharge findMany
   */
  export type FeeChargeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
    /**
     * Filter, which FeeCharges to fetch.
     */
    where?: FeeChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeCharges to fetch.
     */
    orderBy?: FeeChargeOrderByWithRelationInput | FeeChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeCharges.
     */
    cursor?: FeeChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeCharges.
     */
    skip?: number
    distinct?: FeeChargeScalarFieldEnum | FeeChargeScalarFieldEnum[]
  }

  /**
   * FeeCharge create
   */
  export type FeeChargeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeCharge.
     */
    data: XOR<FeeChargeCreateInput, FeeChargeUncheckedCreateInput>
  }

  /**
   * FeeCharge createMany
   */
  export type FeeChargeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeCharges.
     */
    data: FeeChargeCreateManyInput | FeeChargeCreateManyInput[]
  }

  /**
   * FeeCharge createManyAndReturn
   */
  export type FeeChargeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * The data used to create many FeeCharges.
     */
    data: FeeChargeCreateManyInput | FeeChargeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeCharge update
   */
  export type FeeChargeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeCharge.
     */
    data: XOR<FeeChargeUpdateInput, FeeChargeUncheckedUpdateInput>
    /**
     * Choose, which FeeCharge to update.
     */
    where: FeeChargeWhereUniqueInput
  }

  /**
   * FeeCharge updateMany
   */
  export type FeeChargeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeCharges.
     */
    data: XOR<FeeChargeUpdateManyMutationInput, FeeChargeUncheckedUpdateManyInput>
    /**
     * Filter which FeeCharges to update
     */
    where?: FeeChargeWhereInput
    /**
     * Limit how many FeeCharges to update.
     */
    limit?: number
  }

  /**
   * FeeCharge updateManyAndReturn
   */
  export type FeeChargeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * The data used to update FeeCharges.
     */
    data: XOR<FeeChargeUpdateManyMutationInput, FeeChargeUncheckedUpdateManyInput>
    /**
     * Filter which FeeCharges to update
     */
    where?: FeeChargeWhereInput
    /**
     * Limit how many FeeCharges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeCharge upsert
   */
  export type FeeChargeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeCharge to update in case it exists.
     */
    where: FeeChargeWhereUniqueInput
    /**
     * In case the FeeCharge found by the `where` argument doesn't exist, create a new FeeCharge with this data.
     */
    create: XOR<FeeChargeCreateInput, FeeChargeUncheckedCreateInput>
    /**
     * In case the FeeCharge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeChargeUpdateInput, FeeChargeUncheckedUpdateInput>
  }

  /**
   * FeeCharge delete
   */
  export type FeeChargeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
    /**
     * Filter which FeeCharge to delete.
     */
    where: FeeChargeWhereUniqueInput
  }

  /**
   * FeeCharge deleteMany
   */
  export type FeeChargeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeCharges to delete
     */
    where?: FeeChargeWhereInput
    /**
     * Limit how many FeeCharges to delete.
     */
    limit?: number
  }

  /**
   * FeeCharge without action
   */
  export type FeeChargeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeCharge
     */
    select?: FeeChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeCharge
     */
    omit?: FeeChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeChargeInclude<ExtArgs> | null
  }


  /**
   * Model FeePayment
   */

  export type AggregateFeePayment = {
    _count: FeePaymentCountAggregateOutputType | null
    _avg: FeePaymentAvgAggregateOutputType | null
    _sum: FeePaymentSumAggregateOutputType | null
    _min: FeePaymentMinAggregateOutputType | null
    _max: FeePaymentMaxAggregateOutputType | null
  }

  export type FeePaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type FeePaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type FeePaymentMinAggregateOutputType = {
    id: string | null
    feeAccountId: string | null
    amount: number | null
    paidAt: Date | null
    method: string | null
    reference: string | null
    createdAt: Date | null
  }

  export type FeePaymentMaxAggregateOutputType = {
    id: string | null
    feeAccountId: string | null
    amount: number | null
    paidAt: Date | null
    method: string | null
    reference: string | null
    createdAt: Date | null
  }

  export type FeePaymentCountAggregateOutputType = {
    id: number
    feeAccountId: number
    amount: number
    paidAt: number
    method: number
    reference: number
    createdAt: number
    _all: number
  }


  export type FeePaymentAvgAggregateInputType = {
    amount?: true
  }

  export type FeePaymentSumAggregateInputType = {
    amount?: true
  }

  export type FeePaymentMinAggregateInputType = {
    id?: true
    feeAccountId?: true
    amount?: true
    paidAt?: true
    method?: true
    reference?: true
    createdAt?: true
  }

  export type FeePaymentMaxAggregateInputType = {
    id?: true
    feeAccountId?: true
    amount?: true
    paidAt?: true
    method?: true
    reference?: true
    createdAt?: true
  }

  export type FeePaymentCountAggregateInputType = {
    id?: true
    feeAccountId?: true
    amount?: true
    paidAt?: true
    method?: true
    reference?: true
    createdAt?: true
    _all?: true
  }

  export type FeePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeePayment to aggregate.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeePayments
    **/
    _count?: true | FeePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeePaymentMaxAggregateInputType
  }

  export type GetFeePaymentAggregateType<T extends FeePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeePayment[P]>
      : GetScalarType<T[P], AggregateFeePayment[P]>
  }




  export type FeePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeePaymentWhereInput
    orderBy?: FeePaymentOrderByWithAggregationInput | FeePaymentOrderByWithAggregationInput[]
    by: FeePaymentScalarFieldEnum[] | FeePaymentScalarFieldEnum
    having?: FeePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeePaymentCountAggregateInputType | true
    _avg?: FeePaymentAvgAggregateInputType
    _sum?: FeePaymentSumAggregateInputType
    _min?: FeePaymentMinAggregateInputType
    _max?: FeePaymentMaxAggregateInputType
  }

  export type FeePaymentGroupByOutputType = {
    id: string
    feeAccountId: string
    amount: number
    paidAt: Date
    method: string | null
    reference: string | null
    createdAt: Date
    _count: FeePaymentCountAggregateOutputType | null
    _avg: FeePaymentAvgAggregateOutputType | null
    _sum: FeePaymentSumAggregateOutputType | null
    _min: FeePaymentMinAggregateOutputType | null
    _max: FeePaymentMaxAggregateOutputType | null
  }

  type GetFeePaymentGroupByPayload<T extends FeePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], FeePaymentGroupByOutputType[P]>
        }
      >
    >


  export type FeePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeAccountId?: boolean
    amount?: boolean
    paidAt?: boolean
    method?: boolean
    reference?: boolean
    createdAt?: boolean
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feePayment"]>

  export type FeePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeAccountId?: boolean
    amount?: boolean
    paidAt?: boolean
    method?: boolean
    reference?: boolean
    createdAt?: boolean
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feePayment"]>

  export type FeePaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeAccountId?: boolean
    amount?: boolean
    paidAt?: boolean
    method?: boolean
    reference?: boolean
    createdAt?: boolean
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feePayment"]>

  export type FeePaymentSelectScalar = {
    id?: boolean
    feeAccountId?: boolean
    amount?: boolean
    paidAt?: boolean
    method?: boolean
    reference?: boolean
    createdAt?: boolean
  }

  export type FeePaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feeAccountId" | "amount" | "paidAt" | "method" | "reference" | "createdAt", ExtArgs["result"]["feePayment"]>
  export type FeePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }
  export type FeePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }
  export type FeePaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeAccount?: boolean | FeeAccountDefaultArgs<ExtArgs>
  }

  export type $FeePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeePayment"
    objects: {
      feeAccount: Prisma.$FeeAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feeAccountId: string
      amount: number
      paidAt: Date
      method: string | null
      reference: string | null
      createdAt: Date
    }, ExtArgs["result"]["feePayment"]>
    composites: {}
  }

  type FeePaymentGetPayload<S extends boolean | null | undefined | FeePaymentDefaultArgs> = $Result.GetResult<Prisma.$FeePaymentPayload, S>

  type FeePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeePaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeePaymentCountAggregateInputType | true
    }

  export interface FeePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeePayment'], meta: { name: 'FeePayment' } }
    /**
     * Find zero or one FeePayment that matches the filter.
     * @param {FeePaymentFindUniqueArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeePaymentFindUniqueArgs>(args: SelectSubset<T, FeePaymentFindUniqueArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeePayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeePaymentFindUniqueOrThrowArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, FeePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindFirstArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeePaymentFindFirstArgs>(args?: SelectSubset<T, FeePaymentFindFirstArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindFirstOrThrowArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, FeePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeePayments
     * const feePayments = await prisma.feePayment.findMany()
     * 
     * // Get first 10 FeePayments
     * const feePayments = await prisma.feePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feePaymentWithIdOnly = await prisma.feePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeePaymentFindManyArgs>(args?: SelectSubset<T, FeePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeePayment.
     * @param {FeePaymentCreateArgs} args - Arguments to create a FeePayment.
     * @example
     * // Create one FeePayment
     * const FeePayment = await prisma.feePayment.create({
     *   data: {
     *     // ... data to create a FeePayment
     *   }
     * })
     * 
     */
    create<T extends FeePaymentCreateArgs>(args: SelectSubset<T, FeePaymentCreateArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeePayments.
     * @param {FeePaymentCreateManyArgs} args - Arguments to create many FeePayments.
     * @example
     * // Create many FeePayments
     * const feePayment = await prisma.feePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeePaymentCreateManyArgs>(args?: SelectSubset<T, FeePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeePayments and returns the data saved in the database.
     * @param {FeePaymentCreateManyAndReturnArgs} args - Arguments to create many FeePayments.
     * @example
     * // Create many FeePayments
     * const feePayment = await prisma.feePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeePayments and only return the `id`
     * const feePaymentWithIdOnly = await prisma.feePayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, FeePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeePayment.
     * @param {FeePaymentDeleteArgs} args - Arguments to delete one FeePayment.
     * @example
     * // Delete one FeePayment
     * const FeePayment = await prisma.feePayment.delete({
     *   where: {
     *     // ... filter to delete one FeePayment
     *   }
     * })
     * 
     */
    delete<T extends FeePaymentDeleteArgs>(args: SelectSubset<T, FeePaymentDeleteArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeePayment.
     * @param {FeePaymentUpdateArgs} args - Arguments to update one FeePayment.
     * @example
     * // Update one FeePayment
     * const feePayment = await prisma.feePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeePaymentUpdateArgs>(args: SelectSubset<T, FeePaymentUpdateArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeePayments.
     * @param {FeePaymentDeleteManyArgs} args - Arguments to filter FeePayments to delete.
     * @example
     * // Delete a few FeePayments
     * const { count } = await prisma.feePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeePaymentDeleteManyArgs>(args?: SelectSubset<T, FeePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeePayments
     * const feePayment = await prisma.feePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeePaymentUpdateManyArgs>(args: SelectSubset<T, FeePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeePayments and returns the data updated in the database.
     * @param {FeePaymentUpdateManyAndReturnArgs} args - Arguments to update many FeePayments.
     * @example
     * // Update many FeePayments
     * const feePayment = await prisma.feePayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeePayments and only return the `id`
     * const feePaymentWithIdOnly = await prisma.feePayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeePaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, FeePaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeePayment.
     * @param {FeePaymentUpsertArgs} args - Arguments to update or create a FeePayment.
     * @example
     * // Update or create a FeePayment
     * const feePayment = await prisma.feePayment.upsert({
     *   create: {
     *     // ... data to create a FeePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeePayment we want to update
     *   }
     * })
     */
    upsert<T extends FeePaymentUpsertArgs>(args: SelectSubset<T, FeePaymentUpsertArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentCountArgs} args - Arguments to filter FeePayments to count.
     * @example
     * // Count the number of FeePayments
     * const count = await prisma.feePayment.count({
     *   where: {
     *     // ... the filter for the FeePayments we want to count
     *   }
     * })
    **/
    count<T extends FeePaymentCountArgs>(
      args?: Subset<T, FeePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeePaymentAggregateArgs>(args: Subset<T, FeePaymentAggregateArgs>): Prisma.PrismaPromise<GetFeePaymentAggregateType<T>>

    /**
     * Group by FeePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeePaymentGroupByArgs['orderBy'] }
        : { orderBy?: FeePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeePayment model
   */
  readonly fields: FeePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feeAccount<T extends FeeAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeeAccountDefaultArgs<ExtArgs>>): Prisma__FeeAccountClient<$Result.GetResult<Prisma.$FeeAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeePayment model
   */
  interface FeePaymentFieldRefs {
    readonly id: FieldRef<"FeePayment", 'String'>
    readonly feeAccountId: FieldRef<"FeePayment", 'String'>
    readonly amount: FieldRef<"FeePayment", 'Int'>
    readonly paidAt: FieldRef<"FeePayment", 'DateTime'>
    readonly method: FieldRef<"FeePayment", 'String'>
    readonly reference: FieldRef<"FeePayment", 'String'>
    readonly createdAt: FieldRef<"FeePayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeePayment findUnique
   */
  export type FeePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment findUniqueOrThrow
   */
  export type FeePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment findFirst
   */
  export type FeePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeePayments.
     */
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * FeePayment findFirstOrThrow
   */
  export type FeePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeePayments.
     */
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * FeePayment findMany
   */
  export type FeePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayments to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * FeePayment create
   */
  export type FeePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a FeePayment.
     */
    data: XOR<FeePaymentCreateInput, FeePaymentUncheckedCreateInput>
  }

  /**
   * FeePayment createMany
   */
  export type FeePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeePayments.
     */
    data: FeePaymentCreateManyInput | FeePaymentCreateManyInput[]
  }

  /**
   * FeePayment createManyAndReturn
   */
  export type FeePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * The data used to create many FeePayments.
     */
    data: FeePaymentCreateManyInput | FeePaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeePayment update
   */
  export type FeePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a FeePayment.
     */
    data: XOR<FeePaymentUpdateInput, FeePaymentUncheckedUpdateInput>
    /**
     * Choose, which FeePayment to update.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment updateMany
   */
  export type FeePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeePayments.
     */
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyInput>
    /**
     * Filter which FeePayments to update
     */
    where?: FeePaymentWhereInput
    /**
     * Limit how many FeePayments to update.
     */
    limit?: number
  }

  /**
   * FeePayment updateManyAndReturn
   */
  export type FeePaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * The data used to update FeePayments.
     */
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyInput>
    /**
     * Filter which FeePayments to update
     */
    where?: FeePaymentWhereInput
    /**
     * Limit how many FeePayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeePayment upsert
   */
  export type FeePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the FeePayment to update in case it exists.
     */
    where: FeePaymentWhereUniqueInput
    /**
     * In case the FeePayment found by the `where` argument doesn't exist, create a new FeePayment with this data.
     */
    create: XOR<FeePaymentCreateInput, FeePaymentUncheckedCreateInput>
    /**
     * In case the FeePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeePaymentUpdateInput, FeePaymentUncheckedUpdateInput>
  }

  /**
   * FeePayment delete
   */
  export type FeePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter which FeePayment to delete.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment deleteMany
   */
  export type FeePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeePayments to delete
     */
    where?: FeePaymentWhereInput
    /**
     * Limit how many FeePayments to delete.
     */
    limit?: number
  }

  /**
   * FeePayment without action
   */
  export type FeePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeePayment
     */
    omit?: FeePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
  }


  /**
   * Model Counter
   */

  export type AggregateCounter = {
    _count: CounterCountAggregateOutputType | null
    _avg: CounterAvgAggregateOutputType | null
    _sum: CounterSumAggregateOutputType | null
    _min: CounterMinAggregateOutputType | null
    _max: CounterMaxAggregateOutputType | null
  }

  export type CounterAvgAggregateOutputType = {
    value: number | null
  }

  export type CounterSumAggregateOutputType = {
    value: number | null
  }

  export type CounterMinAggregateOutputType = {
    key: string | null
    value: number | null
  }

  export type CounterMaxAggregateOutputType = {
    key: string | null
    value: number | null
  }

  export type CounterCountAggregateOutputType = {
    key: number
    value: number
    _all: number
  }


  export type CounterAvgAggregateInputType = {
    value?: true
  }

  export type CounterSumAggregateInputType = {
    value?: true
  }

  export type CounterMinAggregateInputType = {
    key?: true
    value?: true
  }

  export type CounterMaxAggregateInputType = {
    key?: true
    value?: true
  }

  export type CounterCountAggregateInputType = {
    key?: true
    value?: true
    _all?: true
  }

  export type CounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Counter to aggregate.
     */
    where?: CounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counters to fetch.
     */
    orderBy?: CounterOrderByWithRelationInput | CounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Counters
    **/
    _count?: true | CounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CounterMaxAggregateInputType
  }

  export type GetCounterAggregateType<T extends CounterAggregateArgs> = {
        [P in keyof T & keyof AggregateCounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounter[P]>
      : GetScalarType<T[P], AggregateCounter[P]>
  }




  export type CounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CounterWhereInput
    orderBy?: CounterOrderByWithAggregationInput | CounterOrderByWithAggregationInput[]
    by: CounterScalarFieldEnum[] | CounterScalarFieldEnum
    having?: CounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CounterCountAggregateInputType | true
    _avg?: CounterAvgAggregateInputType
    _sum?: CounterSumAggregateInputType
    _min?: CounterMinAggregateInputType
    _max?: CounterMaxAggregateInputType
  }

  export type CounterGroupByOutputType = {
    key: string
    value: number
    _count: CounterCountAggregateOutputType | null
    _avg: CounterAvgAggregateOutputType | null
    _sum: CounterSumAggregateOutputType | null
    _min: CounterMinAggregateOutputType | null
    _max: CounterMaxAggregateOutputType | null
  }

  type GetCounterGroupByPayload<T extends CounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CounterGroupByOutputType[P]>
            : GetScalarType<T[P], CounterGroupByOutputType[P]>
        }
      >
    >


  export type CounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["counter"]>

  export type CounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["counter"]>

  export type CounterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["counter"]>

  export type CounterSelectScalar = {
    key?: boolean
    value?: boolean
  }

  export type CounterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value", ExtArgs["result"]["counter"]>

  export type $CounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Counter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: number
    }, ExtArgs["result"]["counter"]>
    composites: {}
  }

  type CounterGetPayload<S extends boolean | null | undefined | CounterDefaultArgs> = $Result.GetResult<Prisma.$CounterPayload, S>

  type CounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CounterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CounterCountAggregateInputType | true
    }

  export interface CounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Counter'], meta: { name: 'Counter' } }
    /**
     * Find zero or one Counter that matches the filter.
     * @param {CounterFindUniqueArgs} args - Arguments to find a Counter
     * @example
     * // Get one Counter
     * const counter = await prisma.counter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CounterFindUniqueArgs>(args: SelectSubset<T, CounterFindUniqueArgs<ExtArgs>>): Prisma__CounterClient<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Counter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CounterFindUniqueOrThrowArgs} args - Arguments to find a Counter
     * @example
     * // Get one Counter
     * const counter = await prisma.counter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CounterFindUniqueOrThrowArgs>(args: SelectSubset<T, CounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CounterClient<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterFindFirstArgs} args - Arguments to find a Counter
     * @example
     * // Get one Counter
     * const counter = await prisma.counter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CounterFindFirstArgs>(args?: SelectSubset<T, CounterFindFirstArgs<ExtArgs>>): Prisma__CounterClient<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterFindFirstOrThrowArgs} args - Arguments to find a Counter
     * @example
     * // Get one Counter
     * const counter = await prisma.counter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CounterFindFirstOrThrowArgs>(args?: SelectSubset<T, CounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CounterClient<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Counters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counters
     * const counters = await prisma.counter.findMany()
     * 
     * // Get first 10 Counters
     * const counters = await prisma.counter.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const counterWithKeyOnly = await prisma.counter.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends CounterFindManyArgs>(args?: SelectSubset<T, CounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Counter.
     * @param {CounterCreateArgs} args - Arguments to create a Counter.
     * @example
     * // Create one Counter
     * const Counter = await prisma.counter.create({
     *   data: {
     *     // ... data to create a Counter
     *   }
     * })
     * 
     */
    create<T extends CounterCreateArgs>(args: SelectSubset<T, CounterCreateArgs<ExtArgs>>): Prisma__CounterClient<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Counters.
     * @param {CounterCreateManyArgs} args - Arguments to create many Counters.
     * @example
     * // Create many Counters
     * const counter = await prisma.counter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CounterCreateManyArgs>(args?: SelectSubset<T, CounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Counters and returns the data saved in the database.
     * @param {CounterCreateManyAndReturnArgs} args - Arguments to create many Counters.
     * @example
     * // Create many Counters
     * const counter = await prisma.counter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Counters and only return the `key`
     * const counterWithKeyOnly = await prisma.counter.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CounterCreateManyAndReturnArgs>(args?: SelectSubset<T, CounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Counter.
     * @param {CounterDeleteArgs} args - Arguments to delete one Counter.
     * @example
     * // Delete one Counter
     * const Counter = await prisma.counter.delete({
     *   where: {
     *     // ... filter to delete one Counter
     *   }
     * })
     * 
     */
    delete<T extends CounterDeleteArgs>(args: SelectSubset<T, CounterDeleteArgs<ExtArgs>>): Prisma__CounterClient<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Counter.
     * @param {CounterUpdateArgs} args - Arguments to update one Counter.
     * @example
     * // Update one Counter
     * const counter = await prisma.counter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CounterUpdateArgs>(args: SelectSubset<T, CounterUpdateArgs<ExtArgs>>): Prisma__CounterClient<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Counters.
     * @param {CounterDeleteManyArgs} args - Arguments to filter Counters to delete.
     * @example
     * // Delete a few Counters
     * const { count } = await prisma.counter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CounterDeleteManyArgs>(args?: SelectSubset<T, CounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counters
     * const counter = await prisma.counter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CounterUpdateManyArgs>(args: SelectSubset<T, CounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counters and returns the data updated in the database.
     * @param {CounterUpdateManyAndReturnArgs} args - Arguments to update many Counters.
     * @example
     * // Update many Counters
     * const counter = await prisma.counter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Counters and only return the `key`
     * const counterWithKeyOnly = await prisma.counter.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CounterUpdateManyAndReturnArgs>(args: SelectSubset<T, CounterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Counter.
     * @param {CounterUpsertArgs} args - Arguments to update or create a Counter.
     * @example
     * // Update or create a Counter
     * const counter = await prisma.counter.upsert({
     *   create: {
     *     // ... data to create a Counter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Counter we want to update
     *   }
     * })
     */
    upsert<T extends CounterUpsertArgs>(args: SelectSubset<T, CounterUpsertArgs<ExtArgs>>): Prisma__CounterClient<$Result.GetResult<Prisma.$CounterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Counters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterCountArgs} args - Arguments to filter Counters to count.
     * @example
     * // Count the number of Counters
     * const count = await prisma.counter.count({
     *   where: {
     *     // ... the filter for the Counters we want to count
     *   }
     * })
    **/
    count<T extends CounterCountArgs>(
      args?: Subset<T, CounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Counter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CounterAggregateArgs>(args: Subset<T, CounterAggregateArgs>): Prisma.PrismaPromise<GetCounterAggregateType<T>>

    /**
     * Group by Counter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CounterGroupByArgs['orderBy'] }
        : { orderBy?: CounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Counter model
   */
  readonly fields: CounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Counter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Counter model
   */
  interface CounterFieldRefs {
    readonly key: FieldRef<"Counter", 'String'>
    readonly value: FieldRef<"Counter", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Counter findUnique
   */
  export type CounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * Filter, which Counter to fetch.
     */
    where: CounterWhereUniqueInput
  }

  /**
   * Counter findUniqueOrThrow
   */
  export type CounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * Filter, which Counter to fetch.
     */
    where: CounterWhereUniqueInput
  }

  /**
   * Counter findFirst
   */
  export type CounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * Filter, which Counter to fetch.
     */
    where?: CounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counters to fetch.
     */
    orderBy?: CounterOrderByWithRelationInput | CounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counters.
     */
    cursor?: CounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counters.
     */
    distinct?: CounterScalarFieldEnum | CounterScalarFieldEnum[]
  }

  /**
   * Counter findFirstOrThrow
   */
  export type CounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * Filter, which Counter to fetch.
     */
    where?: CounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counters to fetch.
     */
    orderBy?: CounterOrderByWithRelationInput | CounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counters.
     */
    cursor?: CounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counters.
     */
    distinct?: CounterScalarFieldEnum | CounterScalarFieldEnum[]
  }

  /**
   * Counter findMany
   */
  export type CounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * Filter, which Counters to fetch.
     */
    where?: CounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counters to fetch.
     */
    orderBy?: CounterOrderByWithRelationInput | CounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Counters.
     */
    cursor?: CounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counters.
     */
    skip?: number
    distinct?: CounterScalarFieldEnum | CounterScalarFieldEnum[]
  }

  /**
   * Counter create
   */
  export type CounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * The data needed to create a Counter.
     */
    data: XOR<CounterCreateInput, CounterUncheckedCreateInput>
  }

  /**
   * Counter createMany
   */
  export type CounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Counters.
     */
    data: CounterCreateManyInput | CounterCreateManyInput[]
  }

  /**
   * Counter createManyAndReturn
   */
  export type CounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * The data used to create many Counters.
     */
    data: CounterCreateManyInput | CounterCreateManyInput[]
  }

  /**
   * Counter update
   */
  export type CounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * The data needed to update a Counter.
     */
    data: XOR<CounterUpdateInput, CounterUncheckedUpdateInput>
    /**
     * Choose, which Counter to update.
     */
    where: CounterWhereUniqueInput
  }

  /**
   * Counter updateMany
   */
  export type CounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Counters.
     */
    data: XOR<CounterUpdateManyMutationInput, CounterUncheckedUpdateManyInput>
    /**
     * Filter which Counters to update
     */
    where?: CounterWhereInput
    /**
     * Limit how many Counters to update.
     */
    limit?: number
  }

  /**
   * Counter updateManyAndReturn
   */
  export type CounterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * The data used to update Counters.
     */
    data: XOR<CounterUpdateManyMutationInput, CounterUncheckedUpdateManyInput>
    /**
     * Filter which Counters to update
     */
    where?: CounterWhereInput
    /**
     * Limit how many Counters to update.
     */
    limit?: number
  }

  /**
   * Counter upsert
   */
  export type CounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * The filter to search for the Counter to update in case it exists.
     */
    where: CounterWhereUniqueInput
    /**
     * In case the Counter found by the `where` argument doesn't exist, create a new Counter with this data.
     */
    create: XOR<CounterCreateInput, CounterUncheckedCreateInput>
    /**
     * In case the Counter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CounterUpdateInput, CounterUncheckedUpdateInput>
  }

  /**
   * Counter delete
   */
  export type CounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
    /**
     * Filter which Counter to delete.
     */
    where: CounterWhereUniqueInput
  }

  /**
   * Counter deleteMany
   */
  export type CounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Counters to delete
     */
    where?: CounterWhereInput
    /**
     * Limit how many Counters to delete.
     */
    limit?: number
  }

  /**
   * Counter without action
   */
  export type CounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counter
     */
    select?: CounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Counter
     */
    omit?: CounterOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    role: 'role',
    email: 'email',
    phone: 'phone',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    displayId: 'displayId',
    fullName: 'fullName',
    programId: 'programId',
    semester: 'semester',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const FacultyProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    employeeCode: 'employeeCode',
    departmentId: 'departmentId',
    designationId: 'designationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacultyProfileScalarFieldEnum = (typeof FacultyProfileScalarFieldEnum)[keyof typeof FacultyProfileScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const DesignationScalarFieldEnum: {
    id: 'id',
    departmentId: 'departmentId',
    title: 'title',
    level: 'level',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DesignationScalarFieldEnum = (typeof DesignationScalarFieldEnum)[keyof typeof DesignationScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    departmentId: 'departmentId',
    name: 'name',
    code: 'code',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const FacultySubjectScalarFieldEnum: {
    id: 'id',
    facultyId: 'facultyId',
    subjectId: 'subjectId',
    createdAt: 'createdAt'
  };

  export type FacultySubjectScalarFieldEnum = (typeof FacultySubjectScalarFieldEnum)[keyof typeof FacultySubjectScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    code: 'code',
    title: 'title',
    credits: 'credits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseOfferingScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    facultyId: 'facultyId',
    semester: 'semester',
    academicYear: 'academicYear',
    term: 'term',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseOfferingScalarFieldEnum = (typeof CourseOfferingScalarFieldEnum)[keyof typeof CourseOfferingScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    offeringId: 'offeringId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const AttendanceSessionScalarFieldEnum: {
    id: 'id',
    offeringId: 'offeringId',
    sessionDate: 'sessionDate',
    createdAt: 'createdAt'
  };

  export type AttendanceSessionScalarFieldEnum = (typeof AttendanceSessionScalarFieldEnum)[keyof typeof AttendanceSessionScalarFieldEnum]


  export const AttendanceMarkScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    studentId: 'studentId',
    status: 'status',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type AttendanceMarkScalarFieldEnum = (typeof AttendanceMarkScalarFieldEnum)[keyof typeof AttendanceMarkScalarFieldEnum]


  export const LibraryBookScalarFieldEnum: {
    id: 'id',
    title: 'title',
    author: 'author',
    isbn: 'isbn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryBookScalarFieldEnum = (typeof LibraryBookScalarFieldEnum)[keyof typeof LibraryBookScalarFieldEnum]


  export const LibraryCopyScalarFieldEnum: {
    id: 'id',
    bookId: 'bookId',
    barcode: 'barcode',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryCopyScalarFieldEnum = (typeof LibraryCopyScalarFieldEnum)[keyof typeof LibraryCopyScalarFieldEnum]


  export const LibraryIssueScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    copyId: 'copyId',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    returnDate: 'returnDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryIssueScalarFieldEnum = (typeof LibraryIssueScalarFieldEnum)[keyof typeof LibraryIssueScalarFieldEnum]


  export const RequestScalarFieldEnum: {
    id: 'id',
    displayId: 'displayId',
    studentId: 'studentId',
    title: 'title',
    description: 'description',
    status: 'status',
    submittedAt: 'submittedAt',
    updatedAt: 'updatedAt'
  };

  export type RequestScalarFieldEnum = (typeof RequestScalarFieldEnum)[keyof typeof RequestScalarFieldEnum]


  export const StudentSettingScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    theme: 'theme',
    notificationsEnabled: 'notificationsEnabled',
    language: 'language',
    profileVisibility: 'profileVisibility',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentSettingScalarFieldEnum = (typeof StudentSettingScalarFieldEnum)[keyof typeof StudentSettingScalarFieldEnum]


  export const FeeAccountScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    currency: 'currency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeeAccountScalarFieldEnum = (typeof FeeAccountScalarFieldEnum)[keyof typeof FeeAccountScalarFieldEnum]


  export const FeeChargeScalarFieldEnum: {
    id: 'id',
    feeAccountId: 'feeAccountId',
    title: 'title',
    amount: 'amount',
    dueDate: 'dueDate',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type FeeChargeScalarFieldEnum = (typeof FeeChargeScalarFieldEnum)[keyof typeof FeeChargeScalarFieldEnum]


  export const FeePaymentScalarFieldEnum: {
    id: 'id',
    feeAccountId: 'feeAccountId',
    amount: 'amount',
    paidAt: 'paidAt',
    method: 'method',
    reference: 'reference',
    createdAt: 'createdAt'
  };

  export type FeePaymentScalarFieldEnum = (typeof FeePaymentScalarFieldEnum)[keyof typeof FeePaymentScalarFieldEnum]


  export const CounterScalarFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type CounterScalarFieldEnum = (typeof CounterScalarFieldEnum)[keyof typeof CounterScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AttendanceMarkStatus'
   */
  export type EnumAttendanceMarkStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceMarkStatus'>
    


  /**
   * Reference to a field of type 'LibraryCopyStatus'
   */
  export type EnumLibraryCopyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LibraryCopyStatus'>
    


  /**
   * Reference to a field of type 'LibraryIssueStatus'
   */
  export type EnumLibraryIssueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LibraryIssueStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'Theme'
   */
  export type EnumThemeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Theme'>
    


  /**
   * Reference to a field of type 'ProfileVisibility'
   */
  export type EnumProfileVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProfileVisibility'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    faculty?: XOR<FacultyProfileNullableScalarRelationFilter, FacultyProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    faculty?: FacultyProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    faculty?: XOR<FacultyProfileNullableScalarRelationFilter, FacultyProfileWhereInput> | null
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: StringFilter<"Program"> | string
    name?: StringFilter<"Program"> | string
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    students?: StudentListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    students?: StudentOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    students?: StudentListRelationFilter
  }, "id" | "name">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Program"> | string
    name?: StringWithAggregatesFilter<"Program"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    displayId?: StringFilter<"Student"> | string
    fullName?: StringFilter<"Student"> | string
    programId?: StringFilter<"Student"> | string
    semester?: IntFilter<"Student"> | number
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    enrollments?: EnrollmentListRelationFilter
    attendanceMarks?: AttendanceMarkListRelationFilter
    libraryIssues?: LibraryIssueListRelationFilter
    requests?: RequestListRelationFilter
    settings?: XOR<StudentSettingNullableScalarRelationFilter, StudentSettingWhereInput> | null
    feeAccount?: XOR<FeeAccountNullableScalarRelationFilter, FeeAccountWhereInput> | null
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayId?: SortOrder
    fullName?: SortOrder
    programId?: SortOrder
    semester?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    attendanceMarks?: AttendanceMarkOrderByRelationAggregateInput
    libraryIssues?: LibraryIssueOrderByRelationAggregateInput
    requests?: RequestOrderByRelationAggregateInput
    settings?: StudentSettingOrderByWithRelationInput
    feeAccount?: FeeAccountOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    displayId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    fullName?: StringFilter<"Student"> | string
    programId?: StringFilter<"Student"> | string
    semester?: IntFilter<"Student"> | number
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    enrollments?: EnrollmentListRelationFilter
    attendanceMarks?: AttendanceMarkListRelationFilter
    libraryIssues?: LibraryIssueListRelationFilter
    requests?: RequestListRelationFilter
    settings?: XOR<StudentSettingNullableScalarRelationFilter, StudentSettingWhereInput> | null
    feeAccount?: XOR<FeeAccountNullableScalarRelationFilter, FeeAccountWhereInput> | null
  }, "id" | "userId" | "displayId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayId?: SortOrder
    fullName?: SortOrder
    programId?: SortOrder
    semester?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    displayId?: StringWithAggregatesFilter<"Student"> | string
    fullName?: StringWithAggregatesFilter<"Student"> | string
    programId?: StringWithAggregatesFilter<"Student"> | string
    semester?: IntWithAggregatesFilter<"Student"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type FacultyProfileWhereInput = {
    AND?: FacultyProfileWhereInput | FacultyProfileWhereInput[]
    OR?: FacultyProfileWhereInput[]
    NOT?: FacultyProfileWhereInput | FacultyProfileWhereInput[]
    id?: StringFilter<"FacultyProfile"> | string
    userId?: StringFilter<"FacultyProfile"> | string
    fullName?: StringNullableFilter<"FacultyProfile"> | string | null
    employeeCode?: StringNullableFilter<"FacultyProfile"> | string | null
    departmentId?: StringNullableFilter<"FacultyProfile"> | string | null
    designationId?: StringNullableFilter<"FacultyProfile"> | string | null
    createdAt?: DateTimeFilter<"FacultyProfile"> | Date | string
    updatedAt?: DateTimeFilter<"FacultyProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    designation?: XOR<DesignationNullableScalarRelationFilter, DesignationWhereInput> | null
    offerings?: CourseOfferingListRelationFilter
    subjects?: FacultySubjectListRelationFilter
  }

  export type FacultyProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrderInput | SortOrder
    employeeCode?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    designationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    designation?: DesignationOrderByWithRelationInput
    offerings?: CourseOfferingOrderByRelationAggregateInput
    subjects?: FacultySubjectOrderByRelationAggregateInput
  }

  export type FacultyProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: FacultyProfileWhereInput | FacultyProfileWhereInput[]
    OR?: FacultyProfileWhereInput[]
    NOT?: FacultyProfileWhereInput | FacultyProfileWhereInput[]
    fullName?: StringNullableFilter<"FacultyProfile"> | string | null
    employeeCode?: StringNullableFilter<"FacultyProfile"> | string | null
    departmentId?: StringNullableFilter<"FacultyProfile"> | string | null
    designationId?: StringNullableFilter<"FacultyProfile"> | string | null
    createdAt?: DateTimeFilter<"FacultyProfile"> | Date | string
    updatedAt?: DateTimeFilter<"FacultyProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    designation?: XOR<DesignationNullableScalarRelationFilter, DesignationWhereInput> | null
    offerings?: CourseOfferingListRelationFilter
    subjects?: FacultySubjectListRelationFilter
  }, "id" | "userId">

  export type FacultyProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrderInput | SortOrder
    employeeCode?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    designationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacultyProfileCountOrderByAggregateInput
    _max?: FacultyProfileMaxOrderByAggregateInput
    _min?: FacultyProfileMinOrderByAggregateInput
  }

  export type FacultyProfileScalarWhereWithAggregatesInput = {
    AND?: FacultyProfileScalarWhereWithAggregatesInput | FacultyProfileScalarWhereWithAggregatesInput[]
    OR?: FacultyProfileScalarWhereWithAggregatesInput[]
    NOT?: FacultyProfileScalarWhereWithAggregatesInput | FacultyProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FacultyProfile"> | string
    userId?: StringWithAggregatesFilter<"FacultyProfile"> | string
    fullName?: StringNullableWithAggregatesFilter<"FacultyProfile"> | string | null
    employeeCode?: StringNullableWithAggregatesFilter<"FacultyProfile"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"FacultyProfile"> | string | null
    designationId?: StringNullableWithAggregatesFilter<"FacultyProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FacultyProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FacultyProfile"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    designations?: DesignationListRelationFilter
    subjects?: SubjectListRelationFilter
    faculty?: FacultyProfileListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    designations?: DesignationOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    faculty?: FacultyProfileOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    code?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    designations?: DesignationListRelationFilter
    subjects?: SubjectListRelationFilter
    faculty?: FacultyProfileListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    code?: StringNullableWithAggregatesFilter<"Department"> | string | null
    isActive?: BoolWithAggregatesFilter<"Department"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type DesignationWhereInput = {
    AND?: DesignationWhereInput | DesignationWhereInput[]
    OR?: DesignationWhereInput[]
    NOT?: DesignationWhereInput | DesignationWhereInput[]
    id?: StringFilter<"Designation"> | string
    departmentId?: StringFilter<"Designation"> | string
    title?: StringFilter<"Designation"> | string
    level?: IntNullableFilter<"Designation"> | number | null
    isActive?: BoolFilter<"Designation"> | boolean
    createdAt?: DateTimeFilter<"Designation"> | Date | string
    updatedAt?: DateTimeFilter<"Designation"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    faculty?: FacultyProfileListRelationFilter
  }

  export type DesignationOrderByWithRelationInput = {
    id?: SortOrder
    departmentId?: SortOrder
    title?: SortOrder
    level?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    faculty?: FacultyProfileOrderByRelationAggregateInput
  }

  export type DesignationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    departmentId_title?: DesignationDepartmentIdTitleCompoundUniqueInput
    AND?: DesignationWhereInput | DesignationWhereInput[]
    OR?: DesignationWhereInput[]
    NOT?: DesignationWhereInput | DesignationWhereInput[]
    departmentId?: StringFilter<"Designation"> | string
    title?: StringFilter<"Designation"> | string
    level?: IntNullableFilter<"Designation"> | number | null
    isActive?: BoolFilter<"Designation"> | boolean
    createdAt?: DateTimeFilter<"Designation"> | Date | string
    updatedAt?: DateTimeFilter<"Designation"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    faculty?: FacultyProfileListRelationFilter
  }, "id" | "departmentId_title">

  export type DesignationOrderByWithAggregationInput = {
    id?: SortOrder
    departmentId?: SortOrder
    title?: SortOrder
    level?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DesignationCountOrderByAggregateInput
    _avg?: DesignationAvgOrderByAggregateInput
    _max?: DesignationMaxOrderByAggregateInput
    _min?: DesignationMinOrderByAggregateInput
    _sum?: DesignationSumOrderByAggregateInput
  }

  export type DesignationScalarWhereWithAggregatesInput = {
    AND?: DesignationScalarWhereWithAggregatesInput | DesignationScalarWhereWithAggregatesInput[]
    OR?: DesignationScalarWhereWithAggregatesInput[]
    NOT?: DesignationScalarWhereWithAggregatesInput | DesignationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Designation"> | string
    departmentId?: StringWithAggregatesFilter<"Designation"> | string
    title?: StringWithAggregatesFilter<"Designation"> | string
    level?: IntNullableWithAggregatesFilter<"Designation"> | number | null
    isActive?: BoolWithAggregatesFilter<"Designation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Designation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Designation"> | Date | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    departmentId?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    isActive?: BoolFilter<"Subject"> | boolean
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    faculty?: FacultySubjectListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    faculty?: FacultySubjectOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    departmentId_name?: SubjectDepartmentIdNameCompoundUniqueInput
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    departmentId?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    isActive?: BoolFilter<"Subject"> | boolean
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    faculty?: FacultySubjectListRelationFilter
  }, "id" | "departmentId_name">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    departmentId?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    code?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    isActive?: BoolWithAggregatesFilter<"Subject"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
  }

  export type FacultySubjectWhereInput = {
    AND?: FacultySubjectWhereInput | FacultySubjectWhereInput[]
    OR?: FacultySubjectWhereInput[]
    NOT?: FacultySubjectWhereInput | FacultySubjectWhereInput[]
    id?: StringFilter<"FacultySubject"> | string
    facultyId?: StringFilter<"FacultySubject"> | string
    subjectId?: StringFilter<"FacultySubject"> | string
    createdAt?: DateTimeFilter<"FacultySubject"> | Date | string
    faculty?: XOR<FacultyProfileScalarRelationFilter, FacultyProfileWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }

  export type FacultySubjectOrderByWithRelationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    faculty?: FacultyProfileOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type FacultySubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    facultyId_subjectId?: FacultySubjectFacultyIdSubjectIdCompoundUniqueInput
    AND?: FacultySubjectWhereInput | FacultySubjectWhereInput[]
    OR?: FacultySubjectWhereInput[]
    NOT?: FacultySubjectWhereInput | FacultySubjectWhereInput[]
    facultyId?: StringFilter<"FacultySubject"> | string
    subjectId?: StringFilter<"FacultySubject"> | string
    createdAt?: DateTimeFilter<"FacultySubject"> | Date | string
    faculty?: XOR<FacultyProfileScalarRelationFilter, FacultyProfileWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }, "id" | "facultyId_subjectId">

  export type FacultySubjectOrderByWithAggregationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    _count?: FacultySubjectCountOrderByAggregateInput
    _max?: FacultySubjectMaxOrderByAggregateInput
    _min?: FacultySubjectMinOrderByAggregateInput
  }

  export type FacultySubjectScalarWhereWithAggregatesInput = {
    AND?: FacultySubjectScalarWhereWithAggregatesInput | FacultySubjectScalarWhereWithAggregatesInput[]
    OR?: FacultySubjectScalarWhereWithAggregatesInput[]
    NOT?: FacultySubjectScalarWhereWithAggregatesInput | FacultySubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FacultySubject"> | string
    facultyId?: StringWithAggregatesFilter<"FacultySubject"> | string
    subjectId?: StringWithAggregatesFilter<"FacultySubject"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FacultySubject"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    credits?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    offerings?: CourseOfferingListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offerings?: CourseOfferingOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    credits?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    offerings?: CourseOfferingListRelationFilter
  }, "id" | "code">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    code?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    credits?: IntWithAggregatesFilter<"Course"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type CourseOfferingWhereInput = {
    AND?: CourseOfferingWhereInput | CourseOfferingWhereInput[]
    OR?: CourseOfferingWhereInput[]
    NOT?: CourseOfferingWhereInput | CourseOfferingWhereInput[]
    id?: StringFilter<"CourseOffering"> | string
    courseId?: StringFilter<"CourseOffering"> | string
    facultyId?: StringFilter<"CourseOffering"> | string
    semester?: IntFilter<"CourseOffering"> | number
    academicYear?: StringNullableFilter<"CourseOffering"> | string | null
    term?: StringNullableFilter<"CourseOffering"> | string | null
    createdAt?: DateTimeFilter<"CourseOffering"> | Date | string
    updatedAt?: DateTimeFilter<"CourseOffering"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    faculty?: XOR<FacultyProfileScalarRelationFilter, FacultyProfileWhereInput>
    enrollments?: EnrollmentListRelationFilter
    sessions?: AttendanceSessionListRelationFilter
  }

  export type CourseOfferingOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    semester?: SortOrder
    academicYear?: SortOrderInput | SortOrder
    term?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    faculty?: FacultyProfileOrderByWithRelationInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    sessions?: AttendanceSessionOrderByRelationAggregateInput
  }

  export type CourseOfferingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseOfferingWhereInput | CourseOfferingWhereInput[]
    OR?: CourseOfferingWhereInput[]
    NOT?: CourseOfferingWhereInput | CourseOfferingWhereInput[]
    courseId?: StringFilter<"CourseOffering"> | string
    facultyId?: StringFilter<"CourseOffering"> | string
    semester?: IntFilter<"CourseOffering"> | number
    academicYear?: StringNullableFilter<"CourseOffering"> | string | null
    term?: StringNullableFilter<"CourseOffering"> | string | null
    createdAt?: DateTimeFilter<"CourseOffering"> | Date | string
    updatedAt?: DateTimeFilter<"CourseOffering"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    faculty?: XOR<FacultyProfileScalarRelationFilter, FacultyProfileWhereInput>
    enrollments?: EnrollmentListRelationFilter
    sessions?: AttendanceSessionListRelationFilter
  }, "id">

  export type CourseOfferingOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    semester?: SortOrder
    academicYear?: SortOrderInput | SortOrder
    term?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseOfferingCountOrderByAggregateInput
    _avg?: CourseOfferingAvgOrderByAggregateInput
    _max?: CourseOfferingMaxOrderByAggregateInput
    _min?: CourseOfferingMinOrderByAggregateInput
    _sum?: CourseOfferingSumOrderByAggregateInput
  }

  export type CourseOfferingScalarWhereWithAggregatesInput = {
    AND?: CourseOfferingScalarWhereWithAggregatesInput | CourseOfferingScalarWhereWithAggregatesInput[]
    OR?: CourseOfferingScalarWhereWithAggregatesInput[]
    NOT?: CourseOfferingScalarWhereWithAggregatesInput | CourseOfferingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseOffering"> | string
    courseId?: StringWithAggregatesFilter<"CourseOffering"> | string
    facultyId?: StringWithAggregatesFilter<"CourseOffering"> | string
    semester?: IntWithAggregatesFilter<"CourseOffering"> | number
    academicYear?: StringNullableWithAggregatesFilter<"CourseOffering"> | string | null
    term?: StringNullableWithAggregatesFilter<"CourseOffering"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CourseOffering"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourseOffering"> | Date | string
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    studentId?: StringFilter<"Enrollment"> | string
    offeringId?: StringFilter<"Enrollment"> | string
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    offering?: XOR<CourseOfferingScalarRelationFilter, CourseOfferingWhereInput>
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    offeringId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    offering?: CourseOfferingOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_offeringId?: EnrollmentStudentIdOfferingIdCompoundUniqueInput
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    studentId?: StringFilter<"Enrollment"> | string
    offeringId?: StringFilter<"Enrollment"> | string
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    offering?: XOR<CourseOfferingScalarRelationFilter, CourseOfferingWhereInput>
  }, "id" | "studentId_offeringId">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    offeringId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enrollment"> | string
    studentId?: StringWithAggregatesFilter<"Enrollment"> | string
    offeringId?: StringWithAggregatesFilter<"Enrollment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
  }

  export type AttendanceSessionWhereInput = {
    AND?: AttendanceSessionWhereInput | AttendanceSessionWhereInput[]
    OR?: AttendanceSessionWhereInput[]
    NOT?: AttendanceSessionWhereInput | AttendanceSessionWhereInput[]
    id?: StringFilter<"AttendanceSession"> | string
    offeringId?: StringFilter<"AttendanceSession"> | string
    sessionDate?: DateTimeFilter<"AttendanceSession"> | Date | string
    createdAt?: DateTimeFilter<"AttendanceSession"> | Date | string
    offering?: XOR<CourseOfferingScalarRelationFilter, CourseOfferingWhereInput>
    marks?: AttendanceMarkListRelationFilter
  }

  export type AttendanceSessionOrderByWithRelationInput = {
    id?: SortOrder
    offeringId?: SortOrder
    sessionDate?: SortOrder
    createdAt?: SortOrder
    offering?: CourseOfferingOrderByWithRelationInput
    marks?: AttendanceMarkOrderByRelationAggregateInput
  }

  export type AttendanceSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceSessionWhereInput | AttendanceSessionWhereInput[]
    OR?: AttendanceSessionWhereInput[]
    NOT?: AttendanceSessionWhereInput | AttendanceSessionWhereInput[]
    offeringId?: StringFilter<"AttendanceSession"> | string
    sessionDate?: DateTimeFilter<"AttendanceSession"> | Date | string
    createdAt?: DateTimeFilter<"AttendanceSession"> | Date | string
    offering?: XOR<CourseOfferingScalarRelationFilter, CourseOfferingWhereInput>
    marks?: AttendanceMarkListRelationFilter
  }, "id">

  export type AttendanceSessionOrderByWithAggregationInput = {
    id?: SortOrder
    offeringId?: SortOrder
    sessionDate?: SortOrder
    createdAt?: SortOrder
    _count?: AttendanceSessionCountOrderByAggregateInput
    _max?: AttendanceSessionMaxOrderByAggregateInput
    _min?: AttendanceSessionMinOrderByAggregateInput
  }

  export type AttendanceSessionScalarWhereWithAggregatesInput = {
    AND?: AttendanceSessionScalarWhereWithAggregatesInput | AttendanceSessionScalarWhereWithAggregatesInput[]
    OR?: AttendanceSessionScalarWhereWithAggregatesInput[]
    NOT?: AttendanceSessionScalarWhereWithAggregatesInput | AttendanceSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceSession"> | string
    offeringId?: StringWithAggregatesFilter<"AttendanceSession"> | string
    sessionDate?: DateTimeWithAggregatesFilter<"AttendanceSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceSession"> | Date | string
  }

  export type AttendanceMarkWhereInput = {
    AND?: AttendanceMarkWhereInput | AttendanceMarkWhereInput[]
    OR?: AttendanceMarkWhereInput[]
    NOT?: AttendanceMarkWhereInput | AttendanceMarkWhereInput[]
    id?: StringFilter<"AttendanceMark"> | string
    sessionId?: StringFilter<"AttendanceMark"> | string
    studentId?: StringFilter<"AttendanceMark"> | string
    status?: EnumAttendanceMarkStatusFilter<"AttendanceMark"> | $Enums.AttendanceMarkStatus
    note?: StringNullableFilter<"AttendanceMark"> | string | null
    createdAt?: DateTimeFilter<"AttendanceMark"> | Date | string
    session?: XOR<AttendanceSessionScalarRelationFilter, AttendanceSessionWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type AttendanceMarkOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: AttendanceSessionOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type AttendanceMarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_studentId?: AttendanceMarkSessionIdStudentIdCompoundUniqueInput
    AND?: AttendanceMarkWhereInput | AttendanceMarkWhereInput[]
    OR?: AttendanceMarkWhereInput[]
    NOT?: AttendanceMarkWhereInput | AttendanceMarkWhereInput[]
    sessionId?: StringFilter<"AttendanceMark"> | string
    studentId?: StringFilter<"AttendanceMark"> | string
    status?: EnumAttendanceMarkStatusFilter<"AttendanceMark"> | $Enums.AttendanceMarkStatus
    note?: StringNullableFilter<"AttendanceMark"> | string | null
    createdAt?: DateTimeFilter<"AttendanceMark"> | Date | string
    session?: XOR<AttendanceSessionScalarRelationFilter, AttendanceSessionWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "sessionId_studentId">

  export type AttendanceMarkOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceMarkCountOrderByAggregateInput
    _max?: AttendanceMarkMaxOrderByAggregateInput
    _min?: AttendanceMarkMinOrderByAggregateInput
  }

  export type AttendanceMarkScalarWhereWithAggregatesInput = {
    AND?: AttendanceMarkScalarWhereWithAggregatesInput | AttendanceMarkScalarWhereWithAggregatesInput[]
    OR?: AttendanceMarkScalarWhereWithAggregatesInput[]
    NOT?: AttendanceMarkScalarWhereWithAggregatesInput | AttendanceMarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceMark"> | string
    sessionId?: StringWithAggregatesFilter<"AttendanceMark"> | string
    studentId?: StringWithAggregatesFilter<"AttendanceMark"> | string
    status?: EnumAttendanceMarkStatusWithAggregatesFilter<"AttendanceMark"> | $Enums.AttendanceMarkStatus
    note?: StringNullableWithAggregatesFilter<"AttendanceMark"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceMark"> | Date | string
  }

  export type LibraryBookWhereInput = {
    AND?: LibraryBookWhereInput | LibraryBookWhereInput[]
    OR?: LibraryBookWhereInput[]
    NOT?: LibraryBookWhereInput | LibraryBookWhereInput[]
    id?: StringFilter<"LibraryBook"> | string
    title?: StringFilter<"LibraryBook"> | string
    author?: StringFilter<"LibraryBook"> | string
    isbn?: StringNullableFilter<"LibraryBook"> | string | null
    createdAt?: DateTimeFilter<"LibraryBook"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryBook"> | Date | string
    copies?: LibraryCopyListRelationFilter
  }

  export type LibraryBookOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    isbn?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    copies?: LibraryCopyOrderByRelationAggregateInput
  }

  export type LibraryBookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LibraryBookWhereInput | LibraryBookWhereInput[]
    OR?: LibraryBookWhereInput[]
    NOT?: LibraryBookWhereInput | LibraryBookWhereInput[]
    title?: StringFilter<"LibraryBook"> | string
    author?: StringFilter<"LibraryBook"> | string
    isbn?: StringNullableFilter<"LibraryBook"> | string | null
    createdAt?: DateTimeFilter<"LibraryBook"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryBook"> | Date | string
    copies?: LibraryCopyListRelationFilter
  }, "id">

  export type LibraryBookOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    isbn?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryBookCountOrderByAggregateInput
    _max?: LibraryBookMaxOrderByAggregateInput
    _min?: LibraryBookMinOrderByAggregateInput
  }

  export type LibraryBookScalarWhereWithAggregatesInput = {
    AND?: LibraryBookScalarWhereWithAggregatesInput | LibraryBookScalarWhereWithAggregatesInput[]
    OR?: LibraryBookScalarWhereWithAggregatesInput[]
    NOT?: LibraryBookScalarWhereWithAggregatesInput | LibraryBookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LibraryBook"> | string
    title?: StringWithAggregatesFilter<"LibraryBook"> | string
    author?: StringWithAggregatesFilter<"LibraryBook"> | string
    isbn?: StringNullableWithAggregatesFilter<"LibraryBook"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LibraryBook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LibraryBook"> | Date | string
  }

  export type LibraryCopyWhereInput = {
    AND?: LibraryCopyWhereInput | LibraryCopyWhereInput[]
    OR?: LibraryCopyWhereInput[]
    NOT?: LibraryCopyWhereInput | LibraryCopyWhereInput[]
    id?: StringFilter<"LibraryCopy"> | string
    bookId?: StringFilter<"LibraryCopy"> | string
    barcode?: StringFilter<"LibraryCopy"> | string
    status?: EnumLibraryCopyStatusFilter<"LibraryCopy"> | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFilter<"LibraryCopy"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryCopy"> | Date | string
    book?: XOR<LibraryBookScalarRelationFilter, LibraryBookWhereInput>
    issues?: LibraryIssueListRelationFilter
  }

  export type LibraryCopyOrderByWithRelationInput = {
    id?: SortOrder
    bookId?: SortOrder
    barcode?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    book?: LibraryBookOrderByWithRelationInput
    issues?: LibraryIssueOrderByRelationAggregateInput
  }

  export type LibraryCopyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barcode?: string
    AND?: LibraryCopyWhereInput | LibraryCopyWhereInput[]
    OR?: LibraryCopyWhereInput[]
    NOT?: LibraryCopyWhereInput | LibraryCopyWhereInput[]
    bookId?: StringFilter<"LibraryCopy"> | string
    status?: EnumLibraryCopyStatusFilter<"LibraryCopy"> | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFilter<"LibraryCopy"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryCopy"> | Date | string
    book?: XOR<LibraryBookScalarRelationFilter, LibraryBookWhereInput>
    issues?: LibraryIssueListRelationFilter
  }, "id" | "barcode">

  export type LibraryCopyOrderByWithAggregationInput = {
    id?: SortOrder
    bookId?: SortOrder
    barcode?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryCopyCountOrderByAggregateInput
    _max?: LibraryCopyMaxOrderByAggregateInput
    _min?: LibraryCopyMinOrderByAggregateInput
  }

  export type LibraryCopyScalarWhereWithAggregatesInput = {
    AND?: LibraryCopyScalarWhereWithAggregatesInput | LibraryCopyScalarWhereWithAggregatesInput[]
    OR?: LibraryCopyScalarWhereWithAggregatesInput[]
    NOT?: LibraryCopyScalarWhereWithAggregatesInput | LibraryCopyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LibraryCopy"> | string
    bookId?: StringWithAggregatesFilter<"LibraryCopy"> | string
    barcode?: StringWithAggregatesFilter<"LibraryCopy"> | string
    status?: EnumLibraryCopyStatusWithAggregatesFilter<"LibraryCopy"> | $Enums.LibraryCopyStatus
    createdAt?: DateTimeWithAggregatesFilter<"LibraryCopy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LibraryCopy"> | Date | string
  }

  export type LibraryIssueWhereInput = {
    AND?: LibraryIssueWhereInput | LibraryIssueWhereInput[]
    OR?: LibraryIssueWhereInput[]
    NOT?: LibraryIssueWhereInput | LibraryIssueWhereInput[]
    id?: StringFilter<"LibraryIssue"> | string
    studentId?: StringFilter<"LibraryIssue"> | string
    copyId?: StringFilter<"LibraryIssue"> | string
    issueDate?: DateTimeFilter<"LibraryIssue"> | Date | string
    dueDate?: DateTimeFilter<"LibraryIssue"> | Date | string
    returnDate?: DateTimeNullableFilter<"LibraryIssue"> | Date | string | null
    status?: EnumLibraryIssueStatusFilter<"LibraryIssue"> | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFilter<"LibraryIssue"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryIssue"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    copy?: XOR<LibraryCopyScalarRelationFilter, LibraryCopyWhereInput>
  }

  export type LibraryIssueOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    copyId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    copy?: LibraryCopyOrderByWithRelationInput
  }

  export type LibraryIssueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LibraryIssueWhereInput | LibraryIssueWhereInput[]
    OR?: LibraryIssueWhereInput[]
    NOT?: LibraryIssueWhereInput | LibraryIssueWhereInput[]
    studentId?: StringFilter<"LibraryIssue"> | string
    copyId?: StringFilter<"LibraryIssue"> | string
    issueDate?: DateTimeFilter<"LibraryIssue"> | Date | string
    dueDate?: DateTimeFilter<"LibraryIssue"> | Date | string
    returnDate?: DateTimeNullableFilter<"LibraryIssue"> | Date | string | null
    status?: EnumLibraryIssueStatusFilter<"LibraryIssue"> | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFilter<"LibraryIssue"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryIssue"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    copy?: XOR<LibraryCopyScalarRelationFilter, LibraryCopyWhereInput>
  }, "id">

  export type LibraryIssueOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    copyId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryIssueCountOrderByAggregateInput
    _max?: LibraryIssueMaxOrderByAggregateInput
    _min?: LibraryIssueMinOrderByAggregateInput
  }

  export type LibraryIssueScalarWhereWithAggregatesInput = {
    AND?: LibraryIssueScalarWhereWithAggregatesInput | LibraryIssueScalarWhereWithAggregatesInput[]
    OR?: LibraryIssueScalarWhereWithAggregatesInput[]
    NOT?: LibraryIssueScalarWhereWithAggregatesInput | LibraryIssueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LibraryIssue"> | string
    studentId?: StringWithAggregatesFilter<"LibraryIssue"> | string
    copyId?: StringWithAggregatesFilter<"LibraryIssue"> | string
    issueDate?: DateTimeWithAggregatesFilter<"LibraryIssue"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"LibraryIssue"> | Date | string
    returnDate?: DateTimeNullableWithAggregatesFilter<"LibraryIssue"> | Date | string | null
    status?: EnumLibraryIssueStatusWithAggregatesFilter<"LibraryIssue"> | $Enums.LibraryIssueStatus
    createdAt?: DateTimeWithAggregatesFilter<"LibraryIssue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LibraryIssue"> | Date | string
  }

  export type RequestWhereInput = {
    AND?: RequestWhereInput | RequestWhereInput[]
    OR?: RequestWhereInput[]
    NOT?: RequestWhereInput | RequestWhereInput[]
    id?: StringFilter<"Request"> | string
    displayId?: StringFilter<"Request"> | string
    studentId?: StringFilter<"Request"> | string
    title?: StringFilter<"Request"> | string
    description?: StringNullableFilter<"Request"> | string | null
    status?: EnumRequestStatusFilter<"Request"> | $Enums.RequestStatus
    submittedAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type RequestOrderByWithRelationInput = {
    id?: SortOrder
    displayId?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type RequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    displayId?: string
    AND?: RequestWhereInput | RequestWhereInput[]
    OR?: RequestWhereInput[]
    NOT?: RequestWhereInput | RequestWhereInput[]
    studentId?: StringFilter<"Request"> | string
    title?: StringFilter<"Request"> | string
    description?: StringNullableFilter<"Request"> | string | null
    status?: EnumRequestStatusFilter<"Request"> | $Enums.RequestStatus
    submittedAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "displayId">

  export type RequestOrderByWithAggregationInput = {
    id?: SortOrder
    displayId?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequestCountOrderByAggregateInput
    _max?: RequestMaxOrderByAggregateInput
    _min?: RequestMinOrderByAggregateInput
  }

  export type RequestScalarWhereWithAggregatesInput = {
    AND?: RequestScalarWhereWithAggregatesInput | RequestScalarWhereWithAggregatesInput[]
    OR?: RequestScalarWhereWithAggregatesInput[]
    NOT?: RequestScalarWhereWithAggregatesInput | RequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Request"> | string
    displayId?: StringWithAggregatesFilter<"Request"> | string
    studentId?: StringWithAggregatesFilter<"Request"> | string
    title?: StringWithAggregatesFilter<"Request"> | string
    description?: StringNullableWithAggregatesFilter<"Request"> | string | null
    status?: EnumRequestStatusWithAggregatesFilter<"Request"> | $Enums.RequestStatus
    submittedAt?: DateTimeWithAggregatesFilter<"Request"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Request"> | Date | string
  }

  export type StudentSettingWhereInput = {
    AND?: StudentSettingWhereInput | StudentSettingWhereInput[]
    OR?: StudentSettingWhereInput[]
    NOT?: StudentSettingWhereInput | StudentSettingWhereInput[]
    id?: StringFilter<"StudentSetting"> | string
    studentId?: StringFilter<"StudentSetting"> | string
    theme?: EnumThemeFilter<"StudentSetting"> | $Enums.Theme
    notificationsEnabled?: BoolFilter<"StudentSetting"> | boolean
    language?: StringFilter<"StudentSetting"> | string
    profileVisibility?: EnumProfileVisibilityFilter<"StudentSetting"> | $Enums.ProfileVisibility
    createdAt?: DateTimeFilter<"StudentSetting"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSetting"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type StudentSettingOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    theme?: SortOrder
    notificationsEnabled?: SortOrder
    language?: SortOrder
    profileVisibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type StudentSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    AND?: StudentSettingWhereInput | StudentSettingWhereInput[]
    OR?: StudentSettingWhereInput[]
    NOT?: StudentSettingWhereInput | StudentSettingWhereInput[]
    theme?: EnumThemeFilter<"StudentSetting"> | $Enums.Theme
    notificationsEnabled?: BoolFilter<"StudentSetting"> | boolean
    language?: StringFilter<"StudentSetting"> | string
    profileVisibility?: EnumProfileVisibilityFilter<"StudentSetting"> | $Enums.ProfileVisibility
    createdAt?: DateTimeFilter<"StudentSetting"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSetting"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "studentId">

  export type StudentSettingOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    theme?: SortOrder
    notificationsEnabled?: SortOrder
    language?: SortOrder
    profileVisibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentSettingCountOrderByAggregateInput
    _max?: StudentSettingMaxOrderByAggregateInput
    _min?: StudentSettingMinOrderByAggregateInput
  }

  export type StudentSettingScalarWhereWithAggregatesInput = {
    AND?: StudentSettingScalarWhereWithAggregatesInput | StudentSettingScalarWhereWithAggregatesInput[]
    OR?: StudentSettingScalarWhereWithAggregatesInput[]
    NOT?: StudentSettingScalarWhereWithAggregatesInput | StudentSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSetting"> | string
    studentId?: StringWithAggregatesFilter<"StudentSetting"> | string
    theme?: EnumThemeWithAggregatesFilter<"StudentSetting"> | $Enums.Theme
    notificationsEnabled?: BoolWithAggregatesFilter<"StudentSetting"> | boolean
    language?: StringWithAggregatesFilter<"StudentSetting"> | string
    profileVisibility?: EnumProfileVisibilityWithAggregatesFilter<"StudentSetting"> | $Enums.ProfileVisibility
    createdAt?: DateTimeWithAggregatesFilter<"StudentSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSetting"> | Date | string
  }

  export type FeeAccountWhereInput = {
    AND?: FeeAccountWhereInput | FeeAccountWhereInput[]
    OR?: FeeAccountWhereInput[]
    NOT?: FeeAccountWhereInput | FeeAccountWhereInput[]
    id?: StringFilter<"FeeAccount"> | string
    studentId?: StringFilter<"FeeAccount"> | string
    currency?: StringFilter<"FeeAccount"> | string
    createdAt?: DateTimeFilter<"FeeAccount"> | Date | string
    updatedAt?: DateTimeFilter<"FeeAccount"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    charges?: FeeChargeListRelationFilter
    payments?: FeePaymentListRelationFilter
  }

  export type FeeAccountOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    charges?: FeeChargeOrderByRelationAggregateInput
    payments?: FeePaymentOrderByRelationAggregateInput
  }

  export type FeeAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    AND?: FeeAccountWhereInput | FeeAccountWhereInput[]
    OR?: FeeAccountWhereInput[]
    NOT?: FeeAccountWhereInput | FeeAccountWhereInput[]
    currency?: StringFilter<"FeeAccount"> | string
    createdAt?: DateTimeFilter<"FeeAccount"> | Date | string
    updatedAt?: DateTimeFilter<"FeeAccount"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    charges?: FeeChargeListRelationFilter
    payments?: FeePaymentListRelationFilter
  }, "id" | "studentId">

  export type FeeAccountOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeeAccountCountOrderByAggregateInput
    _max?: FeeAccountMaxOrderByAggregateInput
    _min?: FeeAccountMinOrderByAggregateInput
  }

  export type FeeAccountScalarWhereWithAggregatesInput = {
    AND?: FeeAccountScalarWhereWithAggregatesInput | FeeAccountScalarWhereWithAggregatesInput[]
    OR?: FeeAccountScalarWhereWithAggregatesInput[]
    NOT?: FeeAccountScalarWhereWithAggregatesInput | FeeAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeAccount"> | string
    studentId?: StringWithAggregatesFilter<"FeeAccount"> | string
    currency?: StringWithAggregatesFilter<"FeeAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeeAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeeAccount"> | Date | string
  }

  export type FeeChargeWhereInput = {
    AND?: FeeChargeWhereInput | FeeChargeWhereInput[]
    OR?: FeeChargeWhereInput[]
    NOT?: FeeChargeWhereInput | FeeChargeWhereInput[]
    id?: StringFilter<"FeeCharge"> | string
    feeAccountId?: StringFilter<"FeeCharge"> | string
    title?: StringFilter<"FeeCharge"> | string
    amount?: IntFilter<"FeeCharge"> | number
    dueDate?: DateTimeNullableFilter<"FeeCharge"> | Date | string | null
    status?: StringFilter<"FeeCharge"> | string
    createdAt?: DateTimeFilter<"FeeCharge"> | Date | string
    feeAccount?: XOR<FeeAccountScalarRelationFilter, FeeAccountWhereInput>
  }

  export type FeeChargeOrderByWithRelationInput = {
    id?: SortOrder
    feeAccountId?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    feeAccount?: FeeAccountOrderByWithRelationInput
  }

  export type FeeChargeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeChargeWhereInput | FeeChargeWhereInput[]
    OR?: FeeChargeWhereInput[]
    NOT?: FeeChargeWhereInput | FeeChargeWhereInput[]
    feeAccountId?: StringFilter<"FeeCharge"> | string
    title?: StringFilter<"FeeCharge"> | string
    amount?: IntFilter<"FeeCharge"> | number
    dueDate?: DateTimeNullableFilter<"FeeCharge"> | Date | string | null
    status?: StringFilter<"FeeCharge"> | string
    createdAt?: DateTimeFilter<"FeeCharge"> | Date | string
    feeAccount?: XOR<FeeAccountScalarRelationFilter, FeeAccountWhereInput>
  }, "id">

  export type FeeChargeOrderByWithAggregationInput = {
    id?: SortOrder
    feeAccountId?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: FeeChargeCountOrderByAggregateInput
    _avg?: FeeChargeAvgOrderByAggregateInput
    _max?: FeeChargeMaxOrderByAggregateInput
    _min?: FeeChargeMinOrderByAggregateInput
    _sum?: FeeChargeSumOrderByAggregateInput
  }

  export type FeeChargeScalarWhereWithAggregatesInput = {
    AND?: FeeChargeScalarWhereWithAggregatesInput | FeeChargeScalarWhereWithAggregatesInput[]
    OR?: FeeChargeScalarWhereWithAggregatesInput[]
    NOT?: FeeChargeScalarWhereWithAggregatesInput | FeeChargeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeCharge"> | string
    feeAccountId?: StringWithAggregatesFilter<"FeeCharge"> | string
    title?: StringWithAggregatesFilter<"FeeCharge"> | string
    amount?: IntWithAggregatesFilter<"FeeCharge"> | number
    dueDate?: DateTimeNullableWithAggregatesFilter<"FeeCharge"> | Date | string | null
    status?: StringWithAggregatesFilter<"FeeCharge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeeCharge"> | Date | string
  }

  export type FeePaymentWhereInput = {
    AND?: FeePaymentWhereInput | FeePaymentWhereInput[]
    OR?: FeePaymentWhereInput[]
    NOT?: FeePaymentWhereInput | FeePaymentWhereInput[]
    id?: StringFilter<"FeePayment"> | string
    feeAccountId?: StringFilter<"FeePayment"> | string
    amount?: IntFilter<"FeePayment"> | number
    paidAt?: DateTimeFilter<"FeePayment"> | Date | string
    method?: StringNullableFilter<"FeePayment"> | string | null
    reference?: StringNullableFilter<"FeePayment"> | string | null
    createdAt?: DateTimeFilter<"FeePayment"> | Date | string
    feeAccount?: XOR<FeeAccountScalarRelationFilter, FeeAccountWhereInput>
  }

  export type FeePaymentOrderByWithRelationInput = {
    id?: SortOrder
    feeAccountId?: SortOrder
    amount?: SortOrder
    paidAt?: SortOrder
    method?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    feeAccount?: FeeAccountOrderByWithRelationInput
  }

  export type FeePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeePaymentWhereInput | FeePaymentWhereInput[]
    OR?: FeePaymentWhereInput[]
    NOT?: FeePaymentWhereInput | FeePaymentWhereInput[]
    feeAccountId?: StringFilter<"FeePayment"> | string
    amount?: IntFilter<"FeePayment"> | number
    paidAt?: DateTimeFilter<"FeePayment"> | Date | string
    method?: StringNullableFilter<"FeePayment"> | string | null
    reference?: StringNullableFilter<"FeePayment"> | string | null
    createdAt?: DateTimeFilter<"FeePayment"> | Date | string
    feeAccount?: XOR<FeeAccountScalarRelationFilter, FeeAccountWhereInput>
  }, "id">

  export type FeePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    feeAccountId?: SortOrder
    amount?: SortOrder
    paidAt?: SortOrder
    method?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FeePaymentCountOrderByAggregateInput
    _avg?: FeePaymentAvgOrderByAggregateInput
    _max?: FeePaymentMaxOrderByAggregateInput
    _min?: FeePaymentMinOrderByAggregateInput
    _sum?: FeePaymentSumOrderByAggregateInput
  }

  export type FeePaymentScalarWhereWithAggregatesInput = {
    AND?: FeePaymentScalarWhereWithAggregatesInput | FeePaymentScalarWhereWithAggregatesInput[]
    OR?: FeePaymentScalarWhereWithAggregatesInput[]
    NOT?: FeePaymentScalarWhereWithAggregatesInput | FeePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeePayment"> | string
    feeAccountId?: StringWithAggregatesFilter<"FeePayment"> | string
    amount?: IntWithAggregatesFilter<"FeePayment"> | number
    paidAt?: DateTimeWithAggregatesFilter<"FeePayment"> | Date | string
    method?: StringNullableWithAggregatesFilter<"FeePayment"> | string | null
    reference?: StringNullableWithAggregatesFilter<"FeePayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeePayment"> | Date | string
  }

  export type CounterWhereInput = {
    AND?: CounterWhereInput | CounterWhereInput[]
    OR?: CounterWhereInput[]
    NOT?: CounterWhereInput | CounterWhereInput[]
    key?: StringFilter<"Counter"> | string
    value?: IntFilter<"Counter"> | number
  }

  export type CounterOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type CounterWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: CounterWhereInput | CounterWhereInput[]
    OR?: CounterWhereInput[]
    NOT?: CounterWhereInput | CounterWhereInput[]
    value?: IntFilter<"Counter"> | number
  }, "key">

  export type CounterOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    _count?: CounterCountOrderByAggregateInput
    _avg?: CounterAvgOrderByAggregateInput
    _max?: CounterMaxOrderByAggregateInput
    _min?: CounterMinOrderByAggregateInput
    _sum?: CounterSumOrderByAggregateInput
  }

  export type CounterScalarWhereWithAggregatesInput = {
    AND?: CounterScalarWhereWithAggregatesInput | CounterScalarWhereWithAggregatesInput[]
    OR?: CounterScalarWhereWithAggregatesInput[]
    NOT?: CounterScalarWhereWithAggregatesInput | CounterScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"Counter"> | string
    value?: IntWithAggregatesFilter<"Counter"> | number
  }

  export type UserCreateInput = {
    id?: string
    role: $Enums.UserRole
    email?: string | null
    phone?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    faculty?: FacultyProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    role: $Enums.UserRole
    email?: string | null
    phone?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    faculty?: FacultyProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    faculty?: FacultyProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    faculty?: FacultyProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    role: $Enums.UserRole
    email?: string | null
    phone?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueCreateNestedManyWithoutStudentInput
    requests?: RequestCreateNestedManyWithoutStudentInput
    settings?: StudentSettingCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    displayId: string
    fullName: string
    programId: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkUncheckedCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueUncheckedCreateNestedManyWithoutStudentInput
    requests?: RequestUncheckedCreateNestedManyWithoutStudentInput
    settings?: StudentSettingUncheckedCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUpdateManyWithoutStudentNestedInput
    requests?: RequestUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUncheckedUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUncheckedUpdateManyWithoutStudentNestedInput
    requests?: RequestUncheckedUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUncheckedUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    displayId: string
    fullName: string
    programId: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyProfileCreateInput = {
    id?: string
    fullName?: string | null
    employeeCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFacultyInput
    department?: DepartmentCreateNestedOneWithoutFacultyInput
    designation?: DesignationCreateNestedOneWithoutFacultyInput
    offerings?: CourseOfferingCreateNestedManyWithoutFacultyInput
    subjects?: FacultySubjectCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileUncheckedCreateInput = {
    id?: string
    userId: string
    fullName?: string | null
    employeeCode?: string | null
    departmentId?: string | null
    designationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: CourseOfferingUncheckedCreateNestedManyWithoutFacultyInput
    subjects?: FacultySubjectUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFacultyNestedInput
    department?: DepartmentUpdateOneWithoutFacultyNestedInput
    designation?: DesignationUpdateOneWithoutFacultyNestedInput
    offerings?: CourseOfferingUpdateManyWithoutFacultyNestedInput
    subjects?: FacultySubjectUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: CourseOfferingUncheckedUpdateManyWithoutFacultyNestedInput
    subjects?: FacultySubjectUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyProfileCreateManyInput = {
    id?: string
    userId: string
    fullName?: string | null
    employeeCode?: string | null
    departmentId?: string | null
    designationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacultyProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    designations?: DesignationCreateNestedManyWithoutDepartmentInput
    subjects?: SubjectCreateNestedManyWithoutDepartmentInput
    faculty?: FacultyProfileCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    designations?: DesignationUncheckedCreateNestedManyWithoutDepartmentInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutDepartmentInput
    faculty?: FacultyProfileUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designations?: DesignationUpdateManyWithoutDepartmentNestedInput
    subjects?: SubjectUpdateManyWithoutDepartmentNestedInput
    faculty?: FacultyProfileUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designations?: DesignationUncheckedUpdateManyWithoutDepartmentNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutDepartmentNestedInput
    faculty?: FacultyProfileUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignationCreateInput = {
    id?: string
    title: string
    level?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutDesignationsInput
    faculty?: FacultyProfileCreateNestedManyWithoutDesignationInput
  }

  export type DesignationUncheckedCreateInput = {
    id?: string
    departmentId: string
    title: string
    level?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty?: FacultyProfileUncheckedCreateNestedManyWithoutDesignationInput
  }

  export type DesignationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutDesignationsNestedInput
    faculty?: FacultyProfileUpdateManyWithoutDesignationNestedInput
  }

  export type DesignationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyProfileUncheckedUpdateManyWithoutDesignationNestedInput
  }

  export type DesignationCreateManyInput = {
    id?: string
    departmentId: string
    title: string
    level?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutSubjectsInput
    faculty?: FacultySubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    departmentId: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty?: FacultySubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutSubjectsNestedInput
    faculty?: FacultySubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultySubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    departmentId: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultySubjectCreateInput = {
    id?: string
    createdAt?: Date | string
    faculty: FacultyProfileCreateNestedOneWithoutSubjectsInput
    subject: SubjectCreateNestedOneWithoutFacultyInput
  }

  export type FacultySubjectUncheckedCreateInput = {
    id?: string
    facultyId: string
    subjectId: string
    createdAt?: Date | string
  }

  export type FacultySubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyProfileUpdateOneRequiredWithoutSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutFacultyNestedInput
  }

  export type FacultySubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultySubjectCreateManyInput = {
    id?: string
    facultyId: string
    subjectId: string
    createdAt?: Date | string
  }

  export type FacultySubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultySubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    code: string
    title: string
    credits: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: CourseOfferingCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    code: string
    title: string
    credits: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: CourseOfferingUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: CourseOfferingUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: CourseOfferingUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    code: string
    title: string
    credits: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseOfferingCreateInput = {
    id?: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutOfferingsInput
    faculty: FacultyProfileCreateNestedOneWithoutOfferingsInput
    enrollments?: EnrollmentCreateNestedManyWithoutOfferingInput
    sessions?: AttendanceSessionCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingUncheckedCreateInput = {
    id?: string
    courseId: string
    facultyId: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutOfferingInput
    sessions?: AttendanceSessionUncheckedCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutOfferingsNestedInput
    faculty?: FacultyProfileUpdateOneRequiredWithoutOfferingsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutOfferingNestedInput
    sessions?: AttendanceSessionUpdateManyWithoutOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
    sessions?: AttendanceSessionUncheckedUpdateManyWithoutOfferingNestedInput
  }

  export type CourseOfferingCreateManyInput = {
    id?: string
    courseId: string
    facultyId: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseOfferingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseOfferingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    offering: CourseOfferingCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: string
    studentId: string
    offeringId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    offering?: CourseOfferingUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeringId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateManyInput = {
    id?: string
    studentId: string
    offeringId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeringId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSessionCreateInput = {
    id?: string
    sessionDate: Date | string
    createdAt?: Date | string
    offering: CourseOfferingCreateNestedOneWithoutSessionsInput
    marks?: AttendanceMarkCreateNestedManyWithoutSessionInput
  }

  export type AttendanceSessionUncheckedCreateInput = {
    id?: string
    offeringId: string
    sessionDate: Date | string
    createdAt?: Date | string
    marks?: AttendanceMarkUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AttendanceSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offering?: CourseOfferingUpdateOneRequiredWithoutSessionsNestedInput
    marks?: AttendanceMarkUpdateManyWithoutSessionNestedInput
  }

  export type AttendanceSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marks?: AttendanceMarkUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AttendanceSessionCreateManyInput = {
    id?: string
    offeringId: string
    sessionDate: Date | string
    createdAt?: Date | string
  }

  export type AttendanceSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceMarkCreateInput = {
    id?: string
    status: $Enums.AttendanceMarkStatus
    note?: string | null
    createdAt?: Date | string
    session: AttendanceSessionCreateNestedOneWithoutMarksInput
    student: StudentCreateNestedOneWithoutAttendanceMarksInput
  }

  export type AttendanceMarkUncheckedCreateInput = {
    id?: string
    sessionId: string
    studentId: string
    status: $Enums.AttendanceMarkStatus
    note?: string | null
    createdAt?: Date | string
  }

  export type AttendanceMarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceMarkStatusFieldUpdateOperationsInput | $Enums.AttendanceMarkStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: AttendanceSessionUpdateOneRequiredWithoutMarksNestedInput
    student?: StudentUpdateOneRequiredWithoutAttendanceMarksNestedInput
  }

  export type AttendanceMarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceMarkStatusFieldUpdateOperationsInput | $Enums.AttendanceMarkStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceMarkCreateManyInput = {
    id?: string
    sessionId: string
    studentId: string
    status: $Enums.AttendanceMarkStatus
    note?: string | null
    createdAt?: Date | string
  }

  export type AttendanceMarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceMarkStatusFieldUpdateOperationsInput | $Enums.AttendanceMarkStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceMarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceMarkStatusFieldUpdateOperationsInput | $Enums.AttendanceMarkStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCreateInput = {
    id?: string
    title: string
    author: string
    isbn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    copies?: LibraryCopyCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateInput = {
    id?: string
    title: string
    author: string
    isbn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    copies?: LibraryCopyUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    copies?: LibraryCopyUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    copies?: LibraryCopyUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookCreateManyInput = {
    id?: string
    title: string
    author: string
    isbn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCopyCreateInput = {
    id?: string
    barcode: string
    status?: $Enums.LibraryCopyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    book: LibraryBookCreateNestedOneWithoutCopiesInput
    issues?: LibraryIssueCreateNestedManyWithoutCopyInput
  }

  export type LibraryCopyUncheckedCreateInput = {
    id?: string
    bookId: string
    barcode: string
    status?: $Enums.LibraryCopyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    issues?: LibraryIssueUncheckedCreateNestedManyWithoutCopyInput
  }

  export type LibraryCopyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    status?: EnumLibraryCopyStatusFieldUpdateOperationsInput | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: LibraryBookUpdateOneRequiredWithoutCopiesNestedInput
    issues?: LibraryIssueUpdateManyWithoutCopyNestedInput
  }

  export type LibraryCopyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    status?: EnumLibraryCopyStatusFieldUpdateOperationsInput | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issues?: LibraryIssueUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type LibraryCopyCreateManyInput = {
    id?: string
    bookId: string
    barcode: string
    status?: $Enums.LibraryCopyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCopyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    status?: EnumLibraryCopyStatusFieldUpdateOperationsInput | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCopyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    status?: EnumLibraryCopyStatusFieldUpdateOperationsInput | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryIssueCreateInput = {
    id?: string
    issueDate: Date | string
    dueDate: Date | string
    returnDate?: Date | string | null
    status?: $Enums.LibraryIssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutLibraryIssuesInput
    copy: LibraryCopyCreateNestedOneWithoutIssuesInput
  }

  export type LibraryIssueUncheckedCreateInput = {
    id?: string
    studentId: string
    copyId: string
    issueDate: Date | string
    dueDate: Date | string
    returnDate?: Date | string | null
    status?: $Enums.LibraryIssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryIssueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumLibraryIssueStatusFieldUpdateOperationsInput | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutLibraryIssuesNestedInput
    copy?: LibraryCopyUpdateOneRequiredWithoutIssuesNestedInput
  }

  export type LibraryIssueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    copyId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumLibraryIssueStatusFieldUpdateOperationsInput | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryIssueCreateManyInput = {
    id?: string
    studentId: string
    copyId: string
    issueDate: Date | string
    dueDate: Date | string
    returnDate?: Date | string | null
    status?: $Enums.LibraryIssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryIssueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumLibraryIssueStatusFieldUpdateOperationsInput | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryIssueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    copyId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumLibraryIssueStatusFieldUpdateOperationsInput | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCreateInput = {
    id?: string
    displayId: string
    title: string
    description?: string | null
    status?: $Enums.RequestStatus
    submittedAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutRequestsInput
  }

  export type RequestUncheckedCreateInput = {
    id?: string
    displayId: string
    studentId: string
    title: string
    description?: string | null
    status?: $Enums.RequestStatus
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutRequestsNestedInput
  }

  export type RequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCreateManyInput = {
    id?: string
    displayId: string
    studentId: string
    title: string
    description?: string | null
    status?: $Enums.RequestStatus
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSettingCreateInput = {
    id?: string
    theme?: $Enums.Theme
    notificationsEnabled?: boolean
    language?: string
    profileVisibility?: $Enums.ProfileVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutSettingsInput
  }

  export type StudentSettingUncheckedCreateInput = {
    id?: string
    studentId: string
    theme?: $Enums.Theme
    notificationsEnabled?: boolean
    language?: string
    profileVisibility?: $Enums.ProfileVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    profileVisibility?: EnumProfileVisibilityFieldUpdateOperationsInput | $Enums.ProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type StudentSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    profileVisibility?: EnumProfileVisibilityFieldUpdateOperationsInput | $Enums.ProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSettingCreateManyInput = {
    id?: string
    studentId: string
    theme?: $Enums.Theme
    notificationsEnabled?: boolean
    language?: string
    profileVisibility?: $Enums.ProfileVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    profileVisibility?: EnumProfileVisibilityFieldUpdateOperationsInput | $Enums.ProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    profileVisibility?: EnumProfileVisibilityFieldUpdateOperationsInput | $Enums.ProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeAccountCreateInput = {
    id?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFeeAccountInput
    charges?: FeeChargeCreateNestedManyWithoutFeeAccountInput
    payments?: FeePaymentCreateNestedManyWithoutFeeAccountInput
  }

  export type FeeAccountUncheckedCreateInput = {
    id?: string
    studentId: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    charges?: FeeChargeUncheckedCreateNestedManyWithoutFeeAccountInput
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeAccountInput
  }

  export type FeeAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeeAccountNestedInput
    charges?: FeeChargeUpdateManyWithoutFeeAccountNestedInput
    payments?: FeePaymentUpdateManyWithoutFeeAccountNestedInput
  }

  export type FeeAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    charges?: FeeChargeUncheckedUpdateManyWithoutFeeAccountNestedInput
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeAccountNestedInput
  }

  export type FeeAccountCreateManyInput = {
    id?: string
    studentId: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeChargeCreateInput = {
    id?: string
    title: string
    amount: number
    dueDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    feeAccount: FeeAccountCreateNestedOneWithoutChargesInput
  }

  export type FeeChargeUncheckedCreateInput = {
    id?: string
    feeAccountId: string
    title: string
    amount: number
    dueDate?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type FeeChargeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeAccount?: FeeAccountUpdateOneRequiredWithoutChargesNestedInput
  }

  export type FeeChargeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeAccountId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeChargeCreateManyInput = {
    id?: string
    feeAccountId: string
    title: string
    amount: number
    dueDate?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type FeeChargeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeChargeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeAccountId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentCreateInput = {
    id?: string
    amount: number
    paidAt?: Date | string
    method?: string | null
    reference?: string | null
    createdAt?: Date | string
    feeAccount: FeeAccountCreateNestedOneWithoutPaymentsInput
  }

  export type FeePaymentUncheckedCreateInput = {
    id?: string
    feeAccountId: string
    amount: number
    paidAt?: Date | string
    method?: string | null
    reference?: string | null
    createdAt?: Date | string
  }

  export type FeePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeAccount?: FeeAccountUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type FeePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeAccountId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentCreateManyInput = {
    id?: string
    feeAccountId: string
    amount: number
    paidAt?: Date | string
    method?: string | null
    reference?: string | null
    createdAt?: Date | string
  }

  export type FeePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeAccountId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterCreateInput = {
    key: string
    value: number
  }

  export type CounterUncheckedCreateInput = {
    key: string
    value: number
  }

  export type CounterUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type CounterUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type CounterCreateManyInput = {
    key: string
    value: number
  }

  export type CounterUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type CounterUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type FacultyProfileNullableScalarRelationFilter = {
    is?: FacultyProfileWhereInput | null
    isNot?: FacultyProfileWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProgramScalarRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type AttendanceMarkListRelationFilter = {
    every?: AttendanceMarkWhereInput
    some?: AttendanceMarkWhereInput
    none?: AttendanceMarkWhereInput
  }

  export type LibraryIssueListRelationFilter = {
    every?: LibraryIssueWhereInput
    some?: LibraryIssueWhereInput
    none?: LibraryIssueWhereInput
  }

  export type RequestListRelationFilter = {
    every?: RequestWhereInput
    some?: RequestWhereInput
    none?: RequestWhereInput
  }

  export type StudentSettingNullableScalarRelationFilter = {
    is?: StudentSettingWhereInput | null
    isNot?: StudentSettingWhereInput | null
  }

  export type FeeAccountNullableScalarRelationFilter = {
    is?: FeeAccountWhereInput | null
    isNot?: FeeAccountWhereInput | null
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceMarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryIssueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayId?: SortOrder
    fullName?: SortOrder
    programId?: SortOrder
    semester?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    semester?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayId?: SortOrder
    fullName?: SortOrder
    programId?: SortOrder
    semester?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayId?: SortOrder
    fullName?: SortOrder
    programId?: SortOrder
    semester?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    semester?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type DesignationNullableScalarRelationFilter = {
    is?: DesignationWhereInput | null
    isNot?: DesignationWhereInput | null
  }

  export type CourseOfferingListRelationFilter = {
    every?: CourseOfferingWhereInput
    some?: CourseOfferingWhereInput
    none?: CourseOfferingWhereInput
  }

  export type FacultySubjectListRelationFilter = {
    every?: FacultySubjectWhereInput
    some?: FacultySubjectWhereInput
    none?: FacultySubjectWhereInput
  }

  export type CourseOfferingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultySubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    employeeCode?: SortOrder
    departmentId?: SortOrder
    designationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacultyProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    employeeCode?: SortOrder
    departmentId?: SortOrder
    designationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacultyProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    employeeCode?: SortOrder
    departmentId?: SortOrder
    designationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DesignationListRelationFilter = {
    every?: DesignationWhereInput
    some?: DesignationWhereInput
    none?: DesignationWhereInput
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type FacultyProfileListRelationFilter = {
    every?: FacultyProfileWhereInput
    some?: FacultyProfileWhereInput
    none?: FacultyProfileWhereInput
  }

  export type DesignationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DepartmentScalarRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type DesignationDepartmentIdTitleCompoundUniqueInput = {
    departmentId: string
    title: string
  }

  export type DesignationCountOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    title?: SortOrder
    level?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignationAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type DesignationMaxOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    title?: SortOrder
    level?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignationMinOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    title?: SortOrder
    level?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DesignationSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SubjectDepartmentIdNameCompoundUniqueInput = {
    departmentId: string
    name: string
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacultyProfileScalarRelationFilter = {
    is?: FacultyProfileWhereInput
    isNot?: FacultyProfileWhereInput
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type FacultySubjectFacultyIdSubjectIdCompoundUniqueInput = {
    facultyId: string
    subjectId: string
  }

  export type FacultySubjectCountOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
  }

  export type FacultySubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
  }

  export type FacultySubjectMinOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type AttendanceSessionListRelationFilter = {
    every?: AttendanceSessionWhereInput
    some?: AttendanceSessionWhereInput
    none?: AttendanceSessionWhereInput
  }

  export type AttendanceSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOfferingCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    semester?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseOfferingAvgOrderByAggregateInput = {
    semester?: SortOrder
  }

  export type CourseOfferingMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    semester?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseOfferingMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    semester?: SortOrder
    academicYear?: SortOrder
    term?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseOfferingSumOrderByAggregateInput = {
    semester?: SortOrder
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type CourseOfferingScalarRelationFilter = {
    is?: CourseOfferingWhereInput
    isNot?: CourseOfferingWhereInput
  }

  export type EnrollmentStudentIdOfferingIdCompoundUniqueInput = {
    studentId: string
    offeringId: string
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    offeringId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    offeringId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    offeringId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceSessionCountOrderByAggregateInput = {
    id?: SortOrder
    offeringId?: SortOrder
    sessionDate?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    offeringId?: SortOrder
    sessionDate?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceSessionMinOrderByAggregateInput = {
    id?: SortOrder
    offeringId?: SortOrder
    sessionDate?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAttendanceMarkStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceMarkStatus | EnumAttendanceMarkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceMarkStatus[]
    notIn?: $Enums.AttendanceMarkStatus[]
    not?: NestedEnumAttendanceMarkStatusFilter<$PrismaModel> | $Enums.AttendanceMarkStatus
  }

  export type AttendanceSessionScalarRelationFilter = {
    is?: AttendanceSessionWhereInput
    isNot?: AttendanceSessionWhereInput
  }

  export type AttendanceMarkSessionIdStudentIdCompoundUniqueInput = {
    sessionId: string
    studentId: string
  }

  export type AttendanceMarkCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceMarkMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceMarkMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAttendanceMarkStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceMarkStatus | EnumAttendanceMarkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceMarkStatus[]
    notIn?: $Enums.AttendanceMarkStatus[]
    not?: NestedEnumAttendanceMarkStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceMarkStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceMarkStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceMarkStatusFilter<$PrismaModel>
  }

  export type LibraryCopyListRelationFilter = {
    every?: LibraryCopyWhereInput
    some?: LibraryCopyWhereInput
    none?: LibraryCopyWhereInput
  }

  export type LibraryCopyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryBookCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLibraryCopyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryCopyStatus | EnumLibraryCopyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryCopyStatus[]
    notIn?: $Enums.LibraryCopyStatus[]
    not?: NestedEnumLibraryCopyStatusFilter<$PrismaModel> | $Enums.LibraryCopyStatus
  }

  export type LibraryBookScalarRelationFilter = {
    is?: LibraryBookWhereInput
    isNot?: LibraryBookWhereInput
  }

  export type LibraryCopyCountOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    barcode?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryCopyMaxOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    barcode?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryCopyMinOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    barcode?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLibraryCopyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryCopyStatus | EnumLibraryCopyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryCopyStatus[]
    notIn?: $Enums.LibraryCopyStatus[]
    not?: NestedEnumLibraryCopyStatusWithAggregatesFilter<$PrismaModel> | $Enums.LibraryCopyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLibraryCopyStatusFilter<$PrismaModel>
    _max?: NestedEnumLibraryCopyStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumLibraryIssueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryIssueStatus | EnumLibraryIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryIssueStatus[]
    notIn?: $Enums.LibraryIssueStatus[]
    not?: NestedEnumLibraryIssueStatusFilter<$PrismaModel> | $Enums.LibraryIssueStatus
  }

  export type LibraryCopyScalarRelationFilter = {
    is?: LibraryCopyWhereInput
    isNot?: LibraryCopyWhereInput
  }

  export type LibraryIssueCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    copyId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryIssueMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    copyId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryIssueMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    copyId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumLibraryIssueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryIssueStatus | EnumLibraryIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryIssueStatus[]
    notIn?: $Enums.LibraryIssueStatus[]
    not?: NestedEnumLibraryIssueStatusWithAggregatesFilter<$PrismaModel> | $Enums.LibraryIssueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLibraryIssueStatusFilter<$PrismaModel>
    _max?: NestedEnumLibraryIssueStatusFilter<$PrismaModel>
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[]
    notIn?: $Enums.RequestStatus[]
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type RequestCountOrderByAggregateInput = {
    id?: SortOrder
    displayId?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestMaxOrderByAggregateInput = {
    id?: SortOrder
    displayId?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestMinOrderByAggregateInput = {
    id?: SortOrder
    displayId?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[]
    notIn?: $Enums.RequestStatus[]
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type EnumThemeFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[]
    notIn?: $Enums.Theme[]
    not?: NestedEnumThemeFilter<$PrismaModel> | $Enums.Theme
  }

  export type EnumProfileVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileVisibility | EnumProfileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileVisibility[]
    notIn?: $Enums.ProfileVisibility[]
    not?: NestedEnumProfileVisibilityFilter<$PrismaModel> | $Enums.ProfileVisibility
  }

  export type StudentSettingCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    theme?: SortOrder
    notificationsEnabled?: SortOrder
    language?: SortOrder
    profileVisibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    theme?: SortOrder
    notificationsEnabled?: SortOrder
    language?: SortOrder
    profileVisibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSettingMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    theme?: SortOrder
    notificationsEnabled?: SortOrder
    language?: SortOrder
    profileVisibility?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumThemeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[]
    notIn?: $Enums.Theme[]
    not?: NestedEnumThemeWithAggregatesFilter<$PrismaModel> | $Enums.Theme
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThemeFilter<$PrismaModel>
    _max?: NestedEnumThemeFilter<$PrismaModel>
  }

  export type EnumProfileVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileVisibility | EnumProfileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileVisibility[]
    notIn?: $Enums.ProfileVisibility[]
    not?: NestedEnumProfileVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ProfileVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProfileVisibilityFilter<$PrismaModel>
    _max?: NestedEnumProfileVisibilityFilter<$PrismaModel>
  }

  export type FeeChargeListRelationFilter = {
    every?: FeeChargeWhereInput
    some?: FeeChargeWhereInput
    none?: FeeChargeWhereInput
  }

  export type FeePaymentListRelationFilter = {
    every?: FeePaymentWhereInput
    some?: FeePaymentWhereInput
    none?: FeePaymentWhereInput
  }

  export type FeeChargeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeAccountCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeAccountMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeAccountScalarRelationFilter = {
    is?: FeeAccountWhereInput
    isNot?: FeeAccountWhereInput
  }

  export type FeeChargeCountOrderByAggregateInput = {
    id?: SortOrder
    feeAccountId?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeChargeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FeeChargeMaxOrderByAggregateInput = {
    id?: SortOrder
    feeAccountId?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeChargeMinOrderByAggregateInput = {
    id?: SortOrder
    feeAccountId?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeChargeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FeePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    feeAccountId?: SortOrder
    amount?: SortOrder
    paidAt?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type FeePaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FeePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    feeAccountId?: SortOrder
    amount?: SortOrder
    paidAt?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type FeePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    feeAccountId?: SortOrder
    amount?: SortOrder
    paidAt?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type FeePaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CounterCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type CounterAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type CounterMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type CounterMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type CounterSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type FacultyProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<FacultyProfileCreateWithoutUserInput, FacultyProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutUserInput
    connect?: FacultyProfileWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type FacultyProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<FacultyProfileCreateWithoutUserInput, FacultyProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutUserInput
    connect?: FacultyProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type FacultyProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<FacultyProfileCreateWithoutUserInput, FacultyProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutUserInput
    upsert?: FacultyProfileUpsertWithoutUserInput
    disconnect?: FacultyProfileWhereInput | boolean
    delete?: FacultyProfileWhereInput | boolean
    connect?: FacultyProfileWhereUniqueInput
    update?: XOR<XOR<FacultyProfileUpdateToOneWithWhereWithoutUserInput, FacultyProfileUpdateWithoutUserInput>, FacultyProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type FacultyProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<FacultyProfileCreateWithoutUserInput, FacultyProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutUserInput
    upsert?: FacultyProfileUpsertWithoutUserInput
    disconnect?: FacultyProfileWhereInput | boolean
    delete?: FacultyProfileWhereInput | boolean
    connect?: FacultyProfileWhereUniqueInput
    update?: XOR<XOR<FacultyProfileUpdateToOneWithWhereWithoutUserInput, FacultyProfileUpdateWithoutUserInput>, FacultyProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentCreateNestedManyWithoutProgramInput = {
    create?: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput> | StudentCreateWithoutProgramInput[] | StudentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutProgramInput | StudentCreateOrConnectWithoutProgramInput[]
    createMany?: StudentCreateManyProgramInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput> | StudentCreateWithoutProgramInput[] | StudentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutProgramInput | StudentCreateOrConnectWithoutProgramInput[]
    createMany?: StudentCreateManyProgramInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentUpdateManyWithoutProgramNestedInput = {
    create?: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput> | StudentCreateWithoutProgramInput[] | StudentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutProgramInput | StudentCreateOrConnectWithoutProgramInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutProgramInput | StudentUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: StudentCreateManyProgramInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutProgramInput | StudentUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutProgramInput | StudentUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput> | StudentCreateWithoutProgramInput[] | StudentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutProgramInput | StudentCreateOrConnectWithoutProgramInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutProgramInput | StudentUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: StudentCreateManyProgramInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutProgramInput | StudentUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutProgramInput | StudentUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ProgramCreateWithoutStudentsInput, ProgramUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutStudentsInput
    connect?: ProgramWhereUniqueInput
  }

  export type EnrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AttendanceMarkCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceMarkCreateWithoutStudentInput, AttendanceMarkUncheckedCreateWithoutStudentInput> | AttendanceMarkCreateWithoutStudentInput[] | AttendanceMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceMarkCreateOrConnectWithoutStudentInput | AttendanceMarkCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceMarkCreateManyStudentInputEnvelope
    connect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
  }

  export type LibraryIssueCreateNestedManyWithoutStudentInput = {
    create?: XOR<LibraryIssueCreateWithoutStudentInput, LibraryIssueUncheckedCreateWithoutStudentInput> | LibraryIssueCreateWithoutStudentInput[] | LibraryIssueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LibraryIssueCreateOrConnectWithoutStudentInput | LibraryIssueCreateOrConnectWithoutStudentInput[]
    createMany?: LibraryIssueCreateManyStudentInputEnvelope
    connect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
  }

  export type RequestCreateNestedManyWithoutStudentInput = {
    create?: XOR<RequestCreateWithoutStudentInput, RequestUncheckedCreateWithoutStudentInput> | RequestCreateWithoutStudentInput[] | RequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutStudentInput | RequestCreateOrConnectWithoutStudentInput[]
    createMany?: RequestCreateManyStudentInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type StudentSettingCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentSettingCreateWithoutStudentInput, StudentSettingUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSettingCreateOrConnectWithoutStudentInput
    connect?: StudentSettingWhereUniqueInput
  }

  export type FeeAccountCreateNestedOneWithoutStudentInput = {
    create?: XOR<FeeAccountCreateWithoutStudentInput, FeeAccountUncheckedCreateWithoutStudentInput>
    connectOrCreate?: FeeAccountCreateOrConnectWithoutStudentInput
    connect?: FeeAccountWhereUniqueInput
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AttendanceMarkUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceMarkCreateWithoutStudentInput, AttendanceMarkUncheckedCreateWithoutStudentInput> | AttendanceMarkCreateWithoutStudentInput[] | AttendanceMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceMarkCreateOrConnectWithoutStudentInput | AttendanceMarkCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceMarkCreateManyStudentInputEnvelope
    connect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
  }

  export type LibraryIssueUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<LibraryIssueCreateWithoutStudentInput, LibraryIssueUncheckedCreateWithoutStudentInput> | LibraryIssueCreateWithoutStudentInput[] | LibraryIssueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LibraryIssueCreateOrConnectWithoutStudentInput | LibraryIssueCreateOrConnectWithoutStudentInput[]
    createMany?: LibraryIssueCreateManyStudentInputEnvelope
    connect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
  }

  export type RequestUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<RequestCreateWithoutStudentInput, RequestUncheckedCreateWithoutStudentInput> | RequestCreateWithoutStudentInput[] | RequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutStudentInput | RequestCreateOrConnectWithoutStudentInput[]
    createMany?: RequestCreateManyStudentInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type StudentSettingUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<StudentSettingCreateWithoutStudentInput, StudentSettingUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSettingCreateOrConnectWithoutStudentInput
    connect?: StudentSettingWhereUniqueInput
  }

  export type FeeAccountUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<FeeAccountCreateWithoutStudentInput, FeeAccountUncheckedCreateWithoutStudentInput>
    connectOrCreate?: FeeAccountCreateOrConnectWithoutStudentInput
    connect?: FeeAccountWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type ProgramUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<ProgramCreateWithoutStudentsInput, ProgramUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutStudentsInput
    upsert?: ProgramUpsertWithoutStudentsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutStudentsInput, ProgramUpdateWithoutStudentsInput>, ProgramUncheckedUpdateWithoutStudentsInput>
  }

  export type EnrollmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutStudentInput | EnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutStudentInput | EnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutStudentInput | EnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AttendanceMarkUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceMarkCreateWithoutStudentInput, AttendanceMarkUncheckedCreateWithoutStudentInput> | AttendanceMarkCreateWithoutStudentInput[] | AttendanceMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceMarkCreateOrConnectWithoutStudentInput | AttendanceMarkCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceMarkUpsertWithWhereUniqueWithoutStudentInput | AttendanceMarkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceMarkCreateManyStudentInputEnvelope
    set?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    disconnect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    delete?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    connect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    update?: AttendanceMarkUpdateWithWhereUniqueWithoutStudentInput | AttendanceMarkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceMarkUpdateManyWithWhereWithoutStudentInput | AttendanceMarkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceMarkScalarWhereInput | AttendanceMarkScalarWhereInput[]
  }

  export type LibraryIssueUpdateManyWithoutStudentNestedInput = {
    create?: XOR<LibraryIssueCreateWithoutStudentInput, LibraryIssueUncheckedCreateWithoutStudentInput> | LibraryIssueCreateWithoutStudentInput[] | LibraryIssueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LibraryIssueCreateOrConnectWithoutStudentInput | LibraryIssueCreateOrConnectWithoutStudentInput[]
    upsert?: LibraryIssueUpsertWithWhereUniqueWithoutStudentInput | LibraryIssueUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: LibraryIssueCreateManyStudentInputEnvelope
    set?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    disconnect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    delete?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    connect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    update?: LibraryIssueUpdateWithWhereUniqueWithoutStudentInput | LibraryIssueUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: LibraryIssueUpdateManyWithWhereWithoutStudentInput | LibraryIssueUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: LibraryIssueScalarWhereInput | LibraryIssueScalarWhereInput[]
  }

  export type RequestUpdateManyWithoutStudentNestedInput = {
    create?: XOR<RequestCreateWithoutStudentInput, RequestUncheckedCreateWithoutStudentInput> | RequestCreateWithoutStudentInput[] | RequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutStudentInput | RequestCreateOrConnectWithoutStudentInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutStudentInput | RequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: RequestCreateManyStudentInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutStudentInput | RequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutStudentInput | RequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type StudentSettingUpdateOneWithoutStudentNestedInput = {
    create?: XOR<StudentSettingCreateWithoutStudentInput, StudentSettingUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSettingCreateOrConnectWithoutStudentInput
    upsert?: StudentSettingUpsertWithoutStudentInput
    disconnect?: StudentSettingWhereInput | boolean
    delete?: StudentSettingWhereInput | boolean
    connect?: StudentSettingWhereUniqueInput
    update?: XOR<XOR<StudentSettingUpdateToOneWithWhereWithoutStudentInput, StudentSettingUpdateWithoutStudentInput>, StudentSettingUncheckedUpdateWithoutStudentInput>
  }

  export type FeeAccountUpdateOneWithoutStudentNestedInput = {
    create?: XOR<FeeAccountCreateWithoutStudentInput, FeeAccountUncheckedCreateWithoutStudentInput>
    connectOrCreate?: FeeAccountCreateOrConnectWithoutStudentInput
    upsert?: FeeAccountUpsertWithoutStudentInput
    disconnect?: FeeAccountWhereInput | boolean
    delete?: FeeAccountWhereInput | boolean
    connect?: FeeAccountWhereUniqueInput
    update?: XOR<XOR<FeeAccountUpdateToOneWithWhereWithoutStudentInput, FeeAccountUpdateWithoutStudentInput>, FeeAccountUncheckedUpdateWithoutStudentInput>
  }

  export type EnrollmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutStudentInput | EnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutStudentInput | EnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutStudentInput | EnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AttendanceMarkUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceMarkCreateWithoutStudentInput, AttendanceMarkUncheckedCreateWithoutStudentInput> | AttendanceMarkCreateWithoutStudentInput[] | AttendanceMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceMarkCreateOrConnectWithoutStudentInput | AttendanceMarkCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceMarkUpsertWithWhereUniqueWithoutStudentInput | AttendanceMarkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceMarkCreateManyStudentInputEnvelope
    set?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    disconnect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    delete?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    connect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    update?: AttendanceMarkUpdateWithWhereUniqueWithoutStudentInput | AttendanceMarkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceMarkUpdateManyWithWhereWithoutStudentInput | AttendanceMarkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceMarkScalarWhereInput | AttendanceMarkScalarWhereInput[]
  }

  export type LibraryIssueUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<LibraryIssueCreateWithoutStudentInput, LibraryIssueUncheckedCreateWithoutStudentInput> | LibraryIssueCreateWithoutStudentInput[] | LibraryIssueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LibraryIssueCreateOrConnectWithoutStudentInput | LibraryIssueCreateOrConnectWithoutStudentInput[]
    upsert?: LibraryIssueUpsertWithWhereUniqueWithoutStudentInput | LibraryIssueUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: LibraryIssueCreateManyStudentInputEnvelope
    set?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    disconnect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    delete?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    connect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    update?: LibraryIssueUpdateWithWhereUniqueWithoutStudentInput | LibraryIssueUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: LibraryIssueUpdateManyWithWhereWithoutStudentInput | LibraryIssueUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: LibraryIssueScalarWhereInput | LibraryIssueScalarWhereInput[]
  }

  export type RequestUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<RequestCreateWithoutStudentInput, RequestUncheckedCreateWithoutStudentInput> | RequestCreateWithoutStudentInput[] | RequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutStudentInput | RequestCreateOrConnectWithoutStudentInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutStudentInput | RequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: RequestCreateManyStudentInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutStudentInput | RequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutStudentInput | RequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type StudentSettingUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<StudentSettingCreateWithoutStudentInput, StudentSettingUncheckedCreateWithoutStudentInput>
    connectOrCreate?: StudentSettingCreateOrConnectWithoutStudentInput
    upsert?: StudentSettingUpsertWithoutStudentInput
    disconnect?: StudentSettingWhereInput | boolean
    delete?: StudentSettingWhereInput | boolean
    connect?: StudentSettingWhereUniqueInput
    update?: XOR<XOR<StudentSettingUpdateToOneWithWhereWithoutStudentInput, StudentSettingUpdateWithoutStudentInput>, StudentSettingUncheckedUpdateWithoutStudentInput>
  }

  export type FeeAccountUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<FeeAccountCreateWithoutStudentInput, FeeAccountUncheckedCreateWithoutStudentInput>
    connectOrCreate?: FeeAccountCreateOrConnectWithoutStudentInput
    upsert?: FeeAccountUpsertWithoutStudentInput
    disconnect?: FeeAccountWhereInput | boolean
    delete?: FeeAccountWhereInput | boolean
    connect?: FeeAccountWhereUniqueInput
    update?: XOR<XOR<FeeAccountUpdateToOneWithWhereWithoutStudentInput, FeeAccountUpdateWithoutStudentInput>, FeeAccountUncheckedUpdateWithoutStudentInput>
  }

  export type UserCreateNestedOneWithoutFacultyInput = {
    create?: XOR<UserCreateWithoutFacultyInput, UserUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: UserCreateOrConnectWithoutFacultyInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutFacultyInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput
    connect?: DepartmentWhereUniqueInput
  }

  export type DesignationCreateNestedOneWithoutFacultyInput = {
    create?: XOR<DesignationCreateWithoutFacultyInput, DesignationUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: DesignationCreateOrConnectWithoutFacultyInput
    connect?: DesignationWhereUniqueInput
  }

  export type CourseOfferingCreateNestedManyWithoutFacultyInput = {
    create?: XOR<CourseOfferingCreateWithoutFacultyInput, CourseOfferingUncheckedCreateWithoutFacultyInput> | CourseOfferingCreateWithoutFacultyInput[] | CourseOfferingUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutFacultyInput | CourseOfferingCreateOrConnectWithoutFacultyInput[]
    createMany?: CourseOfferingCreateManyFacultyInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type FacultySubjectCreateNestedManyWithoutFacultyInput = {
    create?: XOR<FacultySubjectCreateWithoutFacultyInput, FacultySubjectUncheckedCreateWithoutFacultyInput> | FacultySubjectCreateWithoutFacultyInput[] | FacultySubjectUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultySubjectCreateOrConnectWithoutFacultyInput | FacultySubjectCreateOrConnectWithoutFacultyInput[]
    createMany?: FacultySubjectCreateManyFacultyInputEnvelope
    connect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
  }

  export type CourseOfferingUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<CourseOfferingCreateWithoutFacultyInput, CourseOfferingUncheckedCreateWithoutFacultyInput> | CourseOfferingCreateWithoutFacultyInput[] | CourseOfferingUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutFacultyInput | CourseOfferingCreateOrConnectWithoutFacultyInput[]
    createMany?: CourseOfferingCreateManyFacultyInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type FacultySubjectUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<FacultySubjectCreateWithoutFacultyInput, FacultySubjectUncheckedCreateWithoutFacultyInput> | FacultySubjectCreateWithoutFacultyInput[] | FacultySubjectUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultySubjectCreateOrConnectWithoutFacultyInput | FacultySubjectCreateOrConnectWithoutFacultyInput[]
    createMany?: FacultySubjectCreateManyFacultyInputEnvelope
    connect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutFacultyNestedInput = {
    create?: XOR<UserCreateWithoutFacultyInput, UserUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: UserCreateOrConnectWithoutFacultyInput
    upsert?: UserUpsertWithoutFacultyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFacultyInput, UserUpdateWithoutFacultyInput>, UserUncheckedUpdateWithoutFacultyInput>
  }

  export type DepartmentUpdateOneWithoutFacultyNestedInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput
    upsert?: DepartmentUpsertWithoutFacultyInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutFacultyInput, DepartmentUpdateWithoutFacultyInput>, DepartmentUncheckedUpdateWithoutFacultyInput>
  }

  export type DesignationUpdateOneWithoutFacultyNestedInput = {
    create?: XOR<DesignationCreateWithoutFacultyInput, DesignationUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: DesignationCreateOrConnectWithoutFacultyInput
    upsert?: DesignationUpsertWithoutFacultyInput
    disconnect?: DesignationWhereInput | boolean
    delete?: DesignationWhereInput | boolean
    connect?: DesignationWhereUniqueInput
    update?: XOR<XOR<DesignationUpdateToOneWithWhereWithoutFacultyInput, DesignationUpdateWithoutFacultyInput>, DesignationUncheckedUpdateWithoutFacultyInput>
  }

  export type CourseOfferingUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutFacultyInput, CourseOfferingUncheckedCreateWithoutFacultyInput> | CourseOfferingCreateWithoutFacultyInput[] | CourseOfferingUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutFacultyInput | CourseOfferingCreateOrConnectWithoutFacultyInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutFacultyInput | CourseOfferingUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: CourseOfferingCreateManyFacultyInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutFacultyInput | CourseOfferingUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutFacultyInput | CourseOfferingUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type FacultySubjectUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<FacultySubjectCreateWithoutFacultyInput, FacultySubjectUncheckedCreateWithoutFacultyInput> | FacultySubjectCreateWithoutFacultyInput[] | FacultySubjectUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultySubjectCreateOrConnectWithoutFacultyInput | FacultySubjectCreateOrConnectWithoutFacultyInput[]
    upsert?: FacultySubjectUpsertWithWhereUniqueWithoutFacultyInput | FacultySubjectUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: FacultySubjectCreateManyFacultyInputEnvelope
    set?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    disconnect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    delete?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    connect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    update?: FacultySubjectUpdateWithWhereUniqueWithoutFacultyInput | FacultySubjectUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: FacultySubjectUpdateManyWithWhereWithoutFacultyInput | FacultySubjectUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: FacultySubjectScalarWhereInput | FacultySubjectScalarWhereInput[]
  }

  export type CourseOfferingUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutFacultyInput, CourseOfferingUncheckedCreateWithoutFacultyInput> | CourseOfferingCreateWithoutFacultyInput[] | CourseOfferingUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutFacultyInput | CourseOfferingCreateOrConnectWithoutFacultyInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutFacultyInput | CourseOfferingUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: CourseOfferingCreateManyFacultyInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutFacultyInput | CourseOfferingUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutFacultyInput | CourseOfferingUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type FacultySubjectUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<FacultySubjectCreateWithoutFacultyInput, FacultySubjectUncheckedCreateWithoutFacultyInput> | FacultySubjectCreateWithoutFacultyInput[] | FacultySubjectUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FacultySubjectCreateOrConnectWithoutFacultyInput | FacultySubjectCreateOrConnectWithoutFacultyInput[]
    upsert?: FacultySubjectUpsertWithWhereUniqueWithoutFacultyInput | FacultySubjectUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: FacultySubjectCreateManyFacultyInputEnvelope
    set?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    disconnect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    delete?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    connect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    update?: FacultySubjectUpdateWithWhereUniqueWithoutFacultyInput | FacultySubjectUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: FacultySubjectUpdateManyWithWhereWithoutFacultyInput | FacultySubjectUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: FacultySubjectScalarWhereInput | FacultySubjectScalarWhereInput[]
  }

  export type DesignationCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DesignationCreateWithoutDepartmentInput, DesignationUncheckedCreateWithoutDepartmentInput> | DesignationCreateWithoutDepartmentInput[] | DesignationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DesignationCreateOrConnectWithoutDepartmentInput | DesignationCreateOrConnectWithoutDepartmentInput[]
    createMany?: DesignationCreateManyDepartmentInputEnvelope
    connect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput> | SubjectCreateWithoutDepartmentInput[] | SubjectUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutDepartmentInput | SubjectCreateOrConnectWithoutDepartmentInput[]
    createMany?: SubjectCreateManyDepartmentInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type FacultyProfileCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<FacultyProfileCreateWithoutDepartmentInput, FacultyProfileUncheckedCreateWithoutDepartmentInput> | FacultyProfileCreateWithoutDepartmentInput[] | FacultyProfileUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutDepartmentInput | FacultyProfileCreateOrConnectWithoutDepartmentInput[]
    createMany?: FacultyProfileCreateManyDepartmentInputEnvelope
    connect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
  }

  export type DesignationUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DesignationCreateWithoutDepartmentInput, DesignationUncheckedCreateWithoutDepartmentInput> | DesignationCreateWithoutDepartmentInput[] | DesignationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DesignationCreateOrConnectWithoutDepartmentInput | DesignationCreateOrConnectWithoutDepartmentInput[]
    createMany?: DesignationCreateManyDepartmentInputEnvelope
    connect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput> | SubjectCreateWithoutDepartmentInput[] | SubjectUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutDepartmentInput | SubjectCreateOrConnectWithoutDepartmentInput[]
    createMany?: SubjectCreateManyDepartmentInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type FacultyProfileUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<FacultyProfileCreateWithoutDepartmentInput, FacultyProfileUncheckedCreateWithoutDepartmentInput> | FacultyProfileCreateWithoutDepartmentInput[] | FacultyProfileUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutDepartmentInput | FacultyProfileCreateOrConnectWithoutDepartmentInput[]
    createMany?: FacultyProfileCreateManyDepartmentInputEnvelope
    connect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DesignationUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DesignationCreateWithoutDepartmentInput, DesignationUncheckedCreateWithoutDepartmentInput> | DesignationCreateWithoutDepartmentInput[] | DesignationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DesignationCreateOrConnectWithoutDepartmentInput | DesignationCreateOrConnectWithoutDepartmentInput[]
    upsert?: DesignationUpsertWithWhereUniqueWithoutDepartmentInput | DesignationUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DesignationCreateManyDepartmentInputEnvelope
    set?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    disconnect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    delete?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    connect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    update?: DesignationUpdateWithWhereUniqueWithoutDepartmentInput | DesignationUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DesignationUpdateManyWithWhereWithoutDepartmentInput | DesignationUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DesignationScalarWhereInput | DesignationScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput> | SubjectCreateWithoutDepartmentInput[] | SubjectUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutDepartmentInput | SubjectCreateOrConnectWithoutDepartmentInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutDepartmentInput | SubjectUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: SubjectCreateManyDepartmentInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutDepartmentInput | SubjectUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutDepartmentInput | SubjectUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type FacultyProfileUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<FacultyProfileCreateWithoutDepartmentInput, FacultyProfileUncheckedCreateWithoutDepartmentInput> | FacultyProfileCreateWithoutDepartmentInput[] | FacultyProfileUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutDepartmentInput | FacultyProfileCreateOrConnectWithoutDepartmentInput[]
    upsert?: FacultyProfileUpsertWithWhereUniqueWithoutDepartmentInput | FacultyProfileUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: FacultyProfileCreateManyDepartmentInputEnvelope
    set?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    disconnect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    delete?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    connect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    update?: FacultyProfileUpdateWithWhereUniqueWithoutDepartmentInput | FacultyProfileUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: FacultyProfileUpdateManyWithWhereWithoutDepartmentInput | FacultyProfileUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: FacultyProfileScalarWhereInput | FacultyProfileScalarWhereInput[]
  }

  export type DesignationUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DesignationCreateWithoutDepartmentInput, DesignationUncheckedCreateWithoutDepartmentInput> | DesignationCreateWithoutDepartmentInput[] | DesignationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DesignationCreateOrConnectWithoutDepartmentInput | DesignationCreateOrConnectWithoutDepartmentInput[]
    upsert?: DesignationUpsertWithWhereUniqueWithoutDepartmentInput | DesignationUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DesignationCreateManyDepartmentInputEnvelope
    set?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    disconnect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    delete?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    connect?: DesignationWhereUniqueInput | DesignationWhereUniqueInput[]
    update?: DesignationUpdateWithWhereUniqueWithoutDepartmentInput | DesignationUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DesignationUpdateManyWithWhereWithoutDepartmentInput | DesignationUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DesignationScalarWhereInput | DesignationScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput> | SubjectCreateWithoutDepartmentInput[] | SubjectUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutDepartmentInput | SubjectCreateOrConnectWithoutDepartmentInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutDepartmentInput | SubjectUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: SubjectCreateManyDepartmentInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutDepartmentInput | SubjectUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutDepartmentInput | SubjectUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type FacultyProfileUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<FacultyProfileCreateWithoutDepartmentInput, FacultyProfileUncheckedCreateWithoutDepartmentInput> | FacultyProfileCreateWithoutDepartmentInput[] | FacultyProfileUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutDepartmentInput | FacultyProfileCreateOrConnectWithoutDepartmentInput[]
    upsert?: FacultyProfileUpsertWithWhereUniqueWithoutDepartmentInput | FacultyProfileUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: FacultyProfileCreateManyDepartmentInputEnvelope
    set?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    disconnect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    delete?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    connect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    update?: FacultyProfileUpdateWithWhereUniqueWithoutDepartmentInput | FacultyProfileUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: FacultyProfileUpdateManyWithWhereWithoutDepartmentInput | FacultyProfileUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: FacultyProfileScalarWhereInput | FacultyProfileScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutDesignationsInput = {
    create?: XOR<DepartmentCreateWithoutDesignationsInput, DepartmentUncheckedCreateWithoutDesignationsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDesignationsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type FacultyProfileCreateNestedManyWithoutDesignationInput = {
    create?: XOR<FacultyProfileCreateWithoutDesignationInput, FacultyProfileUncheckedCreateWithoutDesignationInput> | FacultyProfileCreateWithoutDesignationInput[] | FacultyProfileUncheckedCreateWithoutDesignationInput[]
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutDesignationInput | FacultyProfileCreateOrConnectWithoutDesignationInput[]
    createMany?: FacultyProfileCreateManyDesignationInputEnvelope
    connect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
  }

  export type FacultyProfileUncheckedCreateNestedManyWithoutDesignationInput = {
    create?: XOR<FacultyProfileCreateWithoutDesignationInput, FacultyProfileUncheckedCreateWithoutDesignationInput> | FacultyProfileCreateWithoutDesignationInput[] | FacultyProfileUncheckedCreateWithoutDesignationInput[]
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutDesignationInput | FacultyProfileCreateOrConnectWithoutDesignationInput[]
    createMany?: FacultyProfileCreateManyDesignationInputEnvelope
    connect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DepartmentUpdateOneRequiredWithoutDesignationsNestedInput = {
    create?: XOR<DepartmentCreateWithoutDesignationsInput, DepartmentUncheckedCreateWithoutDesignationsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDesignationsInput
    upsert?: DepartmentUpsertWithoutDesignationsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutDesignationsInput, DepartmentUpdateWithoutDesignationsInput>, DepartmentUncheckedUpdateWithoutDesignationsInput>
  }

  export type FacultyProfileUpdateManyWithoutDesignationNestedInput = {
    create?: XOR<FacultyProfileCreateWithoutDesignationInput, FacultyProfileUncheckedCreateWithoutDesignationInput> | FacultyProfileCreateWithoutDesignationInput[] | FacultyProfileUncheckedCreateWithoutDesignationInput[]
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutDesignationInput | FacultyProfileCreateOrConnectWithoutDesignationInput[]
    upsert?: FacultyProfileUpsertWithWhereUniqueWithoutDesignationInput | FacultyProfileUpsertWithWhereUniqueWithoutDesignationInput[]
    createMany?: FacultyProfileCreateManyDesignationInputEnvelope
    set?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    disconnect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    delete?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    connect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    update?: FacultyProfileUpdateWithWhereUniqueWithoutDesignationInput | FacultyProfileUpdateWithWhereUniqueWithoutDesignationInput[]
    updateMany?: FacultyProfileUpdateManyWithWhereWithoutDesignationInput | FacultyProfileUpdateManyWithWhereWithoutDesignationInput[]
    deleteMany?: FacultyProfileScalarWhereInput | FacultyProfileScalarWhereInput[]
  }

  export type FacultyProfileUncheckedUpdateManyWithoutDesignationNestedInput = {
    create?: XOR<FacultyProfileCreateWithoutDesignationInput, FacultyProfileUncheckedCreateWithoutDesignationInput> | FacultyProfileCreateWithoutDesignationInput[] | FacultyProfileUncheckedCreateWithoutDesignationInput[]
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutDesignationInput | FacultyProfileCreateOrConnectWithoutDesignationInput[]
    upsert?: FacultyProfileUpsertWithWhereUniqueWithoutDesignationInput | FacultyProfileUpsertWithWhereUniqueWithoutDesignationInput[]
    createMany?: FacultyProfileCreateManyDesignationInputEnvelope
    set?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    disconnect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    delete?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    connect?: FacultyProfileWhereUniqueInput | FacultyProfileWhereUniqueInput[]
    update?: FacultyProfileUpdateWithWhereUniqueWithoutDesignationInput | FacultyProfileUpdateWithWhereUniqueWithoutDesignationInput[]
    updateMany?: FacultyProfileUpdateManyWithWhereWithoutDesignationInput | FacultyProfileUpdateManyWithWhereWithoutDesignationInput[]
    deleteMany?: FacultyProfileScalarWhereInput | FacultyProfileScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<DepartmentCreateWithoutSubjectsInput, DepartmentUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSubjectsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type FacultySubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<FacultySubjectCreateWithoutSubjectInput, FacultySubjectUncheckedCreateWithoutSubjectInput> | FacultySubjectCreateWithoutSubjectInput[] | FacultySubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: FacultySubjectCreateOrConnectWithoutSubjectInput | FacultySubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: FacultySubjectCreateManySubjectInputEnvelope
    connect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
  }

  export type FacultySubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<FacultySubjectCreateWithoutSubjectInput, FacultySubjectUncheckedCreateWithoutSubjectInput> | FacultySubjectCreateWithoutSubjectInput[] | FacultySubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: FacultySubjectCreateOrConnectWithoutSubjectInput | FacultySubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: FacultySubjectCreateManySubjectInputEnvelope
    connect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
  }

  export type DepartmentUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<DepartmentCreateWithoutSubjectsInput, DepartmentUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSubjectsInput
    upsert?: DepartmentUpsertWithoutSubjectsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutSubjectsInput, DepartmentUpdateWithoutSubjectsInput>, DepartmentUncheckedUpdateWithoutSubjectsInput>
  }

  export type FacultySubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<FacultySubjectCreateWithoutSubjectInput, FacultySubjectUncheckedCreateWithoutSubjectInput> | FacultySubjectCreateWithoutSubjectInput[] | FacultySubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: FacultySubjectCreateOrConnectWithoutSubjectInput | FacultySubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: FacultySubjectUpsertWithWhereUniqueWithoutSubjectInput | FacultySubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: FacultySubjectCreateManySubjectInputEnvelope
    set?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    disconnect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    delete?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    connect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    update?: FacultySubjectUpdateWithWhereUniqueWithoutSubjectInput | FacultySubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: FacultySubjectUpdateManyWithWhereWithoutSubjectInput | FacultySubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: FacultySubjectScalarWhereInput | FacultySubjectScalarWhereInput[]
  }

  export type FacultySubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<FacultySubjectCreateWithoutSubjectInput, FacultySubjectUncheckedCreateWithoutSubjectInput> | FacultySubjectCreateWithoutSubjectInput[] | FacultySubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: FacultySubjectCreateOrConnectWithoutSubjectInput | FacultySubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: FacultySubjectUpsertWithWhereUniqueWithoutSubjectInput | FacultySubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: FacultySubjectCreateManySubjectInputEnvelope
    set?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    disconnect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    delete?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    connect?: FacultySubjectWhereUniqueInput | FacultySubjectWhereUniqueInput[]
    update?: FacultySubjectUpdateWithWhereUniqueWithoutSubjectInput | FacultySubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: FacultySubjectUpdateManyWithWhereWithoutSubjectInput | FacultySubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: FacultySubjectScalarWhereInput | FacultySubjectScalarWhereInput[]
  }

  export type FacultyProfileCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<FacultyProfileCreateWithoutSubjectsInput, FacultyProfileUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutSubjectsInput
    connect?: FacultyProfileWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutFacultyInput = {
    create?: XOR<SubjectCreateWithoutFacultyInput, SubjectUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutFacultyInput
    connect?: SubjectWhereUniqueInput
  }

  export type FacultyProfileUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<FacultyProfileCreateWithoutSubjectsInput, FacultyProfileUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutSubjectsInput
    upsert?: FacultyProfileUpsertWithoutSubjectsInput
    connect?: FacultyProfileWhereUniqueInput
    update?: XOR<XOR<FacultyProfileUpdateToOneWithWhereWithoutSubjectsInput, FacultyProfileUpdateWithoutSubjectsInput>, FacultyProfileUncheckedUpdateWithoutSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutFacultyNestedInput = {
    create?: XOR<SubjectCreateWithoutFacultyInput, SubjectUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutFacultyInput
    upsert?: SubjectUpsertWithoutFacultyInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutFacultyInput, SubjectUpdateWithoutFacultyInput>, SubjectUncheckedUpdateWithoutFacultyInput>
  }

  export type CourseOfferingCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput> | CourseOfferingCreateWithoutCourseInput[] | CourseOfferingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutCourseInput | CourseOfferingCreateOrConnectWithoutCourseInput[]
    createMany?: CourseOfferingCreateManyCourseInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type CourseOfferingUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput> | CourseOfferingCreateWithoutCourseInput[] | CourseOfferingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutCourseInput | CourseOfferingCreateOrConnectWithoutCourseInput[]
    createMany?: CourseOfferingCreateManyCourseInputEnvelope
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
  }

  export type CourseOfferingUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput> | CourseOfferingCreateWithoutCourseInput[] | CourseOfferingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutCourseInput | CourseOfferingCreateOrConnectWithoutCourseInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutCourseInput | CourseOfferingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseOfferingCreateManyCourseInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutCourseInput | CourseOfferingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutCourseInput | CourseOfferingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type CourseOfferingUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput> | CourseOfferingCreateWithoutCourseInput[] | CourseOfferingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutCourseInput | CourseOfferingCreateOrConnectWithoutCourseInput[]
    upsert?: CourseOfferingUpsertWithWhereUniqueWithoutCourseInput | CourseOfferingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseOfferingCreateManyCourseInputEnvelope
    set?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    disconnect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    delete?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    connect?: CourseOfferingWhereUniqueInput | CourseOfferingWhereUniqueInput[]
    update?: CourseOfferingUpdateWithWhereUniqueWithoutCourseInput | CourseOfferingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseOfferingUpdateManyWithWhereWithoutCourseInput | CourseOfferingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutOfferingsInput = {
    create?: XOR<CourseCreateWithoutOfferingsInput, CourseUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOfferingsInput
    connect?: CourseWhereUniqueInput
  }

  export type FacultyProfileCreateNestedOneWithoutOfferingsInput = {
    create?: XOR<FacultyProfileCreateWithoutOfferingsInput, FacultyProfileUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutOfferingsInput
    connect?: FacultyProfileWhereUniqueInput
  }

  export type EnrollmentCreateNestedManyWithoutOfferingInput = {
    create?: XOR<EnrollmentCreateWithoutOfferingInput, EnrollmentUncheckedCreateWithoutOfferingInput> | EnrollmentCreateWithoutOfferingInput[] | EnrollmentUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutOfferingInput | EnrollmentCreateOrConnectWithoutOfferingInput[]
    createMany?: EnrollmentCreateManyOfferingInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AttendanceSessionCreateNestedManyWithoutOfferingInput = {
    create?: XOR<AttendanceSessionCreateWithoutOfferingInput, AttendanceSessionUncheckedCreateWithoutOfferingInput> | AttendanceSessionCreateWithoutOfferingInput[] | AttendanceSessionUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: AttendanceSessionCreateOrConnectWithoutOfferingInput | AttendanceSessionCreateOrConnectWithoutOfferingInput[]
    createMany?: AttendanceSessionCreateManyOfferingInputEnvelope
    connect?: AttendanceSessionWhereUniqueInput | AttendanceSessionWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutOfferingInput = {
    create?: XOR<EnrollmentCreateWithoutOfferingInput, EnrollmentUncheckedCreateWithoutOfferingInput> | EnrollmentCreateWithoutOfferingInput[] | EnrollmentUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutOfferingInput | EnrollmentCreateOrConnectWithoutOfferingInput[]
    createMany?: EnrollmentCreateManyOfferingInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AttendanceSessionUncheckedCreateNestedManyWithoutOfferingInput = {
    create?: XOR<AttendanceSessionCreateWithoutOfferingInput, AttendanceSessionUncheckedCreateWithoutOfferingInput> | AttendanceSessionCreateWithoutOfferingInput[] | AttendanceSessionUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: AttendanceSessionCreateOrConnectWithoutOfferingInput | AttendanceSessionCreateOrConnectWithoutOfferingInput[]
    createMany?: AttendanceSessionCreateManyOfferingInputEnvelope
    connect?: AttendanceSessionWhereUniqueInput | AttendanceSessionWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutOfferingsNestedInput = {
    create?: XOR<CourseCreateWithoutOfferingsInput, CourseUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOfferingsInput
    upsert?: CourseUpsertWithoutOfferingsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutOfferingsInput, CourseUpdateWithoutOfferingsInput>, CourseUncheckedUpdateWithoutOfferingsInput>
  }

  export type FacultyProfileUpdateOneRequiredWithoutOfferingsNestedInput = {
    create?: XOR<FacultyProfileCreateWithoutOfferingsInput, FacultyProfileUncheckedCreateWithoutOfferingsInput>
    connectOrCreate?: FacultyProfileCreateOrConnectWithoutOfferingsInput
    upsert?: FacultyProfileUpsertWithoutOfferingsInput
    connect?: FacultyProfileWhereUniqueInput
    update?: XOR<XOR<FacultyProfileUpdateToOneWithWhereWithoutOfferingsInput, FacultyProfileUpdateWithoutOfferingsInput>, FacultyProfileUncheckedUpdateWithoutOfferingsInput>
  }

  export type EnrollmentUpdateManyWithoutOfferingNestedInput = {
    create?: XOR<EnrollmentCreateWithoutOfferingInput, EnrollmentUncheckedCreateWithoutOfferingInput> | EnrollmentCreateWithoutOfferingInput[] | EnrollmentUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutOfferingInput | EnrollmentCreateOrConnectWithoutOfferingInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutOfferingInput | EnrollmentUpsertWithWhereUniqueWithoutOfferingInput[]
    createMany?: EnrollmentCreateManyOfferingInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutOfferingInput | EnrollmentUpdateWithWhereUniqueWithoutOfferingInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutOfferingInput | EnrollmentUpdateManyWithWhereWithoutOfferingInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AttendanceSessionUpdateManyWithoutOfferingNestedInput = {
    create?: XOR<AttendanceSessionCreateWithoutOfferingInput, AttendanceSessionUncheckedCreateWithoutOfferingInput> | AttendanceSessionCreateWithoutOfferingInput[] | AttendanceSessionUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: AttendanceSessionCreateOrConnectWithoutOfferingInput | AttendanceSessionCreateOrConnectWithoutOfferingInput[]
    upsert?: AttendanceSessionUpsertWithWhereUniqueWithoutOfferingInput | AttendanceSessionUpsertWithWhereUniqueWithoutOfferingInput[]
    createMany?: AttendanceSessionCreateManyOfferingInputEnvelope
    set?: AttendanceSessionWhereUniqueInput | AttendanceSessionWhereUniqueInput[]
    disconnect?: AttendanceSessionWhereUniqueInput | AttendanceSessionWhereUniqueInput[]
    delete?: AttendanceSessionWhereUniqueInput | AttendanceSessionWhereUniqueInput[]
    connect?: AttendanceSessionWhereUniqueInput | AttendanceSessionWhereUniqueInput[]
    update?: AttendanceSessionUpdateWithWhereUniqueWithoutOfferingInput | AttendanceSessionUpdateWithWhereUniqueWithoutOfferingInput[]
    updateMany?: AttendanceSessionUpdateManyWithWhereWithoutOfferingInput | AttendanceSessionUpdateManyWithWhereWithoutOfferingInput[]
    deleteMany?: AttendanceSessionScalarWhereInput | AttendanceSessionScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutOfferingNestedInput = {
    create?: XOR<EnrollmentCreateWithoutOfferingInput, EnrollmentUncheckedCreateWithoutOfferingInput> | EnrollmentCreateWithoutOfferingInput[] | EnrollmentUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutOfferingInput | EnrollmentCreateOrConnectWithoutOfferingInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutOfferingInput | EnrollmentUpsertWithWhereUniqueWithoutOfferingInput[]
    createMany?: EnrollmentCreateManyOfferingInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutOfferingInput | EnrollmentUpdateWithWhereUniqueWithoutOfferingInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutOfferingInput | EnrollmentUpdateManyWithWhereWithoutOfferingInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AttendanceSessionUncheckedUpdateManyWithoutOfferingNestedInput = {
    create?: XOR<AttendanceSessionCreateWithoutOfferingInput, AttendanceSessionUncheckedCreateWithoutOfferingInput> | AttendanceSessionCreateWithoutOfferingInput[] | AttendanceSessionUncheckedCreateWithoutOfferingInput[]
    connectOrCreate?: AttendanceSessionCreateOrConnectWithoutOfferingInput | AttendanceSessionCreateOrConnectWithoutOfferingInput[]
    upsert?: AttendanceSessionUpsertWithWhereUniqueWithoutOfferingInput | AttendanceSessionUpsertWithWhereUniqueWithoutOfferingInput[]
    createMany?: AttendanceSessionCreateManyOfferingInputEnvelope
    set?: AttendanceSessionWhereUniqueInput | AttendanceSessionWhereUniqueInput[]
    disconnect?: AttendanceSessionWhereUniqueInput | AttendanceSessionWhereUniqueInput[]
    delete?: AttendanceSessionWhereUniqueInput | AttendanceSessionWhereUniqueInput[]
    connect?: AttendanceSessionWhereUniqueInput | AttendanceSessionWhereUniqueInput[]
    update?: AttendanceSessionUpdateWithWhereUniqueWithoutOfferingInput | AttendanceSessionUpdateWithWhereUniqueWithoutOfferingInput[]
    updateMany?: AttendanceSessionUpdateManyWithWhereWithoutOfferingInput | AttendanceSessionUpdateManyWithWhereWithoutOfferingInput[]
    deleteMany?: AttendanceSessionScalarWhereInput | AttendanceSessionScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseOfferingCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseOfferingCreateWithoutEnrollmentsInput, CourseOfferingUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseOfferingWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    upsert?: StudentUpsertWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutEnrollmentsInput, StudentUpdateWithoutEnrollmentsInput>, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseOfferingUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutEnrollmentsInput, CourseOfferingUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseOfferingUpsertWithoutEnrollmentsInput
    connect?: CourseOfferingWhereUniqueInput
    update?: XOR<XOR<CourseOfferingUpdateToOneWithWhereWithoutEnrollmentsInput, CourseOfferingUpdateWithoutEnrollmentsInput>, CourseOfferingUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseOfferingCreateNestedOneWithoutSessionsInput = {
    create?: XOR<CourseOfferingCreateWithoutSessionsInput, CourseOfferingUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutSessionsInput
    connect?: CourseOfferingWhereUniqueInput
  }

  export type AttendanceMarkCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceMarkCreateWithoutSessionInput, AttendanceMarkUncheckedCreateWithoutSessionInput> | AttendanceMarkCreateWithoutSessionInput[] | AttendanceMarkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceMarkCreateOrConnectWithoutSessionInput | AttendanceMarkCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceMarkCreateManySessionInputEnvelope
    connect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
  }

  export type AttendanceMarkUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceMarkCreateWithoutSessionInput, AttendanceMarkUncheckedCreateWithoutSessionInput> | AttendanceMarkCreateWithoutSessionInput[] | AttendanceMarkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceMarkCreateOrConnectWithoutSessionInput | AttendanceMarkCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceMarkCreateManySessionInputEnvelope
    connect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
  }

  export type CourseOfferingUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<CourseOfferingCreateWithoutSessionsInput, CourseOfferingUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CourseOfferingCreateOrConnectWithoutSessionsInput
    upsert?: CourseOfferingUpsertWithoutSessionsInput
    connect?: CourseOfferingWhereUniqueInput
    update?: XOR<XOR<CourseOfferingUpdateToOneWithWhereWithoutSessionsInput, CourseOfferingUpdateWithoutSessionsInput>, CourseOfferingUncheckedUpdateWithoutSessionsInput>
  }

  export type AttendanceMarkUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceMarkCreateWithoutSessionInput, AttendanceMarkUncheckedCreateWithoutSessionInput> | AttendanceMarkCreateWithoutSessionInput[] | AttendanceMarkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceMarkCreateOrConnectWithoutSessionInput | AttendanceMarkCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceMarkUpsertWithWhereUniqueWithoutSessionInput | AttendanceMarkUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceMarkCreateManySessionInputEnvelope
    set?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    disconnect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    delete?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    connect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    update?: AttendanceMarkUpdateWithWhereUniqueWithoutSessionInput | AttendanceMarkUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceMarkUpdateManyWithWhereWithoutSessionInput | AttendanceMarkUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceMarkScalarWhereInput | AttendanceMarkScalarWhereInput[]
  }

  export type AttendanceMarkUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceMarkCreateWithoutSessionInput, AttendanceMarkUncheckedCreateWithoutSessionInput> | AttendanceMarkCreateWithoutSessionInput[] | AttendanceMarkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceMarkCreateOrConnectWithoutSessionInput | AttendanceMarkCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceMarkUpsertWithWhereUniqueWithoutSessionInput | AttendanceMarkUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceMarkCreateManySessionInputEnvelope
    set?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    disconnect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    delete?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    connect?: AttendanceMarkWhereUniqueInput | AttendanceMarkWhereUniqueInput[]
    update?: AttendanceMarkUpdateWithWhereUniqueWithoutSessionInput | AttendanceMarkUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceMarkUpdateManyWithWhereWithoutSessionInput | AttendanceMarkUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceMarkScalarWhereInput | AttendanceMarkScalarWhereInput[]
  }

  export type AttendanceSessionCreateNestedOneWithoutMarksInput = {
    create?: XOR<AttendanceSessionCreateWithoutMarksInput, AttendanceSessionUncheckedCreateWithoutMarksInput>
    connectOrCreate?: AttendanceSessionCreateOrConnectWithoutMarksInput
    connect?: AttendanceSessionWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAttendanceMarksInput = {
    create?: XOR<StudentCreateWithoutAttendanceMarksInput, StudentUncheckedCreateWithoutAttendanceMarksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceMarksInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumAttendanceMarkStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceMarkStatus
  }

  export type AttendanceSessionUpdateOneRequiredWithoutMarksNestedInput = {
    create?: XOR<AttendanceSessionCreateWithoutMarksInput, AttendanceSessionUncheckedCreateWithoutMarksInput>
    connectOrCreate?: AttendanceSessionCreateOrConnectWithoutMarksInput
    upsert?: AttendanceSessionUpsertWithoutMarksInput
    connect?: AttendanceSessionWhereUniqueInput
    update?: XOR<XOR<AttendanceSessionUpdateToOneWithWhereWithoutMarksInput, AttendanceSessionUpdateWithoutMarksInput>, AttendanceSessionUncheckedUpdateWithoutMarksInput>
  }

  export type StudentUpdateOneRequiredWithoutAttendanceMarksNestedInput = {
    create?: XOR<StudentCreateWithoutAttendanceMarksInput, StudentUncheckedCreateWithoutAttendanceMarksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceMarksInput
    upsert?: StudentUpsertWithoutAttendanceMarksInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendanceMarksInput, StudentUpdateWithoutAttendanceMarksInput>, StudentUncheckedUpdateWithoutAttendanceMarksInput>
  }

  export type LibraryCopyCreateNestedManyWithoutBookInput = {
    create?: XOR<LibraryCopyCreateWithoutBookInput, LibraryCopyUncheckedCreateWithoutBookInput> | LibraryCopyCreateWithoutBookInput[] | LibraryCopyUncheckedCreateWithoutBookInput[]
    connectOrCreate?: LibraryCopyCreateOrConnectWithoutBookInput | LibraryCopyCreateOrConnectWithoutBookInput[]
    createMany?: LibraryCopyCreateManyBookInputEnvelope
    connect?: LibraryCopyWhereUniqueInput | LibraryCopyWhereUniqueInput[]
  }

  export type LibraryCopyUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<LibraryCopyCreateWithoutBookInput, LibraryCopyUncheckedCreateWithoutBookInput> | LibraryCopyCreateWithoutBookInput[] | LibraryCopyUncheckedCreateWithoutBookInput[]
    connectOrCreate?: LibraryCopyCreateOrConnectWithoutBookInput | LibraryCopyCreateOrConnectWithoutBookInput[]
    createMany?: LibraryCopyCreateManyBookInputEnvelope
    connect?: LibraryCopyWhereUniqueInput | LibraryCopyWhereUniqueInput[]
  }

  export type LibraryCopyUpdateManyWithoutBookNestedInput = {
    create?: XOR<LibraryCopyCreateWithoutBookInput, LibraryCopyUncheckedCreateWithoutBookInput> | LibraryCopyCreateWithoutBookInput[] | LibraryCopyUncheckedCreateWithoutBookInput[]
    connectOrCreate?: LibraryCopyCreateOrConnectWithoutBookInput | LibraryCopyCreateOrConnectWithoutBookInput[]
    upsert?: LibraryCopyUpsertWithWhereUniqueWithoutBookInput | LibraryCopyUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: LibraryCopyCreateManyBookInputEnvelope
    set?: LibraryCopyWhereUniqueInput | LibraryCopyWhereUniqueInput[]
    disconnect?: LibraryCopyWhereUniqueInput | LibraryCopyWhereUniqueInput[]
    delete?: LibraryCopyWhereUniqueInput | LibraryCopyWhereUniqueInput[]
    connect?: LibraryCopyWhereUniqueInput | LibraryCopyWhereUniqueInput[]
    update?: LibraryCopyUpdateWithWhereUniqueWithoutBookInput | LibraryCopyUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: LibraryCopyUpdateManyWithWhereWithoutBookInput | LibraryCopyUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: LibraryCopyScalarWhereInput | LibraryCopyScalarWhereInput[]
  }

  export type LibraryCopyUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<LibraryCopyCreateWithoutBookInput, LibraryCopyUncheckedCreateWithoutBookInput> | LibraryCopyCreateWithoutBookInput[] | LibraryCopyUncheckedCreateWithoutBookInput[]
    connectOrCreate?: LibraryCopyCreateOrConnectWithoutBookInput | LibraryCopyCreateOrConnectWithoutBookInput[]
    upsert?: LibraryCopyUpsertWithWhereUniqueWithoutBookInput | LibraryCopyUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: LibraryCopyCreateManyBookInputEnvelope
    set?: LibraryCopyWhereUniqueInput | LibraryCopyWhereUniqueInput[]
    disconnect?: LibraryCopyWhereUniqueInput | LibraryCopyWhereUniqueInput[]
    delete?: LibraryCopyWhereUniqueInput | LibraryCopyWhereUniqueInput[]
    connect?: LibraryCopyWhereUniqueInput | LibraryCopyWhereUniqueInput[]
    update?: LibraryCopyUpdateWithWhereUniqueWithoutBookInput | LibraryCopyUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: LibraryCopyUpdateManyWithWhereWithoutBookInput | LibraryCopyUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: LibraryCopyScalarWhereInput | LibraryCopyScalarWhereInput[]
  }

  export type LibraryBookCreateNestedOneWithoutCopiesInput = {
    create?: XOR<LibraryBookCreateWithoutCopiesInput, LibraryBookUncheckedCreateWithoutCopiesInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutCopiesInput
    connect?: LibraryBookWhereUniqueInput
  }

  export type LibraryIssueCreateNestedManyWithoutCopyInput = {
    create?: XOR<LibraryIssueCreateWithoutCopyInput, LibraryIssueUncheckedCreateWithoutCopyInput> | LibraryIssueCreateWithoutCopyInput[] | LibraryIssueUncheckedCreateWithoutCopyInput[]
    connectOrCreate?: LibraryIssueCreateOrConnectWithoutCopyInput | LibraryIssueCreateOrConnectWithoutCopyInput[]
    createMany?: LibraryIssueCreateManyCopyInputEnvelope
    connect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
  }

  export type LibraryIssueUncheckedCreateNestedManyWithoutCopyInput = {
    create?: XOR<LibraryIssueCreateWithoutCopyInput, LibraryIssueUncheckedCreateWithoutCopyInput> | LibraryIssueCreateWithoutCopyInput[] | LibraryIssueUncheckedCreateWithoutCopyInput[]
    connectOrCreate?: LibraryIssueCreateOrConnectWithoutCopyInput | LibraryIssueCreateOrConnectWithoutCopyInput[]
    createMany?: LibraryIssueCreateManyCopyInputEnvelope
    connect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
  }

  export type EnumLibraryCopyStatusFieldUpdateOperationsInput = {
    set?: $Enums.LibraryCopyStatus
  }

  export type LibraryBookUpdateOneRequiredWithoutCopiesNestedInput = {
    create?: XOR<LibraryBookCreateWithoutCopiesInput, LibraryBookUncheckedCreateWithoutCopiesInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutCopiesInput
    upsert?: LibraryBookUpsertWithoutCopiesInput
    connect?: LibraryBookWhereUniqueInput
    update?: XOR<XOR<LibraryBookUpdateToOneWithWhereWithoutCopiesInput, LibraryBookUpdateWithoutCopiesInput>, LibraryBookUncheckedUpdateWithoutCopiesInput>
  }

  export type LibraryIssueUpdateManyWithoutCopyNestedInput = {
    create?: XOR<LibraryIssueCreateWithoutCopyInput, LibraryIssueUncheckedCreateWithoutCopyInput> | LibraryIssueCreateWithoutCopyInput[] | LibraryIssueUncheckedCreateWithoutCopyInput[]
    connectOrCreate?: LibraryIssueCreateOrConnectWithoutCopyInput | LibraryIssueCreateOrConnectWithoutCopyInput[]
    upsert?: LibraryIssueUpsertWithWhereUniqueWithoutCopyInput | LibraryIssueUpsertWithWhereUniqueWithoutCopyInput[]
    createMany?: LibraryIssueCreateManyCopyInputEnvelope
    set?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    disconnect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    delete?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    connect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    update?: LibraryIssueUpdateWithWhereUniqueWithoutCopyInput | LibraryIssueUpdateWithWhereUniqueWithoutCopyInput[]
    updateMany?: LibraryIssueUpdateManyWithWhereWithoutCopyInput | LibraryIssueUpdateManyWithWhereWithoutCopyInput[]
    deleteMany?: LibraryIssueScalarWhereInput | LibraryIssueScalarWhereInput[]
  }

  export type LibraryIssueUncheckedUpdateManyWithoutCopyNestedInput = {
    create?: XOR<LibraryIssueCreateWithoutCopyInput, LibraryIssueUncheckedCreateWithoutCopyInput> | LibraryIssueCreateWithoutCopyInput[] | LibraryIssueUncheckedCreateWithoutCopyInput[]
    connectOrCreate?: LibraryIssueCreateOrConnectWithoutCopyInput | LibraryIssueCreateOrConnectWithoutCopyInput[]
    upsert?: LibraryIssueUpsertWithWhereUniqueWithoutCopyInput | LibraryIssueUpsertWithWhereUniqueWithoutCopyInput[]
    createMany?: LibraryIssueCreateManyCopyInputEnvelope
    set?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    disconnect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    delete?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    connect?: LibraryIssueWhereUniqueInput | LibraryIssueWhereUniqueInput[]
    update?: LibraryIssueUpdateWithWhereUniqueWithoutCopyInput | LibraryIssueUpdateWithWhereUniqueWithoutCopyInput[]
    updateMany?: LibraryIssueUpdateManyWithWhereWithoutCopyInput | LibraryIssueUpdateManyWithWhereWithoutCopyInput[]
    deleteMany?: LibraryIssueScalarWhereInput | LibraryIssueScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutLibraryIssuesInput = {
    create?: XOR<StudentCreateWithoutLibraryIssuesInput, StudentUncheckedCreateWithoutLibraryIssuesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLibraryIssuesInput
    connect?: StudentWhereUniqueInput
  }

  export type LibraryCopyCreateNestedOneWithoutIssuesInput = {
    create?: XOR<LibraryCopyCreateWithoutIssuesInput, LibraryCopyUncheckedCreateWithoutIssuesInput>
    connectOrCreate?: LibraryCopyCreateOrConnectWithoutIssuesInput
    connect?: LibraryCopyWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumLibraryIssueStatusFieldUpdateOperationsInput = {
    set?: $Enums.LibraryIssueStatus
  }

  export type StudentUpdateOneRequiredWithoutLibraryIssuesNestedInput = {
    create?: XOR<StudentCreateWithoutLibraryIssuesInput, StudentUncheckedCreateWithoutLibraryIssuesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLibraryIssuesInput
    upsert?: StudentUpsertWithoutLibraryIssuesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutLibraryIssuesInput, StudentUpdateWithoutLibraryIssuesInput>, StudentUncheckedUpdateWithoutLibraryIssuesInput>
  }

  export type LibraryCopyUpdateOneRequiredWithoutIssuesNestedInput = {
    create?: XOR<LibraryCopyCreateWithoutIssuesInput, LibraryCopyUncheckedCreateWithoutIssuesInput>
    connectOrCreate?: LibraryCopyCreateOrConnectWithoutIssuesInput
    upsert?: LibraryCopyUpsertWithoutIssuesInput
    connect?: LibraryCopyWhereUniqueInput
    update?: XOR<XOR<LibraryCopyUpdateToOneWithWhereWithoutIssuesInput, LibraryCopyUpdateWithoutIssuesInput>, LibraryCopyUncheckedUpdateWithoutIssuesInput>
  }

  export type StudentCreateNestedOneWithoutRequestsInput = {
    create?: XOR<StudentCreateWithoutRequestsInput, StudentUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutRequestsInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type StudentUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<StudentCreateWithoutRequestsInput, StudentUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutRequestsInput
    upsert?: StudentUpsertWithoutRequestsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutRequestsInput, StudentUpdateWithoutRequestsInput>, StudentUncheckedUpdateWithoutRequestsInput>
  }

  export type StudentCreateNestedOneWithoutSettingsInput = {
    create?: XOR<StudentCreateWithoutSettingsInput, StudentUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSettingsInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumThemeFieldUpdateOperationsInput = {
    set?: $Enums.Theme
  }

  export type EnumProfileVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.ProfileVisibility
  }

  export type StudentUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<StudentCreateWithoutSettingsInput, StudentUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSettingsInput
    upsert?: StudentUpsertWithoutSettingsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutSettingsInput, StudentUpdateWithoutSettingsInput>, StudentUncheckedUpdateWithoutSettingsInput>
  }

  export type StudentCreateNestedOneWithoutFeeAccountInput = {
    create?: XOR<StudentCreateWithoutFeeAccountInput, StudentUncheckedCreateWithoutFeeAccountInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeeAccountInput
    connect?: StudentWhereUniqueInput
  }

  export type FeeChargeCreateNestedManyWithoutFeeAccountInput = {
    create?: XOR<FeeChargeCreateWithoutFeeAccountInput, FeeChargeUncheckedCreateWithoutFeeAccountInput> | FeeChargeCreateWithoutFeeAccountInput[] | FeeChargeUncheckedCreateWithoutFeeAccountInput[]
    connectOrCreate?: FeeChargeCreateOrConnectWithoutFeeAccountInput | FeeChargeCreateOrConnectWithoutFeeAccountInput[]
    createMany?: FeeChargeCreateManyFeeAccountInputEnvelope
    connect?: FeeChargeWhereUniqueInput | FeeChargeWhereUniqueInput[]
  }

  export type FeePaymentCreateNestedManyWithoutFeeAccountInput = {
    create?: XOR<FeePaymentCreateWithoutFeeAccountInput, FeePaymentUncheckedCreateWithoutFeeAccountInput> | FeePaymentCreateWithoutFeeAccountInput[] | FeePaymentUncheckedCreateWithoutFeeAccountInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeAccountInput | FeePaymentCreateOrConnectWithoutFeeAccountInput[]
    createMany?: FeePaymentCreateManyFeeAccountInputEnvelope
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type FeeChargeUncheckedCreateNestedManyWithoutFeeAccountInput = {
    create?: XOR<FeeChargeCreateWithoutFeeAccountInput, FeeChargeUncheckedCreateWithoutFeeAccountInput> | FeeChargeCreateWithoutFeeAccountInput[] | FeeChargeUncheckedCreateWithoutFeeAccountInput[]
    connectOrCreate?: FeeChargeCreateOrConnectWithoutFeeAccountInput | FeeChargeCreateOrConnectWithoutFeeAccountInput[]
    createMany?: FeeChargeCreateManyFeeAccountInputEnvelope
    connect?: FeeChargeWhereUniqueInput | FeeChargeWhereUniqueInput[]
  }

  export type FeePaymentUncheckedCreateNestedManyWithoutFeeAccountInput = {
    create?: XOR<FeePaymentCreateWithoutFeeAccountInput, FeePaymentUncheckedCreateWithoutFeeAccountInput> | FeePaymentCreateWithoutFeeAccountInput[] | FeePaymentUncheckedCreateWithoutFeeAccountInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeAccountInput | FeePaymentCreateOrConnectWithoutFeeAccountInput[]
    createMany?: FeePaymentCreateManyFeeAccountInputEnvelope
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type StudentUpdateOneRequiredWithoutFeeAccountNestedInput = {
    create?: XOR<StudentCreateWithoutFeeAccountInput, StudentUncheckedCreateWithoutFeeAccountInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeeAccountInput
    upsert?: StudentUpsertWithoutFeeAccountInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFeeAccountInput, StudentUpdateWithoutFeeAccountInput>, StudentUncheckedUpdateWithoutFeeAccountInput>
  }

  export type FeeChargeUpdateManyWithoutFeeAccountNestedInput = {
    create?: XOR<FeeChargeCreateWithoutFeeAccountInput, FeeChargeUncheckedCreateWithoutFeeAccountInput> | FeeChargeCreateWithoutFeeAccountInput[] | FeeChargeUncheckedCreateWithoutFeeAccountInput[]
    connectOrCreate?: FeeChargeCreateOrConnectWithoutFeeAccountInput | FeeChargeCreateOrConnectWithoutFeeAccountInput[]
    upsert?: FeeChargeUpsertWithWhereUniqueWithoutFeeAccountInput | FeeChargeUpsertWithWhereUniqueWithoutFeeAccountInput[]
    createMany?: FeeChargeCreateManyFeeAccountInputEnvelope
    set?: FeeChargeWhereUniqueInput | FeeChargeWhereUniqueInput[]
    disconnect?: FeeChargeWhereUniqueInput | FeeChargeWhereUniqueInput[]
    delete?: FeeChargeWhereUniqueInput | FeeChargeWhereUniqueInput[]
    connect?: FeeChargeWhereUniqueInput | FeeChargeWhereUniqueInput[]
    update?: FeeChargeUpdateWithWhereUniqueWithoutFeeAccountInput | FeeChargeUpdateWithWhereUniqueWithoutFeeAccountInput[]
    updateMany?: FeeChargeUpdateManyWithWhereWithoutFeeAccountInput | FeeChargeUpdateManyWithWhereWithoutFeeAccountInput[]
    deleteMany?: FeeChargeScalarWhereInput | FeeChargeScalarWhereInput[]
  }

  export type FeePaymentUpdateManyWithoutFeeAccountNestedInput = {
    create?: XOR<FeePaymentCreateWithoutFeeAccountInput, FeePaymentUncheckedCreateWithoutFeeAccountInput> | FeePaymentCreateWithoutFeeAccountInput[] | FeePaymentUncheckedCreateWithoutFeeAccountInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeAccountInput | FeePaymentCreateOrConnectWithoutFeeAccountInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutFeeAccountInput | FeePaymentUpsertWithWhereUniqueWithoutFeeAccountInput[]
    createMany?: FeePaymentCreateManyFeeAccountInputEnvelope
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutFeeAccountInput | FeePaymentUpdateWithWhereUniqueWithoutFeeAccountInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutFeeAccountInput | FeePaymentUpdateManyWithWhereWithoutFeeAccountInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type FeeChargeUncheckedUpdateManyWithoutFeeAccountNestedInput = {
    create?: XOR<FeeChargeCreateWithoutFeeAccountInput, FeeChargeUncheckedCreateWithoutFeeAccountInput> | FeeChargeCreateWithoutFeeAccountInput[] | FeeChargeUncheckedCreateWithoutFeeAccountInput[]
    connectOrCreate?: FeeChargeCreateOrConnectWithoutFeeAccountInput | FeeChargeCreateOrConnectWithoutFeeAccountInput[]
    upsert?: FeeChargeUpsertWithWhereUniqueWithoutFeeAccountInput | FeeChargeUpsertWithWhereUniqueWithoutFeeAccountInput[]
    createMany?: FeeChargeCreateManyFeeAccountInputEnvelope
    set?: FeeChargeWhereUniqueInput | FeeChargeWhereUniqueInput[]
    disconnect?: FeeChargeWhereUniqueInput | FeeChargeWhereUniqueInput[]
    delete?: FeeChargeWhereUniqueInput | FeeChargeWhereUniqueInput[]
    connect?: FeeChargeWhereUniqueInput | FeeChargeWhereUniqueInput[]
    update?: FeeChargeUpdateWithWhereUniqueWithoutFeeAccountInput | FeeChargeUpdateWithWhereUniqueWithoutFeeAccountInput[]
    updateMany?: FeeChargeUpdateManyWithWhereWithoutFeeAccountInput | FeeChargeUpdateManyWithWhereWithoutFeeAccountInput[]
    deleteMany?: FeeChargeScalarWhereInput | FeeChargeScalarWhereInput[]
  }

  export type FeePaymentUncheckedUpdateManyWithoutFeeAccountNestedInput = {
    create?: XOR<FeePaymentCreateWithoutFeeAccountInput, FeePaymentUncheckedCreateWithoutFeeAccountInput> | FeePaymentCreateWithoutFeeAccountInput[] | FeePaymentUncheckedCreateWithoutFeeAccountInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeAccountInput | FeePaymentCreateOrConnectWithoutFeeAccountInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutFeeAccountInput | FeePaymentUpsertWithWhereUniqueWithoutFeeAccountInput[]
    createMany?: FeePaymentCreateManyFeeAccountInputEnvelope
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutFeeAccountInput | FeePaymentUpdateWithWhereUniqueWithoutFeeAccountInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutFeeAccountInput | FeePaymentUpdateManyWithWhereWithoutFeeAccountInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type FeeAccountCreateNestedOneWithoutChargesInput = {
    create?: XOR<FeeAccountCreateWithoutChargesInput, FeeAccountUncheckedCreateWithoutChargesInput>
    connectOrCreate?: FeeAccountCreateOrConnectWithoutChargesInput
    connect?: FeeAccountWhereUniqueInput
  }

  export type FeeAccountUpdateOneRequiredWithoutChargesNestedInput = {
    create?: XOR<FeeAccountCreateWithoutChargesInput, FeeAccountUncheckedCreateWithoutChargesInput>
    connectOrCreate?: FeeAccountCreateOrConnectWithoutChargesInput
    upsert?: FeeAccountUpsertWithoutChargesInput
    connect?: FeeAccountWhereUniqueInput
    update?: XOR<XOR<FeeAccountUpdateToOneWithWhereWithoutChargesInput, FeeAccountUpdateWithoutChargesInput>, FeeAccountUncheckedUpdateWithoutChargesInput>
  }

  export type FeeAccountCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<FeeAccountCreateWithoutPaymentsInput, FeeAccountUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: FeeAccountCreateOrConnectWithoutPaymentsInput
    connect?: FeeAccountWhereUniqueInput
  }

  export type FeeAccountUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<FeeAccountCreateWithoutPaymentsInput, FeeAccountUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: FeeAccountCreateOrConnectWithoutPaymentsInput
    upsert?: FeeAccountUpsertWithoutPaymentsInput
    connect?: FeeAccountWhereUniqueInput
    update?: XOR<XOR<FeeAccountUpdateToOneWithWhereWithoutPaymentsInput, FeeAccountUpdateWithoutPaymentsInput>, FeeAccountUncheckedUpdateWithoutPaymentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAttendanceMarkStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceMarkStatus | EnumAttendanceMarkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceMarkStatus[]
    notIn?: $Enums.AttendanceMarkStatus[]
    not?: NestedEnumAttendanceMarkStatusFilter<$PrismaModel> | $Enums.AttendanceMarkStatus
  }

  export type NestedEnumAttendanceMarkStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceMarkStatus | EnumAttendanceMarkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceMarkStatus[]
    notIn?: $Enums.AttendanceMarkStatus[]
    not?: NestedEnumAttendanceMarkStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceMarkStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceMarkStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceMarkStatusFilter<$PrismaModel>
  }

  export type NestedEnumLibraryCopyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryCopyStatus | EnumLibraryCopyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryCopyStatus[]
    notIn?: $Enums.LibraryCopyStatus[]
    not?: NestedEnumLibraryCopyStatusFilter<$PrismaModel> | $Enums.LibraryCopyStatus
  }

  export type NestedEnumLibraryCopyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryCopyStatus | EnumLibraryCopyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryCopyStatus[]
    notIn?: $Enums.LibraryCopyStatus[]
    not?: NestedEnumLibraryCopyStatusWithAggregatesFilter<$PrismaModel> | $Enums.LibraryCopyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLibraryCopyStatusFilter<$PrismaModel>
    _max?: NestedEnumLibraryCopyStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumLibraryIssueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryIssueStatus | EnumLibraryIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryIssueStatus[]
    notIn?: $Enums.LibraryIssueStatus[]
    not?: NestedEnumLibraryIssueStatusFilter<$PrismaModel> | $Enums.LibraryIssueStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLibraryIssueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LibraryIssueStatus | EnumLibraryIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LibraryIssueStatus[]
    notIn?: $Enums.LibraryIssueStatus[]
    not?: NestedEnumLibraryIssueStatusWithAggregatesFilter<$PrismaModel> | $Enums.LibraryIssueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLibraryIssueStatusFilter<$PrismaModel>
    _max?: NestedEnumLibraryIssueStatusFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[]
    notIn?: $Enums.RequestStatus[]
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[]
    notIn?: $Enums.RequestStatus[]
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumThemeFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[]
    notIn?: $Enums.Theme[]
    not?: NestedEnumThemeFilter<$PrismaModel> | $Enums.Theme
  }

  export type NestedEnumProfileVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileVisibility | EnumProfileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileVisibility[]
    notIn?: $Enums.ProfileVisibility[]
    not?: NestedEnumProfileVisibilityFilter<$PrismaModel> | $Enums.ProfileVisibility
  }

  export type NestedEnumThemeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[]
    notIn?: $Enums.Theme[]
    not?: NestedEnumThemeWithAggregatesFilter<$PrismaModel> | $Enums.Theme
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThemeFilter<$PrismaModel>
    _max?: NestedEnumThemeFilter<$PrismaModel>
  }

  export type NestedEnumProfileVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileVisibility | EnumProfileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileVisibility[]
    notIn?: $Enums.ProfileVisibility[]
    not?: NestedEnumProfileVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ProfileVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProfileVisibilityFilter<$PrismaModel>
    _max?: NestedEnumProfileVisibilityFilter<$PrismaModel>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueCreateNestedManyWithoutStudentInput
    requests?: RequestCreateNestedManyWithoutStudentInput
    settings?: StudentSettingCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    displayId: string
    fullName: string
    programId: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkUncheckedCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueUncheckedCreateNestedManyWithoutStudentInput
    requests?: RequestUncheckedCreateNestedManyWithoutStudentInput
    settings?: StudentSettingUncheckedCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type FacultyProfileCreateWithoutUserInput = {
    id?: string
    fullName?: string | null
    employeeCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutFacultyInput
    designation?: DesignationCreateNestedOneWithoutFacultyInput
    offerings?: CourseOfferingCreateNestedManyWithoutFacultyInput
    subjects?: FacultySubjectCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileUncheckedCreateWithoutUserInput = {
    id?: string
    fullName?: string | null
    employeeCode?: string | null
    departmentId?: string | null
    designationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: CourseOfferingUncheckedCreateNestedManyWithoutFacultyInput
    subjects?: FacultySubjectUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileCreateOrConnectWithoutUserInput = {
    where: FacultyProfileWhereUniqueInput
    create: XOR<FacultyProfileCreateWithoutUserInput, FacultyProfileUncheckedCreateWithoutUserInput>
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUpdateManyWithoutStudentNestedInput
    requests?: RequestUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUncheckedUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUncheckedUpdateManyWithoutStudentNestedInput
    requests?: RequestUncheckedUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUncheckedUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type FacultyProfileUpsertWithoutUserInput = {
    update: XOR<FacultyProfileUpdateWithoutUserInput, FacultyProfileUncheckedUpdateWithoutUserInput>
    create: XOR<FacultyProfileCreateWithoutUserInput, FacultyProfileUncheckedCreateWithoutUserInput>
    where?: FacultyProfileWhereInput
  }

  export type FacultyProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: FacultyProfileWhereInput
    data: XOR<FacultyProfileUpdateWithoutUserInput, FacultyProfileUncheckedUpdateWithoutUserInput>
  }

  export type FacultyProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutFacultyNestedInput
    designation?: DesignationUpdateOneWithoutFacultyNestedInput
    offerings?: CourseOfferingUpdateManyWithoutFacultyNestedInput
    subjects?: FacultySubjectUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: CourseOfferingUncheckedUpdateManyWithoutFacultyNestedInput
    subjects?: FacultySubjectUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type StudentCreateWithoutProgramInput = {
    id?: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueCreateNestedManyWithoutStudentInput
    requests?: RequestCreateNestedManyWithoutStudentInput
    settings?: StudentSettingCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutProgramInput = {
    id?: string
    userId: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkUncheckedCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueUncheckedCreateNestedManyWithoutStudentInput
    requests?: RequestUncheckedCreateNestedManyWithoutStudentInput
    settings?: StudentSettingUncheckedCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutProgramInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput>
  }

  export type StudentCreateManyProgramInputEnvelope = {
    data: StudentCreateManyProgramInput | StudentCreateManyProgramInput[]
  }

  export type StudentUpsertWithWhereUniqueWithoutProgramInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutProgramInput, StudentUncheckedUpdateWithoutProgramInput>
    create: XOR<StudentCreateWithoutProgramInput, StudentUncheckedCreateWithoutProgramInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutProgramInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutProgramInput, StudentUncheckedUpdateWithoutProgramInput>
  }

  export type StudentUpdateManyWithWhereWithoutProgramInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutProgramInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    displayId?: StringFilter<"Student"> | string
    fullName?: StringFilter<"Student"> | string
    programId?: StringFilter<"Student"> | string
    semester?: IntFilter<"Student"> | number
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    role: $Enums.UserRole
    email?: string | null
    phone?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty?: FacultyProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    role: $Enums.UserRole
    email?: string | null
    phone?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty?: FacultyProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type ProgramCreateWithoutStudentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramCreateOrConnectWithoutStudentsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutStudentsInput, ProgramUncheckedCreateWithoutStudentsInput>
  }

  export type EnrollmentCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offering: CourseOfferingCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    offeringId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type EnrollmentCreateManyStudentInputEnvelope = {
    data: EnrollmentCreateManyStudentInput | EnrollmentCreateManyStudentInput[]
  }

  export type AttendanceMarkCreateWithoutStudentInput = {
    id?: string
    status: $Enums.AttendanceMarkStatus
    note?: string | null
    createdAt?: Date | string
    session: AttendanceSessionCreateNestedOneWithoutMarksInput
  }

  export type AttendanceMarkUncheckedCreateWithoutStudentInput = {
    id?: string
    sessionId: string
    status: $Enums.AttendanceMarkStatus
    note?: string | null
    createdAt?: Date | string
  }

  export type AttendanceMarkCreateOrConnectWithoutStudentInput = {
    where: AttendanceMarkWhereUniqueInput
    create: XOR<AttendanceMarkCreateWithoutStudentInput, AttendanceMarkUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceMarkCreateManyStudentInputEnvelope = {
    data: AttendanceMarkCreateManyStudentInput | AttendanceMarkCreateManyStudentInput[]
  }

  export type LibraryIssueCreateWithoutStudentInput = {
    id?: string
    issueDate: Date | string
    dueDate: Date | string
    returnDate?: Date | string | null
    status?: $Enums.LibraryIssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    copy: LibraryCopyCreateNestedOneWithoutIssuesInput
  }

  export type LibraryIssueUncheckedCreateWithoutStudentInput = {
    id?: string
    copyId: string
    issueDate: Date | string
    dueDate: Date | string
    returnDate?: Date | string | null
    status?: $Enums.LibraryIssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryIssueCreateOrConnectWithoutStudentInput = {
    where: LibraryIssueWhereUniqueInput
    create: XOR<LibraryIssueCreateWithoutStudentInput, LibraryIssueUncheckedCreateWithoutStudentInput>
  }

  export type LibraryIssueCreateManyStudentInputEnvelope = {
    data: LibraryIssueCreateManyStudentInput | LibraryIssueCreateManyStudentInput[]
  }

  export type RequestCreateWithoutStudentInput = {
    id?: string
    displayId: string
    title: string
    description?: string | null
    status?: $Enums.RequestStatus
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestUncheckedCreateWithoutStudentInput = {
    id?: string
    displayId: string
    title: string
    description?: string | null
    status?: $Enums.RequestStatus
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCreateOrConnectWithoutStudentInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutStudentInput, RequestUncheckedCreateWithoutStudentInput>
  }

  export type RequestCreateManyStudentInputEnvelope = {
    data: RequestCreateManyStudentInput | RequestCreateManyStudentInput[]
  }

  export type StudentSettingCreateWithoutStudentInput = {
    id?: string
    theme?: $Enums.Theme
    notificationsEnabled?: boolean
    language?: string
    profileVisibility?: $Enums.ProfileVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSettingUncheckedCreateWithoutStudentInput = {
    id?: string
    theme?: $Enums.Theme
    notificationsEnabled?: boolean
    language?: string
    profileVisibility?: $Enums.ProfileVisibility
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSettingCreateOrConnectWithoutStudentInput = {
    where: StudentSettingWhereUniqueInput
    create: XOR<StudentSettingCreateWithoutStudentInput, StudentSettingUncheckedCreateWithoutStudentInput>
  }

  export type FeeAccountCreateWithoutStudentInput = {
    id?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    charges?: FeeChargeCreateNestedManyWithoutFeeAccountInput
    payments?: FeePaymentCreateNestedManyWithoutFeeAccountInput
  }

  export type FeeAccountUncheckedCreateWithoutStudentInput = {
    id?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    charges?: FeeChargeUncheckedCreateNestedManyWithoutFeeAccountInput
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeAccountInput
  }

  export type FeeAccountCreateOrConnectWithoutStudentInput = {
    where: FeeAccountWhereUniqueInput
    create: XOR<FeeAccountCreateWithoutStudentInput, FeeAccountUncheckedCreateWithoutStudentInput>
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProgramUpsertWithoutStudentsInput = {
    update: XOR<ProgramUpdateWithoutStudentsInput, ProgramUncheckedUpdateWithoutStudentsInput>
    create: XOR<ProgramCreateWithoutStudentsInput, ProgramUncheckedCreateWithoutStudentsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutStudentsInput, ProgramUncheckedUpdateWithoutStudentsInput>
  }

  export type ProgramUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutStudentInput, EnrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutStudentInput, EnrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    studentId?: StringFilter<"Enrollment"> | string
    offeringId?: StringFilter<"Enrollment"> | string
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
  }

  export type AttendanceMarkUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceMarkWhereUniqueInput
    update: XOR<AttendanceMarkUpdateWithoutStudentInput, AttendanceMarkUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceMarkCreateWithoutStudentInput, AttendanceMarkUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceMarkUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceMarkWhereUniqueInput
    data: XOR<AttendanceMarkUpdateWithoutStudentInput, AttendanceMarkUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceMarkUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceMarkScalarWhereInput
    data: XOR<AttendanceMarkUpdateManyMutationInput, AttendanceMarkUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceMarkScalarWhereInput = {
    AND?: AttendanceMarkScalarWhereInput | AttendanceMarkScalarWhereInput[]
    OR?: AttendanceMarkScalarWhereInput[]
    NOT?: AttendanceMarkScalarWhereInput | AttendanceMarkScalarWhereInput[]
    id?: StringFilter<"AttendanceMark"> | string
    sessionId?: StringFilter<"AttendanceMark"> | string
    studentId?: StringFilter<"AttendanceMark"> | string
    status?: EnumAttendanceMarkStatusFilter<"AttendanceMark"> | $Enums.AttendanceMarkStatus
    note?: StringNullableFilter<"AttendanceMark"> | string | null
    createdAt?: DateTimeFilter<"AttendanceMark"> | Date | string
  }

  export type LibraryIssueUpsertWithWhereUniqueWithoutStudentInput = {
    where: LibraryIssueWhereUniqueInput
    update: XOR<LibraryIssueUpdateWithoutStudentInput, LibraryIssueUncheckedUpdateWithoutStudentInput>
    create: XOR<LibraryIssueCreateWithoutStudentInput, LibraryIssueUncheckedCreateWithoutStudentInput>
  }

  export type LibraryIssueUpdateWithWhereUniqueWithoutStudentInput = {
    where: LibraryIssueWhereUniqueInput
    data: XOR<LibraryIssueUpdateWithoutStudentInput, LibraryIssueUncheckedUpdateWithoutStudentInput>
  }

  export type LibraryIssueUpdateManyWithWhereWithoutStudentInput = {
    where: LibraryIssueScalarWhereInput
    data: XOR<LibraryIssueUpdateManyMutationInput, LibraryIssueUncheckedUpdateManyWithoutStudentInput>
  }

  export type LibraryIssueScalarWhereInput = {
    AND?: LibraryIssueScalarWhereInput | LibraryIssueScalarWhereInput[]
    OR?: LibraryIssueScalarWhereInput[]
    NOT?: LibraryIssueScalarWhereInput | LibraryIssueScalarWhereInput[]
    id?: StringFilter<"LibraryIssue"> | string
    studentId?: StringFilter<"LibraryIssue"> | string
    copyId?: StringFilter<"LibraryIssue"> | string
    issueDate?: DateTimeFilter<"LibraryIssue"> | Date | string
    dueDate?: DateTimeFilter<"LibraryIssue"> | Date | string
    returnDate?: DateTimeNullableFilter<"LibraryIssue"> | Date | string | null
    status?: EnumLibraryIssueStatusFilter<"LibraryIssue"> | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFilter<"LibraryIssue"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryIssue"> | Date | string
  }

  export type RequestUpsertWithWhereUniqueWithoutStudentInput = {
    where: RequestWhereUniqueInput
    update: XOR<RequestUpdateWithoutStudentInput, RequestUncheckedUpdateWithoutStudentInput>
    create: XOR<RequestCreateWithoutStudentInput, RequestUncheckedCreateWithoutStudentInput>
  }

  export type RequestUpdateWithWhereUniqueWithoutStudentInput = {
    where: RequestWhereUniqueInput
    data: XOR<RequestUpdateWithoutStudentInput, RequestUncheckedUpdateWithoutStudentInput>
  }

  export type RequestUpdateManyWithWhereWithoutStudentInput = {
    where: RequestScalarWhereInput
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyWithoutStudentInput>
  }

  export type RequestScalarWhereInput = {
    AND?: RequestScalarWhereInput | RequestScalarWhereInput[]
    OR?: RequestScalarWhereInput[]
    NOT?: RequestScalarWhereInput | RequestScalarWhereInput[]
    id?: StringFilter<"Request"> | string
    displayId?: StringFilter<"Request"> | string
    studentId?: StringFilter<"Request"> | string
    title?: StringFilter<"Request"> | string
    description?: StringNullableFilter<"Request"> | string | null
    status?: EnumRequestStatusFilter<"Request"> | $Enums.RequestStatus
    submittedAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
  }

  export type StudentSettingUpsertWithoutStudentInput = {
    update: XOR<StudentSettingUpdateWithoutStudentInput, StudentSettingUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSettingCreateWithoutStudentInput, StudentSettingUncheckedCreateWithoutStudentInput>
    where?: StudentSettingWhereInput
  }

  export type StudentSettingUpdateToOneWithWhereWithoutStudentInput = {
    where?: StudentSettingWhereInput
    data: XOR<StudentSettingUpdateWithoutStudentInput, StudentSettingUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSettingUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    profileVisibility?: EnumProfileVisibilityFieldUpdateOperationsInput | $Enums.ProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSettingUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    profileVisibility?: EnumProfileVisibilityFieldUpdateOperationsInput | $Enums.ProfileVisibility
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeAccountUpsertWithoutStudentInput = {
    update: XOR<FeeAccountUpdateWithoutStudentInput, FeeAccountUncheckedUpdateWithoutStudentInput>
    create: XOR<FeeAccountCreateWithoutStudentInput, FeeAccountUncheckedCreateWithoutStudentInput>
    where?: FeeAccountWhereInput
  }

  export type FeeAccountUpdateToOneWithWhereWithoutStudentInput = {
    where?: FeeAccountWhereInput
    data: XOR<FeeAccountUpdateWithoutStudentInput, FeeAccountUncheckedUpdateWithoutStudentInput>
  }

  export type FeeAccountUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    charges?: FeeChargeUpdateManyWithoutFeeAccountNestedInput
    payments?: FeePaymentUpdateManyWithoutFeeAccountNestedInput
  }

  export type FeeAccountUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    charges?: FeeChargeUncheckedUpdateManyWithoutFeeAccountNestedInput
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeAccountNestedInput
  }

  export type UserCreateWithoutFacultyInput = {
    id?: string
    role: $Enums.UserRole
    email?: string | null
    phone?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFacultyInput = {
    id?: string
    role: $Enums.UserRole
    email?: string | null
    phone?: string | null
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFacultyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFacultyInput, UserUncheckedCreateWithoutFacultyInput>
  }

  export type DepartmentCreateWithoutFacultyInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    designations?: DesignationCreateNestedManyWithoutDepartmentInput
    subjects?: SubjectCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutFacultyInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    designations?: DesignationUncheckedCreateNestedManyWithoutDepartmentInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutFacultyInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
  }

  export type DesignationCreateWithoutFacultyInput = {
    id?: string
    title: string
    level?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutDesignationsInput
  }

  export type DesignationUncheckedCreateWithoutFacultyInput = {
    id?: string
    departmentId: string
    title: string
    level?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignationCreateOrConnectWithoutFacultyInput = {
    where: DesignationWhereUniqueInput
    create: XOR<DesignationCreateWithoutFacultyInput, DesignationUncheckedCreateWithoutFacultyInput>
  }

  export type CourseOfferingCreateWithoutFacultyInput = {
    id?: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutOfferingsInput
    enrollments?: EnrollmentCreateNestedManyWithoutOfferingInput
    sessions?: AttendanceSessionCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutFacultyInput = {
    id?: string
    courseId: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutOfferingInput
    sessions?: AttendanceSessionUncheckedCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutFacultyInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutFacultyInput, CourseOfferingUncheckedCreateWithoutFacultyInput>
  }

  export type CourseOfferingCreateManyFacultyInputEnvelope = {
    data: CourseOfferingCreateManyFacultyInput | CourseOfferingCreateManyFacultyInput[]
  }

  export type FacultySubjectCreateWithoutFacultyInput = {
    id?: string
    createdAt?: Date | string
    subject: SubjectCreateNestedOneWithoutFacultyInput
  }

  export type FacultySubjectUncheckedCreateWithoutFacultyInput = {
    id?: string
    subjectId: string
    createdAt?: Date | string
  }

  export type FacultySubjectCreateOrConnectWithoutFacultyInput = {
    where: FacultySubjectWhereUniqueInput
    create: XOR<FacultySubjectCreateWithoutFacultyInput, FacultySubjectUncheckedCreateWithoutFacultyInput>
  }

  export type FacultySubjectCreateManyFacultyInputEnvelope = {
    data: FacultySubjectCreateManyFacultyInput | FacultySubjectCreateManyFacultyInput[]
  }

  export type UserUpsertWithoutFacultyInput = {
    update: XOR<UserUpdateWithoutFacultyInput, UserUncheckedUpdateWithoutFacultyInput>
    create: XOR<UserCreateWithoutFacultyInput, UserUncheckedCreateWithoutFacultyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFacultyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFacultyInput, UserUncheckedUpdateWithoutFacultyInput>
  }

  export type UserUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type DepartmentUpsertWithoutFacultyInput = {
    update: XOR<DepartmentUpdateWithoutFacultyInput, DepartmentUncheckedUpdateWithoutFacultyInput>
    create: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutFacultyInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutFacultyInput, DepartmentUncheckedUpdateWithoutFacultyInput>
  }

  export type DepartmentUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designations?: DesignationUpdateManyWithoutDepartmentNestedInput
    subjects?: SubjectUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designations?: DesignationUncheckedUpdateManyWithoutDepartmentNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DesignationUpsertWithoutFacultyInput = {
    update: XOR<DesignationUpdateWithoutFacultyInput, DesignationUncheckedUpdateWithoutFacultyInput>
    create: XOR<DesignationCreateWithoutFacultyInput, DesignationUncheckedCreateWithoutFacultyInput>
    where?: DesignationWhereInput
  }

  export type DesignationUpdateToOneWithWhereWithoutFacultyInput = {
    where?: DesignationWhereInput
    data: XOR<DesignationUpdateWithoutFacultyInput, DesignationUncheckedUpdateWithoutFacultyInput>
  }

  export type DesignationUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutDesignationsNestedInput
  }

  export type DesignationUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseOfferingUpsertWithWhereUniqueWithoutFacultyInput = {
    where: CourseOfferingWhereUniqueInput
    update: XOR<CourseOfferingUpdateWithoutFacultyInput, CourseOfferingUncheckedUpdateWithoutFacultyInput>
    create: XOR<CourseOfferingCreateWithoutFacultyInput, CourseOfferingUncheckedCreateWithoutFacultyInput>
  }

  export type CourseOfferingUpdateWithWhereUniqueWithoutFacultyInput = {
    where: CourseOfferingWhereUniqueInput
    data: XOR<CourseOfferingUpdateWithoutFacultyInput, CourseOfferingUncheckedUpdateWithoutFacultyInput>
  }

  export type CourseOfferingUpdateManyWithWhereWithoutFacultyInput = {
    where: CourseOfferingScalarWhereInput
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyWithoutFacultyInput>
  }

  export type CourseOfferingScalarWhereInput = {
    AND?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
    OR?: CourseOfferingScalarWhereInput[]
    NOT?: CourseOfferingScalarWhereInput | CourseOfferingScalarWhereInput[]
    id?: StringFilter<"CourseOffering"> | string
    courseId?: StringFilter<"CourseOffering"> | string
    facultyId?: StringFilter<"CourseOffering"> | string
    semester?: IntFilter<"CourseOffering"> | number
    academicYear?: StringNullableFilter<"CourseOffering"> | string | null
    term?: StringNullableFilter<"CourseOffering"> | string | null
    createdAt?: DateTimeFilter<"CourseOffering"> | Date | string
    updatedAt?: DateTimeFilter<"CourseOffering"> | Date | string
  }

  export type FacultySubjectUpsertWithWhereUniqueWithoutFacultyInput = {
    where: FacultySubjectWhereUniqueInput
    update: XOR<FacultySubjectUpdateWithoutFacultyInput, FacultySubjectUncheckedUpdateWithoutFacultyInput>
    create: XOR<FacultySubjectCreateWithoutFacultyInput, FacultySubjectUncheckedCreateWithoutFacultyInput>
  }

  export type FacultySubjectUpdateWithWhereUniqueWithoutFacultyInput = {
    where: FacultySubjectWhereUniqueInput
    data: XOR<FacultySubjectUpdateWithoutFacultyInput, FacultySubjectUncheckedUpdateWithoutFacultyInput>
  }

  export type FacultySubjectUpdateManyWithWhereWithoutFacultyInput = {
    where: FacultySubjectScalarWhereInput
    data: XOR<FacultySubjectUpdateManyMutationInput, FacultySubjectUncheckedUpdateManyWithoutFacultyInput>
  }

  export type FacultySubjectScalarWhereInput = {
    AND?: FacultySubjectScalarWhereInput | FacultySubjectScalarWhereInput[]
    OR?: FacultySubjectScalarWhereInput[]
    NOT?: FacultySubjectScalarWhereInput | FacultySubjectScalarWhereInput[]
    id?: StringFilter<"FacultySubject"> | string
    facultyId?: StringFilter<"FacultySubject"> | string
    subjectId?: StringFilter<"FacultySubject"> | string
    createdAt?: DateTimeFilter<"FacultySubject"> | Date | string
  }

  export type DesignationCreateWithoutDepartmentInput = {
    id?: string
    title: string
    level?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty?: FacultyProfileCreateNestedManyWithoutDesignationInput
  }

  export type DesignationUncheckedCreateWithoutDepartmentInput = {
    id?: string
    title: string
    level?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty?: FacultyProfileUncheckedCreateNestedManyWithoutDesignationInput
  }

  export type DesignationCreateOrConnectWithoutDepartmentInput = {
    where: DesignationWhereUniqueInput
    create: XOR<DesignationCreateWithoutDepartmentInput, DesignationUncheckedCreateWithoutDepartmentInput>
  }

  export type DesignationCreateManyDepartmentInputEnvelope = {
    data: DesignationCreateManyDepartmentInput | DesignationCreateManyDepartmentInput[]
  }

  export type SubjectCreateWithoutDepartmentInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty?: FacultySubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty?: FacultySubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutDepartmentInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput>
  }

  export type SubjectCreateManyDepartmentInputEnvelope = {
    data: SubjectCreateManyDepartmentInput | SubjectCreateManyDepartmentInput[]
  }

  export type FacultyProfileCreateWithoutDepartmentInput = {
    id?: string
    fullName?: string | null
    employeeCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFacultyInput
    designation?: DesignationCreateNestedOneWithoutFacultyInput
    offerings?: CourseOfferingCreateNestedManyWithoutFacultyInput
    subjects?: FacultySubjectCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId: string
    fullName?: string | null
    employeeCode?: string | null
    designationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: CourseOfferingUncheckedCreateNestedManyWithoutFacultyInput
    subjects?: FacultySubjectUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileCreateOrConnectWithoutDepartmentInput = {
    where: FacultyProfileWhereUniqueInput
    create: XOR<FacultyProfileCreateWithoutDepartmentInput, FacultyProfileUncheckedCreateWithoutDepartmentInput>
  }

  export type FacultyProfileCreateManyDepartmentInputEnvelope = {
    data: FacultyProfileCreateManyDepartmentInput | FacultyProfileCreateManyDepartmentInput[]
  }

  export type DesignationUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DesignationWhereUniqueInput
    update: XOR<DesignationUpdateWithoutDepartmentInput, DesignationUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DesignationCreateWithoutDepartmentInput, DesignationUncheckedCreateWithoutDepartmentInput>
  }

  export type DesignationUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DesignationWhereUniqueInput
    data: XOR<DesignationUpdateWithoutDepartmentInput, DesignationUncheckedUpdateWithoutDepartmentInput>
  }

  export type DesignationUpdateManyWithWhereWithoutDepartmentInput = {
    where: DesignationScalarWhereInput
    data: XOR<DesignationUpdateManyMutationInput, DesignationUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DesignationScalarWhereInput = {
    AND?: DesignationScalarWhereInput | DesignationScalarWhereInput[]
    OR?: DesignationScalarWhereInput[]
    NOT?: DesignationScalarWhereInput | DesignationScalarWhereInput[]
    id?: StringFilter<"Designation"> | string
    departmentId?: StringFilter<"Designation"> | string
    title?: StringFilter<"Designation"> | string
    level?: IntNullableFilter<"Designation"> | number | null
    isActive?: BoolFilter<"Designation"> | boolean
    createdAt?: DateTimeFilter<"Designation"> | Date | string
    updatedAt?: DateTimeFilter<"Designation"> | Date | string
  }

  export type SubjectUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutDepartmentInput, SubjectUncheckedUpdateWithoutDepartmentInput>
    create: XOR<SubjectCreateWithoutDepartmentInput, SubjectUncheckedCreateWithoutDepartmentInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutDepartmentInput, SubjectUncheckedUpdateWithoutDepartmentInput>
  }

  export type SubjectUpdateManyWithWhereWithoutDepartmentInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    departmentId?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    isActive?: BoolFilter<"Subject"> | boolean
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
  }

  export type FacultyProfileUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: FacultyProfileWhereUniqueInput
    update: XOR<FacultyProfileUpdateWithoutDepartmentInput, FacultyProfileUncheckedUpdateWithoutDepartmentInput>
    create: XOR<FacultyProfileCreateWithoutDepartmentInput, FacultyProfileUncheckedCreateWithoutDepartmentInput>
  }

  export type FacultyProfileUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: FacultyProfileWhereUniqueInput
    data: XOR<FacultyProfileUpdateWithoutDepartmentInput, FacultyProfileUncheckedUpdateWithoutDepartmentInput>
  }

  export type FacultyProfileUpdateManyWithWhereWithoutDepartmentInput = {
    where: FacultyProfileScalarWhereInput
    data: XOR<FacultyProfileUpdateManyMutationInput, FacultyProfileUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type FacultyProfileScalarWhereInput = {
    AND?: FacultyProfileScalarWhereInput | FacultyProfileScalarWhereInput[]
    OR?: FacultyProfileScalarWhereInput[]
    NOT?: FacultyProfileScalarWhereInput | FacultyProfileScalarWhereInput[]
    id?: StringFilter<"FacultyProfile"> | string
    userId?: StringFilter<"FacultyProfile"> | string
    fullName?: StringNullableFilter<"FacultyProfile"> | string | null
    employeeCode?: StringNullableFilter<"FacultyProfile"> | string | null
    departmentId?: StringNullableFilter<"FacultyProfile"> | string | null
    designationId?: StringNullableFilter<"FacultyProfile"> | string | null
    createdAt?: DateTimeFilter<"FacultyProfile"> | Date | string
    updatedAt?: DateTimeFilter<"FacultyProfile"> | Date | string
  }

  export type DepartmentCreateWithoutDesignationsInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectCreateNestedManyWithoutDepartmentInput
    faculty?: FacultyProfileCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutDesignationsInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutDepartmentInput
    faculty?: FacultyProfileUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutDesignationsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutDesignationsInput, DepartmentUncheckedCreateWithoutDesignationsInput>
  }

  export type FacultyProfileCreateWithoutDesignationInput = {
    id?: string
    fullName?: string | null
    employeeCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFacultyInput
    department?: DepartmentCreateNestedOneWithoutFacultyInput
    offerings?: CourseOfferingCreateNestedManyWithoutFacultyInput
    subjects?: FacultySubjectCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileUncheckedCreateWithoutDesignationInput = {
    id?: string
    userId: string
    fullName?: string | null
    employeeCode?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: CourseOfferingUncheckedCreateNestedManyWithoutFacultyInput
    subjects?: FacultySubjectUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileCreateOrConnectWithoutDesignationInput = {
    where: FacultyProfileWhereUniqueInput
    create: XOR<FacultyProfileCreateWithoutDesignationInput, FacultyProfileUncheckedCreateWithoutDesignationInput>
  }

  export type FacultyProfileCreateManyDesignationInputEnvelope = {
    data: FacultyProfileCreateManyDesignationInput | FacultyProfileCreateManyDesignationInput[]
  }

  export type DepartmentUpsertWithoutDesignationsInput = {
    update: XOR<DepartmentUpdateWithoutDesignationsInput, DepartmentUncheckedUpdateWithoutDesignationsInput>
    create: XOR<DepartmentCreateWithoutDesignationsInput, DepartmentUncheckedCreateWithoutDesignationsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutDesignationsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutDesignationsInput, DepartmentUncheckedUpdateWithoutDesignationsInput>
  }

  export type DepartmentUpdateWithoutDesignationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUpdateManyWithoutDepartmentNestedInput
    faculty?: FacultyProfileUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutDesignationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutDepartmentNestedInput
    faculty?: FacultyProfileUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type FacultyProfileUpsertWithWhereUniqueWithoutDesignationInput = {
    where: FacultyProfileWhereUniqueInput
    update: XOR<FacultyProfileUpdateWithoutDesignationInput, FacultyProfileUncheckedUpdateWithoutDesignationInput>
    create: XOR<FacultyProfileCreateWithoutDesignationInput, FacultyProfileUncheckedCreateWithoutDesignationInput>
  }

  export type FacultyProfileUpdateWithWhereUniqueWithoutDesignationInput = {
    where: FacultyProfileWhereUniqueInput
    data: XOR<FacultyProfileUpdateWithoutDesignationInput, FacultyProfileUncheckedUpdateWithoutDesignationInput>
  }

  export type FacultyProfileUpdateManyWithWhereWithoutDesignationInput = {
    where: FacultyProfileScalarWhereInput
    data: XOR<FacultyProfileUpdateManyMutationInput, FacultyProfileUncheckedUpdateManyWithoutDesignationInput>
  }

  export type DepartmentCreateWithoutSubjectsInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    designations?: DesignationCreateNestedManyWithoutDepartmentInput
    faculty?: FacultyProfileCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    designations?: DesignationUncheckedCreateNestedManyWithoutDepartmentInput
    faculty?: FacultyProfileUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutSubjectsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutSubjectsInput, DepartmentUncheckedCreateWithoutSubjectsInput>
  }

  export type FacultySubjectCreateWithoutSubjectInput = {
    id?: string
    createdAt?: Date | string
    faculty: FacultyProfileCreateNestedOneWithoutSubjectsInput
  }

  export type FacultySubjectUncheckedCreateWithoutSubjectInput = {
    id?: string
    facultyId: string
    createdAt?: Date | string
  }

  export type FacultySubjectCreateOrConnectWithoutSubjectInput = {
    where: FacultySubjectWhereUniqueInput
    create: XOR<FacultySubjectCreateWithoutSubjectInput, FacultySubjectUncheckedCreateWithoutSubjectInput>
  }

  export type FacultySubjectCreateManySubjectInputEnvelope = {
    data: FacultySubjectCreateManySubjectInput | FacultySubjectCreateManySubjectInput[]
  }

  export type DepartmentUpsertWithoutSubjectsInput = {
    update: XOR<DepartmentUpdateWithoutSubjectsInput, DepartmentUncheckedUpdateWithoutSubjectsInput>
    create: XOR<DepartmentCreateWithoutSubjectsInput, DepartmentUncheckedCreateWithoutSubjectsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutSubjectsInput, DepartmentUncheckedUpdateWithoutSubjectsInput>
  }

  export type DepartmentUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designations?: DesignationUpdateManyWithoutDepartmentNestedInput
    faculty?: FacultyProfileUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    designations?: DesignationUncheckedUpdateManyWithoutDepartmentNestedInput
    faculty?: FacultyProfileUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type FacultySubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: FacultySubjectWhereUniqueInput
    update: XOR<FacultySubjectUpdateWithoutSubjectInput, FacultySubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<FacultySubjectCreateWithoutSubjectInput, FacultySubjectUncheckedCreateWithoutSubjectInput>
  }

  export type FacultySubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: FacultySubjectWhereUniqueInput
    data: XOR<FacultySubjectUpdateWithoutSubjectInput, FacultySubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type FacultySubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: FacultySubjectScalarWhereInput
    data: XOR<FacultySubjectUpdateManyMutationInput, FacultySubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type FacultyProfileCreateWithoutSubjectsInput = {
    id?: string
    fullName?: string | null
    employeeCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFacultyInput
    department?: DepartmentCreateNestedOneWithoutFacultyInput
    designation?: DesignationCreateNestedOneWithoutFacultyInput
    offerings?: CourseOfferingCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileUncheckedCreateWithoutSubjectsInput = {
    id?: string
    userId: string
    fullName?: string | null
    employeeCode?: string | null
    departmentId?: string | null
    designationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offerings?: CourseOfferingUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileCreateOrConnectWithoutSubjectsInput = {
    where: FacultyProfileWhereUniqueInput
    create: XOR<FacultyProfileCreateWithoutSubjectsInput, FacultyProfileUncheckedCreateWithoutSubjectsInput>
  }

  export type SubjectCreateWithoutFacultyInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutFacultyInput = {
    id?: string
    departmentId: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateOrConnectWithoutFacultyInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutFacultyInput, SubjectUncheckedCreateWithoutFacultyInput>
  }

  export type FacultyProfileUpsertWithoutSubjectsInput = {
    update: XOR<FacultyProfileUpdateWithoutSubjectsInput, FacultyProfileUncheckedUpdateWithoutSubjectsInput>
    create: XOR<FacultyProfileCreateWithoutSubjectsInput, FacultyProfileUncheckedCreateWithoutSubjectsInput>
    where?: FacultyProfileWhereInput
  }

  export type FacultyProfileUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: FacultyProfileWhereInput
    data: XOR<FacultyProfileUpdateWithoutSubjectsInput, FacultyProfileUncheckedUpdateWithoutSubjectsInput>
  }

  export type FacultyProfileUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFacultyNestedInput
    department?: DepartmentUpdateOneWithoutFacultyNestedInput
    designation?: DesignationUpdateOneWithoutFacultyNestedInput
    offerings?: CourseOfferingUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyProfileUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: CourseOfferingUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type SubjectUpsertWithoutFacultyInput = {
    update: XOR<SubjectUpdateWithoutFacultyInput, SubjectUncheckedUpdateWithoutFacultyInput>
    create: XOR<SubjectCreateWithoutFacultyInput, SubjectUncheckedCreateWithoutFacultyInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutFacultyInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutFacultyInput, SubjectUncheckedUpdateWithoutFacultyInput>
  }

  export type SubjectUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseOfferingCreateWithoutCourseInput = {
    id?: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty: FacultyProfileCreateNestedOneWithoutOfferingsInput
    enrollments?: EnrollmentCreateNestedManyWithoutOfferingInput
    sessions?: AttendanceSessionCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutCourseInput = {
    id?: string
    facultyId: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutOfferingInput
    sessions?: AttendanceSessionUncheckedCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutCourseInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput>
  }

  export type CourseOfferingCreateManyCourseInputEnvelope = {
    data: CourseOfferingCreateManyCourseInput | CourseOfferingCreateManyCourseInput[]
  }

  export type CourseOfferingUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseOfferingWhereUniqueInput
    update: XOR<CourseOfferingUpdateWithoutCourseInput, CourseOfferingUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseOfferingCreateWithoutCourseInput, CourseOfferingUncheckedCreateWithoutCourseInput>
  }

  export type CourseOfferingUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseOfferingWhereUniqueInput
    data: XOR<CourseOfferingUpdateWithoutCourseInput, CourseOfferingUncheckedUpdateWithoutCourseInput>
  }

  export type CourseOfferingUpdateManyWithWhereWithoutCourseInput = {
    where: CourseOfferingScalarWhereInput
    data: XOR<CourseOfferingUpdateManyMutationInput, CourseOfferingUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutOfferingsInput = {
    id?: string
    code: string
    title: string
    credits: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUncheckedCreateWithoutOfferingsInput = {
    id?: string
    code: string
    title: string
    credits: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreateOrConnectWithoutOfferingsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutOfferingsInput, CourseUncheckedCreateWithoutOfferingsInput>
  }

  export type FacultyProfileCreateWithoutOfferingsInput = {
    id?: string
    fullName?: string | null
    employeeCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFacultyInput
    department?: DepartmentCreateNestedOneWithoutFacultyInput
    designation?: DesignationCreateNestedOneWithoutFacultyInput
    subjects?: FacultySubjectCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileUncheckedCreateWithoutOfferingsInput = {
    id?: string
    userId: string
    fullName?: string | null
    employeeCode?: string | null
    departmentId?: string | null
    designationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: FacultySubjectUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyProfileCreateOrConnectWithoutOfferingsInput = {
    where: FacultyProfileWhereUniqueInput
    create: XOR<FacultyProfileCreateWithoutOfferingsInput, FacultyProfileUncheckedCreateWithoutOfferingsInput>
  }

  export type EnrollmentCreateWithoutOfferingInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutOfferingInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutOfferingInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutOfferingInput, EnrollmentUncheckedCreateWithoutOfferingInput>
  }

  export type EnrollmentCreateManyOfferingInputEnvelope = {
    data: EnrollmentCreateManyOfferingInput | EnrollmentCreateManyOfferingInput[]
  }

  export type AttendanceSessionCreateWithoutOfferingInput = {
    id?: string
    sessionDate: Date | string
    createdAt?: Date | string
    marks?: AttendanceMarkCreateNestedManyWithoutSessionInput
  }

  export type AttendanceSessionUncheckedCreateWithoutOfferingInput = {
    id?: string
    sessionDate: Date | string
    createdAt?: Date | string
    marks?: AttendanceMarkUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AttendanceSessionCreateOrConnectWithoutOfferingInput = {
    where: AttendanceSessionWhereUniqueInput
    create: XOR<AttendanceSessionCreateWithoutOfferingInput, AttendanceSessionUncheckedCreateWithoutOfferingInput>
  }

  export type AttendanceSessionCreateManyOfferingInputEnvelope = {
    data: AttendanceSessionCreateManyOfferingInput | AttendanceSessionCreateManyOfferingInput[]
  }

  export type CourseUpsertWithoutOfferingsInput = {
    update: XOR<CourseUpdateWithoutOfferingsInput, CourseUncheckedUpdateWithoutOfferingsInput>
    create: XOR<CourseCreateWithoutOfferingsInput, CourseUncheckedCreateWithoutOfferingsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutOfferingsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutOfferingsInput, CourseUncheckedUpdateWithoutOfferingsInput>
  }

  export type CourseUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyProfileUpsertWithoutOfferingsInput = {
    update: XOR<FacultyProfileUpdateWithoutOfferingsInput, FacultyProfileUncheckedUpdateWithoutOfferingsInput>
    create: XOR<FacultyProfileCreateWithoutOfferingsInput, FacultyProfileUncheckedCreateWithoutOfferingsInput>
    where?: FacultyProfileWhereInput
  }

  export type FacultyProfileUpdateToOneWithWhereWithoutOfferingsInput = {
    where?: FacultyProfileWhereInput
    data: XOR<FacultyProfileUpdateWithoutOfferingsInput, FacultyProfileUncheckedUpdateWithoutOfferingsInput>
  }

  export type FacultyProfileUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFacultyNestedInput
    department?: DepartmentUpdateOneWithoutFacultyNestedInput
    designation?: DesignationUpdateOneWithoutFacultyNestedInput
    subjects?: FacultySubjectUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyProfileUncheckedUpdateWithoutOfferingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: FacultySubjectUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutOfferingInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutOfferingInput, EnrollmentUncheckedUpdateWithoutOfferingInput>
    create: XOR<EnrollmentCreateWithoutOfferingInput, EnrollmentUncheckedCreateWithoutOfferingInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutOfferingInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutOfferingInput, EnrollmentUncheckedUpdateWithoutOfferingInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutOfferingInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutOfferingInput>
  }

  export type AttendanceSessionUpsertWithWhereUniqueWithoutOfferingInput = {
    where: AttendanceSessionWhereUniqueInput
    update: XOR<AttendanceSessionUpdateWithoutOfferingInput, AttendanceSessionUncheckedUpdateWithoutOfferingInput>
    create: XOR<AttendanceSessionCreateWithoutOfferingInput, AttendanceSessionUncheckedCreateWithoutOfferingInput>
  }

  export type AttendanceSessionUpdateWithWhereUniqueWithoutOfferingInput = {
    where: AttendanceSessionWhereUniqueInput
    data: XOR<AttendanceSessionUpdateWithoutOfferingInput, AttendanceSessionUncheckedUpdateWithoutOfferingInput>
  }

  export type AttendanceSessionUpdateManyWithWhereWithoutOfferingInput = {
    where: AttendanceSessionScalarWhereInput
    data: XOR<AttendanceSessionUpdateManyMutationInput, AttendanceSessionUncheckedUpdateManyWithoutOfferingInput>
  }

  export type AttendanceSessionScalarWhereInput = {
    AND?: AttendanceSessionScalarWhereInput | AttendanceSessionScalarWhereInput[]
    OR?: AttendanceSessionScalarWhereInput[]
    NOT?: AttendanceSessionScalarWhereInput | AttendanceSessionScalarWhereInput[]
    id?: StringFilter<"AttendanceSession"> | string
    offeringId?: StringFilter<"AttendanceSession"> | string
    sessionDate?: DateTimeFilter<"AttendanceSession"> | Date | string
    createdAt?: DateTimeFilter<"AttendanceSession"> | Date | string
  }

  export type StudentCreateWithoutEnrollmentsInput = {
    id?: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    attendanceMarks?: AttendanceMarkCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueCreateNestedManyWithoutStudentInput
    requests?: RequestCreateNestedManyWithoutStudentInput
    settings?: StudentSettingCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    userId: string
    displayId: string
    fullName: string
    programId: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    attendanceMarks?: AttendanceMarkUncheckedCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueUncheckedCreateNestedManyWithoutStudentInput
    requests?: RequestUncheckedCreateNestedManyWithoutStudentInput
    settings?: StudentSettingUncheckedCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEnrollmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
  }

  export type CourseOfferingCreateWithoutEnrollmentsInput = {
    id?: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutOfferingsInput
    faculty: FacultyProfileCreateNestedOneWithoutOfferingsInput
    sessions?: AttendanceSessionCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    courseId: string
    facultyId: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AttendanceSessionUncheckedCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutEnrollmentsInput, CourseOfferingUncheckedCreateWithoutEnrollmentsInput>
  }

  export type StudentUpsertWithoutEnrollmentsInput = {
    update: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    attendanceMarks?: AttendanceMarkUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUpdateManyWithoutStudentNestedInput
    requests?: RequestUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceMarks?: AttendanceMarkUncheckedUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUncheckedUpdateManyWithoutStudentNestedInput
    requests?: RequestUncheckedUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUncheckedUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type CourseOfferingUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseOfferingUpdateWithoutEnrollmentsInput, CourseOfferingUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseOfferingCreateWithoutEnrollmentsInput, CourseOfferingUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseOfferingWhereInput
  }

  export type CourseOfferingUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseOfferingWhereInput
    data: XOR<CourseOfferingUpdateWithoutEnrollmentsInput, CourseOfferingUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseOfferingUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutOfferingsNestedInput
    faculty?: FacultyProfileUpdateOneRequiredWithoutOfferingsNestedInput
    sessions?: AttendanceSessionUpdateManyWithoutOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AttendanceSessionUncheckedUpdateManyWithoutOfferingNestedInput
  }

  export type CourseOfferingCreateWithoutSessionsInput = {
    id?: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutOfferingsInput
    faculty: FacultyProfileCreateNestedOneWithoutOfferingsInput
    enrollments?: EnrollmentCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingUncheckedCreateWithoutSessionsInput = {
    id?: string
    courseId: string
    facultyId: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutOfferingInput
  }

  export type CourseOfferingCreateOrConnectWithoutSessionsInput = {
    where: CourseOfferingWhereUniqueInput
    create: XOR<CourseOfferingCreateWithoutSessionsInput, CourseOfferingUncheckedCreateWithoutSessionsInput>
  }

  export type AttendanceMarkCreateWithoutSessionInput = {
    id?: string
    status: $Enums.AttendanceMarkStatus
    note?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendanceMarksInput
  }

  export type AttendanceMarkUncheckedCreateWithoutSessionInput = {
    id?: string
    studentId: string
    status: $Enums.AttendanceMarkStatus
    note?: string | null
    createdAt?: Date | string
  }

  export type AttendanceMarkCreateOrConnectWithoutSessionInput = {
    where: AttendanceMarkWhereUniqueInput
    create: XOR<AttendanceMarkCreateWithoutSessionInput, AttendanceMarkUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceMarkCreateManySessionInputEnvelope = {
    data: AttendanceMarkCreateManySessionInput | AttendanceMarkCreateManySessionInput[]
  }

  export type CourseOfferingUpsertWithoutSessionsInput = {
    update: XOR<CourseOfferingUpdateWithoutSessionsInput, CourseOfferingUncheckedUpdateWithoutSessionsInput>
    create: XOR<CourseOfferingCreateWithoutSessionsInput, CourseOfferingUncheckedCreateWithoutSessionsInput>
    where?: CourseOfferingWhereInput
  }

  export type CourseOfferingUpdateToOneWithWhereWithoutSessionsInput = {
    where?: CourseOfferingWhereInput
    data: XOR<CourseOfferingUpdateWithoutSessionsInput, CourseOfferingUncheckedUpdateWithoutSessionsInput>
  }

  export type CourseOfferingUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutOfferingsNestedInput
    faculty?: FacultyProfileUpdateOneRequiredWithoutOfferingsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
  }

  export type AttendanceMarkUpsertWithWhereUniqueWithoutSessionInput = {
    where: AttendanceMarkWhereUniqueInput
    update: XOR<AttendanceMarkUpdateWithoutSessionInput, AttendanceMarkUncheckedUpdateWithoutSessionInput>
    create: XOR<AttendanceMarkCreateWithoutSessionInput, AttendanceMarkUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceMarkUpdateWithWhereUniqueWithoutSessionInput = {
    where: AttendanceMarkWhereUniqueInput
    data: XOR<AttendanceMarkUpdateWithoutSessionInput, AttendanceMarkUncheckedUpdateWithoutSessionInput>
  }

  export type AttendanceMarkUpdateManyWithWhereWithoutSessionInput = {
    where: AttendanceMarkScalarWhereInput
    data: XOR<AttendanceMarkUpdateManyMutationInput, AttendanceMarkUncheckedUpdateManyWithoutSessionInput>
  }

  export type AttendanceSessionCreateWithoutMarksInput = {
    id?: string
    sessionDate: Date | string
    createdAt?: Date | string
    offering: CourseOfferingCreateNestedOneWithoutSessionsInput
  }

  export type AttendanceSessionUncheckedCreateWithoutMarksInput = {
    id?: string
    offeringId: string
    sessionDate: Date | string
    createdAt?: Date | string
  }

  export type AttendanceSessionCreateOrConnectWithoutMarksInput = {
    where: AttendanceSessionWhereUniqueInput
    create: XOR<AttendanceSessionCreateWithoutMarksInput, AttendanceSessionUncheckedCreateWithoutMarksInput>
  }

  export type StudentCreateWithoutAttendanceMarksInput = {
    id?: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueCreateNestedManyWithoutStudentInput
    requests?: RequestCreateNestedManyWithoutStudentInput
    settings?: StudentSettingCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendanceMarksInput = {
    id?: string
    userId: string
    displayId: string
    fullName: string
    programId: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueUncheckedCreateNestedManyWithoutStudentInput
    requests?: RequestUncheckedCreateNestedManyWithoutStudentInput
    settings?: StudentSettingUncheckedCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendanceMarksInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendanceMarksInput, StudentUncheckedCreateWithoutAttendanceMarksInput>
  }

  export type AttendanceSessionUpsertWithoutMarksInput = {
    update: XOR<AttendanceSessionUpdateWithoutMarksInput, AttendanceSessionUncheckedUpdateWithoutMarksInput>
    create: XOR<AttendanceSessionCreateWithoutMarksInput, AttendanceSessionUncheckedCreateWithoutMarksInput>
    where?: AttendanceSessionWhereInput
  }

  export type AttendanceSessionUpdateToOneWithWhereWithoutMarksInput = {
    where?: AttendanceSessionWhereInput
    data: XOR<AttendanceSessionUpdateWithoutMarksInput, AttendanceSessionUncheckedUpdateWithoutMarksInput>
  }

  export type AttendanceSessionUpdateWithoutMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offering?: CourseOfferingUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type AttendanceSessionUncheckedUpdateWithoutMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpsertWithoutAttendanceMarksInput = {
    update: XOR<StudentUpdateWithoutAttendanceMarksInput, StudentUncheckedUpdateWithoutAttendanceMarksInput>
    create: XOR<StudentCreateWithoutAttendanceMarksInput, StudentUncheckedCreateWithoutAttendanceMarksInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendanceMarksInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendanceMarksInput, StudentUncheckedUpdateWithoutAttendanceMarksInput>
  }

  export type StudentUpdateWithoutAttendanceMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUpdateManyWithoutStudentNestedInput
    requests?: RequestUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendanceMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUncheckedUpdateManyWithoutStudentNestedInput
    requests?: RequestUncheckedUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUncheckedUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type LibraryCopyCreateWithoutBookInput = {
    id?: string
    barcode: string
    status?: $Enums.LibraryCopyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    issues?: LibraryIssueCreateNestedManyWithoutCopyInput
  }

  export type LibraryCopyUncheckedCreateWithoutBookInput = {
    id?: string
    barcode: string
    status?: $Enums.LibraryCopyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    issues?: LibraryIssueUncheckedCreateNestedManyWithoutCopyInput
  }

  export type LibraryCopyCreateOrConnectWithoutBookInput = {
    where: LibraryCopyWhereUniqueInput
    create: XOR<LibraryCopyCreateWithoutBookInput, LibraryCopyUncheckedCreateWithoutBookInput>
  }

  export type LibraryCopyCreateManyBookInputEnvelope = {
    data: LibraryCopyCreateManyBookInput | LibraryCopyCreateManyBookInput[]
  }

  export type LibraryCopyUpsertWithWhereUniqueWithoutBookInput = {
    where: LibraryCopyWhereUniqueInput
    update: XOR<LibraryCopyUpdateWithoutBookInput, LibraryCopyUncheckedUpdateWithoutBookInput>
    create: XOR<LibraryCopyCreateWithoutBookInput, LibraryCopyUncheckedCreateWithoutBookInput>
  }

  export type LibraryCopyUpdateWithWhereUniqueWithoutBookInput = {
    where: LibraryCopyWhereUniqueInput
    data: XOR<LibraryCopyUpdateWithoutBookInput, LibraryCopyUncheckedUpdateWithoutBookInput>
  }

  export type LibraryCopyUpdateManyWithWhereWithoutBookInput = {
    where: LibraryCopyScalarWhereInput
    data: XOR<LibraryCopyUpdateManyMutationInput, LibraryCopyUncheckedUpdateManyWithoutBookInput>
  }

  export type LibraryCopyScalarWhereInput = {
    AND?: LibraryCopyScalarWhereInput | LibraryCopyScalarWhereInput[]
    OR?: LibraryCopyScalarWhereInput[]
    NOT?: LibraryCopyScalarWhereInput | LibraryCopyScalarWhereInput[]
    id?: StringFilter<"LibraryCopy"> | string
    bookId?: StringFilter<"LibraryCopy"> | string
    barcode?: StringFilter<"LibraryCopy"> | string
    status?: EnumLibraryCopyStatusFilter<"LibraryCopy"> | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFilter<"LibraryCopy"> | Date | string
    updatedAt?: DateTimeFilter<"LibraryCopy"> | Date | string
  }

  export type LibraryBookCreateWithoutCopiesInput = {
    id?: string
    title: string
    author: string
    isbn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookUncheckedCreateWithoutCopiesInput = {
    id?: string
    title: string
    author: string
    isbn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCreateOrConnectWithoutCopiesInput = {
    where: LibraryBookWhereUniqueInput
    create: XOR<LibraryBookCreateWithoutCopiesInput, LibraryBookUncheckedCreateWithoutCopiesInput>
  }

  export type LibraryIssueCreateWithoutCopyInput = {
    id?: string
    issueDate: Date | string
    dueDate: Date | string
    returnDate?: Date | string | null
    status?: $Enums.LibraryIssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutLibraryIssuesInput
  }

  export type LibraryIssueUncheckedCreateWithoutCopyInput = {
    id?: string
    studentId: string
    issueDate: Date | string
    dueDate: Date | string
    returnDate?: Date | string | null
    status?: $Enums.LibraryIssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryIssueCreateOrConnectWithoutCopyInput = {
    where: LibraryIssueWhereUniqueInput
    create: XOR<LibraryIssueCreateWithoutCopyInput, LibraryIssueUncheckedCreateWithoutCopyInput>
  }

  export type LibraryIssueCreateManyCopyInputEnvelope = {
    data: LibraryIssueCreateManyCopyInput | LibraryIssueCreateManyCopyInput[]
  }

  export type LibraryBookUpsertWithoutCopiesInput = {
    update: XOR<LibraryBookUpdateWithoutCopiesInput, LibraryBookUncheckedUpdateWithoutCopiesInput>
    create: XOR<LibraryBookCreateWithoutCopiesInput, LibraryBookUncheckedCreateWithoutCopiesInput>
    where?: LibraryBookWhereInput
  }

  export type LibraryBookUpdateToOneWithWhereWithoutCopiesInput = {
    where?: LibraryBookWhereInput
    data: XOR<LibraryBookUpdateWithoutCopiesInput, LibraryBookUncheckedUpdateWithoutCopiesInput>
  }

  export type LibraryBookUpdateWithoutCopiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookUncheckedUpdateWithoutCopiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    isbn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryIssueUpsertWithWhereUniqueWithoutCopyInput = {
    where: LibraryIssueWhereUniqueInput
    update: XOR<LibraryIssueUpdateWithoutCopyInput, LibraryIssueUncheckedUpdateWithoutCopyInput>
    create: XOR<LibraryIssueCreateWithoutCopyInput, LibraryIssueUncheckedCreateWithoutCopyInput>
  }

  export type LibraryIssueUpdateWithWhereUniqueWithoutCopyInput = {
    where: LibraryIssueWhereUniqueInput
    data: XOR<LibraryIssueUpdateWithoutCopyInput, LibraryIssueUncheckedUpdateWithoutCopyInput>
  }

  export type LibraryIssueUpdateManyWithWhereWithoutCopyInput = {
    where: LibraryIssueScalarWhereInput
    data: XOR<LibraryIssueUpdateManyMutationInput, LibraryIssueUncheckedUpdateManyWithoutCopyInput>
  }

  export type StudentCreateWithoutLibraryIssuesInput = {
    id?: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkCreateNestedManyWithoutStudentInput
    requests?: RequestCreateNestedManyWithoutStudentInput
    settings?: StudentSettingCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutLibraryIssuesInput = {
    id?: string
    userId: string
    displayId: string
    fullName: string
    programId: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkUncheckedCreateNestedManyWithoutStudentInput
    requests?: RequestUncheckedCreateNestedManyWithoutStudentInput
    settings?: StudentSettingUncheckedCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutLibraryIssuesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutLibraryIssuesInput, StudentUncheckedCreateWithoutLibraryIssuesInput>
  }

  export type LibraryCopyCreateWithoutIssuesInput = {
    id?: string
    barcode: string
    status?: $Enums.LibraryCopyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    book: LibraryBookCreateNestedOneWithoutCopiesInput
  }

  export type LibraryCopyUncheckedCreateWithoutIssuesInput = {
    id?: string
    bookId: string
    barcode: string
    status?: $Enums.LibraryCopyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCopyCreateOrConnectWithoutIssuesInput = {
    where: LibraryCopyWhereUniqueInput
    create: XOR<LibraryCopyCreateWithoutIssuesInput, LibraryCopyUncheckedCreateWithoutIssuesInput>
  }

  export type StudentUpsertWithoutLibraryIssuesInput = {
    update: XOR<StudentUpdateWithoutLibraryIssuesInput, StudentUncheckedUpdateWithoutLibraryIssuesInput>
    create: XOR<StudentCreateWithoutLibraryIssuesInput, StudentUncheckedCreateWithoutLibraryIssuesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutLibraryIssuesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutLibraryIssuesInput, StudentUncheckedUpdateWithoutLibraryIssuesInput>
  }

  export type StudentUpdateWithoutLibraryIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUpdateManyWithoutStudentNestedInput
    requests?: RequestUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutLibraryIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUncheckedUpdateManyWithoutStudentNestedInput
    requests?: RequestUncheckedUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUncheckedUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type LibraryCopyUpsertWithoutIssuesInput = {
    update: XOR<LibraryCopyUpdateWithoutIssuesInput, LibraryCopyUncheckedUpdateWithoutIssuesInput>
    create: XOR<LibraryCopyCreateWithoutIssuesInput, LibraryCopyUncheckedCreateWithoutIssuesInput>
    where?: LibraryCopyWhereInput
  }

  export type LibraryCopyUpdateToOneWithWhereWithoutIssuesInput = {
    where?: LibraryCopyWhereInput
    data: XOR<LibraryCopyUpdateWithoutIssuesInput, LibraryCopyUncheckedUpdateWithoutIssuesInput>
  }

  export type LibraryCopyUpdateWithoutIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    status?: EnumLibraryCopyStatusFieldUpdateOperationsInput | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: LibraryBookUpdateOneRequiredWithoutCopiesNestedInput
  }

  export type LibraryCopyUncheckedUpdateWithoutIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    status?: EnumLibraryCopyStatusFieldUpdateOperationsInput | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutRequestsInput = {
    id?: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueCreateNestedManyWithoutStudentInput
    settings?: StudentSettingCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutRequestsInput = {
    id?: string
    userId: string
    displayId: string
    fullName: string
    programId: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkUncheckedCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueUncheckedCreateNestedManyWithoutStudentInput
    settings?: StudentSettingUncheckedCreateNestedOneWithoutStudentInput
    feeAccount?: FeeAccountUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutRequestsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutRequestsInput, StudentUncheckedCreateWithoutRequestsInput>
  }

  export type StudentUpsertWithoutRequestsInput = {
    update: XOR<StudentUpdateWithoutRequestsInput, StudentUncheckedUpdateWithoutRequestsInput>
    create: XOR<StudentCreateWithoutRequestsInput, StudentUncheckedCreateWithoutRequestsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutRequestsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutRequestsInput, StudentUncheckedUpdateWithoutRequestsInput>
  }

  export type StudentUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUncheckedUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUncheckedUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUncheckedUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentCreateWithoutSettingsInput = {
    id?: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueCreateNestedManyWithoutStudentInput
    requests?: RequestCreateNestedManyWithoutStudentInput
    feeAccount?: FeeAccountCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSettingsInput = {
    id?: string
    userId: string
    displayId: string
    fullName: string
    programId: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkUncheckedCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueUncheckedCreateNestedManyWithoutStudentInput
    requests?: RequestUncheckedCreateNestedManyWithoutStudentInput
    feeAccount?: FeeAccountUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSettingsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSettingsInput, StudentUncheckedCreateWithoutSettingsInput>
  }

  export type StudentUpsertWithoutSettingsInput = {
    update: XOR<StudentUpdateWithoutSettingsInput, StudentUncheckedUpdateWithoutSettingsInput>
    create: XOR<StudentCreateWithoutSettingsInput, StudentUncheckedCreateWithoutSettingsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutSettingsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutSettingsInput, StudentUncheckedUpdateWithoutSettingsInput>
  }

  export type StudentUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUpdateManyWithoutStudentNestedInput
    requests?: RequestUpdateManyWithoutStudentNestedInput
    feeAccount?: FeeAccountUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUncheckedUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUncheckedUpdateManyWithoutStudentNestedInput
    requests?: RequestUncheckedUpdateManyWithoutStudentNestedInput
    feeAccount?: FeeAccountUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentCreateWithoutFeeAccountInput = {
    id?: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    program: ProgramCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueCreateNestedManyWithoutStudentInput
    requests?: RequestCreateNestedManyWithoutStudentInput
    settings?: StudentSettingCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutFeeAccountInput = {
    id?: string
    userId: string
    displayId: string
    fullName: string
    programId: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendanceMarks?: AttendanceMarkUncheckedCreateNestedManyWithoutStudentInput
    libraryIssues?: LibraryIssueUncheckedCreateNestedManyWithoutStudentInput
    requests?: RequestUncheckedCreateNestedManyWithoutStudentInput
    settings?: StudentSettingUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFeeAccountInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFeeAccountInput, StudentUncheckedCreateWithoutFeeAccountInput>
  }

  export type FeeChargeCreateWithoutFeeAccountInput = {
    id?: string
    title: string
    amount: number
    dueDate?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type FeeChargeUncheckedCreateWithoutFeeAccountInput = {
    id?: string
    title: string
    amount: number
    dueDate?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type FeeChargeCreateOrConnectWithoutFeeAccountInput = {
    where: FeeChargeWhereUniqueInput
    create: XOR<FeeChargeCreateWithoutFeeAccountInput, FeeChargeUncheckedCreateWithoutFeeAccountInput>
  }

  export type FeeChargeCreateManyFeeAccountInputEnvelope = {
    data: FeeChargeCreateManyFeeAccountInput | FeeChargeCreateManyFeeAccountInput[]
  }

  export type FeePaymentCreateWithoutFeeAccountInput = {
    id?: string
    amount: number
    paidAt?: Date | string
    method?: string | null
    reference?: string | null
    createdAt?: Date | string
  }

  export type FeePaymentUncheckedCreateWithoutFeeAccountInput = {
    id?: string
    amount: number
    paidAt?: Date | string
    method?: string | null
    reference?: string | null
    createdAt?: Date | string
  }

  export type FeePaymentCreateOrConnectWithoutFeeAccountInput = {
    where: FeePaymentWhereUniqueInput
    create: XOR<FeePaymentCreateWithoutFeeAccountInput, FeePaymentUncheckedCreateWithoutFeeAccountInput>
  }

  export type FeePaymentCreateManyFeeAccountInputEnvelope = {
    data: FeePaymentCreateManyFeeAccountInput | FeePaymentCreateManyFeeAccountInput[]
  }

  export type StudentUpsertWithoutFeeAccountInput = {
    update: XOR<StudentUpdateWithoutFeeAccountInput, StudentUncheckedUpdateWithoutFeeAccountInput>
    create: XOR<StudentCreateWithoutFeeAccountInput, StudentUncheckedCreateWithoutFeeAccountInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFeeAccountInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFeeAccountInput, StudentUncheckedUpdateWithoutFeeAccountInput>
  }

  export type StudentUpdateWithoutFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    program?: ProgramUpdateOneRequiredWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUpdateManyWithoutStudentNestedInput
    requests?: RequestUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUncheckedUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUncheckedUpdateManyWithoutStudentNestedInput
    requests?: RequestUncheckedUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type FeeChargeUpsertWithWhereUniqueWithoutFeeAccountInput = {
    where: FeeChargeWhereUniqueInput
    update: XOR<FeeChargeUpdateWithoutFeeAccountInput, FeeChargeUncheckedUpdateWithoutFeeAccountInput>
    create: XOR<FeeChargeCreateWithoutFeeAccountInput, FeeChargeUncheckedCreateWithoutFeeAccountInput>
  }

  export type FeeChargeUpdateWithWhereUniqueWithoutFeeAccountInput = {
    where: FeeChargeWhereUniqueInput
    data: XOR<FeeChargeUpdateWithoutFeeAccountInput, FeeChargeUncheckedUpdateWithoutFeeAccountInput>
  }

  export type FeeChargeUpdateManyWithWhereWithoutFeeAccountInput = {
    where: FeeChargeScalarWhereInput
    data: XOR<FeeChargeUpdateManyMutationInput, FeeChargeUncheckedUpdateManyWithoutFeeAccountInput>
  }

  export type FeeChargeScalarWhereInput = {
    AND?: FeeChargeScalarWhereInput | FeeChargeScalarWhereInput[]
    OR?: FeeChargeScalarWhereInput[]
    NOT?: FeeChargeScalarWhereInput | FeeChargeScalarWhereInput[]
    id?: StringFilter<"FeeCharge"> | string
    feeAccountId?: StringFilter<"FeeCharge"> | string
    title?: StringFilter<"FeeCharge"> | string
    amount?: IntFilter<"FeeCharge"> | number
    dueDate?: DateTimeNullableFilter<"FeeCharge"> | Date | string | null
    status?: StringFilter<"FeeCharge"> | string
    createdAt?: DateTimeFilter<"FeeCharge"> | Date | string
  }

  export type FeePaymentUpsertWithWhereUniqueWithoutFeeAccountInput = {
    where: FeePaymentWhereUniqueInput
    update: XOR<FeePaymentUpdateWithoutFeeAccountInput, FeePaymentUncheckedUpdateWithoutFeeAccountInput>
    create: XOR<FeePaymentCreateWithoutFeeAccountInput, FeePaymentUncheckedCreateWithoutFeeAccountInput>
  }

  export type FeePaymentUpdateWithWhereUniqueWithoutFeeAccountInput = {
    where: FeePaymentWhereUniqueInput
    data: XOR<FeePaymentUpdateWithoutFeeAccountInput, FeePaymentUncheckedUpdateWithoutFeeAccountInput>
  }

  export type FeePaymentUpdateManyWithWhereWithoutFeeAccountInput = {
    where: FeePaymentScalarWhereInput
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyWithoutFeeAccountInput>
  }

  export type FeePaymentScalarWhereInput = {
    AND?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
    OR?: FeePaymentScalarWhereInput[]
    NOT?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
    id?: StringFilter<"FeePayment"> | string
    feeAccountId?: StringFilter<"FeePayment"> | string
    amount?: IntFilter<"FeePayment"> | number
    paidAt?: DateTimeFilter<"FeePayment"> | Date | string
    method?: StringNullableFilter<"FeePayment"> | string | null
    reference?: StringNullableFilter<"FeePayment"> | string | null
    createdAt?: DateTimeFilter<"FeePayment"> | Date | string
  }

  export type FeeAccountCreateWithoutChargesInput = {
    id?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFeeAccountInput
    payments?: FeePaymentCreateNestedManyWithoutFeeAccountInput
  }

  export type FeeAccountUncheckedCreateWithoutChargesInput = {
    id?: string
    studentId: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeAccountInput
  }

  export type FeeAccountCreateOrConnectWithoutChargesInput = {
    where: FeeAccountWhereUniqueInput
    create: XOR<FeeAccountCreateWithoutChargesInput, FeeAccountUncheckedCreateWithoutChargesInput>
  }

  export type FeeAccountUpsertWithoutChargesInput = {
    update: XOR<FeeAccountUpdateWithoutChargesInput, FeeAccountUncheckedUpdateWithoutChargesInput>
    create: XOR<FeeAccountCreateWithoutChargesInput, FeeAccountUncheckedCreateWithoutChargesInput>
    where?: FeeAccountWhereInput
  }

  export type FeeAccountUpdateToOneWithWhereWithoutChargesInput = {
    where?: FeeAccountWhereInput
    data: XOR<FeeAccountUpdateWithoutChargesInput, FeeAccountUncheckedUpdateWithoutChargesInput>
  }

  export type FeeAccountUpdateWithoutChargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeeAccountNestedInput
    payments?: FeePaymentUpdateManyWithoutFeeAccountNestedInput
  }

  export type FeeAccountUncheckedUpdateWithoutChargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeAccountNestedInput
  }

  export type FeeAccountCreateWithoutPaymentsInput = {
    id?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFeeAccountInput
    charges?: FeeChargeCreateNestedManyWithoutFeeAccountInput
  }

  export type FeeAccountUncheckedCreateWithoutPaymentsInput = {
    id?: string
    studentId: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    charges?: FeeChargeUncheckedCreateNestedManyWithoutFeeAccountInput
  }

  export type FeeAccountCreateOrConnectWithoutPaymentsInput = {
    where: FeeAccountWhereUniqueInput
    create: XOR<FeeAccountCreateWithoutPaymentsInput, FeeAccountUncheckedCreateWithoutPaymentsInput>
  }

  export type FeeAccountUpsertWithoutPaymentsInput = {
    update: XOR<FeeAccountUpdateWithoutPaymentsInput, FeeAccountUncheckedUpdateWithoutPaymentsInput>
    create: XOR<FeeAccountCreateWithoutPaymentsInput, FeeAccountUncheckedCreateWithoutPaymentsInput>
    where?: FeeAccountWhereInput
  }

  export type FeeAccountUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: FeeAccountWhereInput
    data: XOR<FeeAccountUpdateWithoutPaymentsInput, FeeAccountUncheckedUpdateWithoutPaymentsInput>
  }

  export type FeeAccountUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFeeAccountNestedInput
    charges?: FeeChargeUpdateManyWithoutFeeAccountNestedInput
  }

  export type FeeAccountUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    charges?: FeeChargeUncheckedUpdateManyWithoutFeeAccountNestedInput
  }

  export type StudentCreateManyProgramInput = {
    id?: string
    userId: string
    displayId: string
    fullName: string
    semester: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUpdateManyWithoutStudentNestedInput
    requests?: RequestUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendanceMarks?: AttendanceMarkUncheckedUpdateManyWithoutStudentNestedInput
    libraryIssues?: LibraryIssueUncheckedUpdateManyWithoutStudentNestedInput
    requests?: RequestUncheckedUpdateManyWithoutStudentNestedInput
    settings?: StudentSettingUncheckedUpdateOneWithoutStudentNestedInput
    feeAccount?: FeeAccountUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateManyStudentInput = {
    id?: string
    offeringId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceMarkCreateManyStudentInput = {
    id?: string
    sessionId: string
    status: $Enums.AttendanceMarkStatus
    note?: string | null
    createdAt?: Date | string
  }

  export type LibraryIssueCreateManyStudentInput = {
    id?: string
    copyId: string
    issueDate: Date | string
    dueDate: Date | string
    returnDate?: Date | string | null
    status?: $Enums.LibraryIssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCreateManyStudentInput = {
    id?: string
    displayId: string
    title: string
    description?: string | null
    status?: $Enums.RequestStatus
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offering?: CourseOfferingUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    offeringId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceMarkUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceMarkStatusFieldUpdateOperationsInput | $Enums.AttendanceMarkStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: AttendanceSessionUpdateOneRequiredWithoutMarksNestedInput
  }

  export type AttendanceMarkUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceMarkStatusFieldUpdateOperationsInput | $Enums.AttendanceMarkStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceMarkUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceMarkStatusFieldUpdateOperationsInput | $Enums.AttendanceMarkStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryIssueUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumLibraryIssueStatusFieldUpdateOperationsInput | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    copy?: LibraryCopyUpdateOneRequiredWithoutIssuesNestedInput
  }

  export type LibraryIssueUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    copyId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumLibraryIssueStatusFieldUpdateOperationsInput | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryIssueUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    copyId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumLibraryIssueStatusFieldUpdateOperationsInput | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseOfferingCreateManyFacultyInput = {
    id?: string
    courseId: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacultySubjectCreateManyFacultyInput = {
    id?: string
    subjectId: string
    createdAt?: Date | string
  }

  export type CourseOfferingUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutOfferingsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutOfferingNestedInput
    sessions?: AttendanceSessionUpdateManyWithoutOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
    sessions?: AttendanceSessionUncheckedUpdateManyWithoutOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultySubjectUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutFacultyNestedInput
  }

  export type FacultySubjectUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultySubjectUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DesignationCreateManyDepartmentInput = {
    id?: string
    title: string
    level?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManyDepartmentInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacultyProfileCreateManyDepartmentInput = {
    id?: string
    userId: string
    fullName?: string | null
    employeeCode?: string | null
    designationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DesignationUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyProfileUpdateManyWithoutDesignationNestedInput
  }

  export type DesignationUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyProfileUncheckedUpdateManyWithoutDesignationNestedInput
  }

  export type DesignationUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultySubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultySubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyProfileUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFacultyNestedInput
    designation?: DesignationUpdateOneWithoutFacultyNestedInput
    offerings?: CourseOfferingUpdateManyWithoutFacultyNestedInput
    subjects?: FacultySubjectUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyProfileUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: CourseOfferingUncheckedUpdateManyWithoutFacultyNestedInput
    subjects?: FacultySubjectUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyProfileUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    designationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyProfileCreateManyDesignationInput = {
    id?: string
    userId: string
    fullName?: string | null
    employeeCode?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacultyProfileUpdateWithoutDesignationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFacultyNestedInput
    department?: DepartmentUpdateOneWithoutFacultyNestedInput
    offerings?: CourseOfferingUpdateManyWithoutFacultyNestedInput
    subjects?: FacultySubjectUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyProfileUncheckedUpdateWithoutDesignationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offerings?: CourseOfferingUncheckedUpdateManyWithoutFacultyNestedInput
    subjects?: FacultySubjectUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyProfileUncheckedUpdateManyWithoutDesignationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultySubjectCreateManySubjectInput = {
    id?: string
    facultyId: string
    createdAt?: Date | string
  }

  export type FacultySubjectUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyProfileUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type FacultySubjectUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultySubjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseOfferingCreateManyCourseInput = {
    id?: string
    facultyId: string
    semester: number
    academicYear?: string | null
    term?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseOfferingUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyProfileUpdateOneRequiredWithoutOfferingsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutOfferingNestedInput
    sessions?: AttendanceSessionUpdateManyWithoutOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutOfferingNestedInput
    sessions?: AttendanceSessionUncheckedUpdateManyWithoutOfferingNestedInput
  }

  export type CourseOfferingUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    semester?: IntFieldUpdateOperationsInput | number
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateManyOfferingInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceSessionCreateManyOfferingInput = {
    id?: string
    sessionDate: Date | string
    createdAt?: Date | string
  }

  export type EnrollmentUpdateWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSessionUpdateWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marks?: AttendanceMarkUpdateManyWithoutSessionNestedInput
  }

  export type AttendanceSessionUncheckedUpdateWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marks?: AttendanceMarkUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AttendanceSessionUncheckedUpdateManyWithoutOfferingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceMarkCreateManySessionInput = {
    id?: string
    studentId: string
    status: $Enums.AttendanceMarkStatus
    note?: string | null
    createdAt?: Date | string
  }

  export type AttendanceMarkUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceMarkStatusFieldUpdateOperationsInput | $Enums.AttendanceMarkStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendanceMarksNestedInput
  }

  export type AttendanceMarkUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceMarkStatusFieldUpdateOperationsInput | $Enums.AttendanceMarkStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceMarkUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceMarkStatusFieldUpdateOperationsInput | $Enums.AttendanceMarkStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCopyCreateManyBookInput = {
    id?: string
    barcode: string
    status?: $Enums.LibraryCopyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCopyUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    status?: EnumLibraryCopyStatusFieldUpdateOperationsInput | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issues?: LibraryIssueUpdateManyWithoutCopyNestedInput
  }

  export type LibraryCopyUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    status?: EnumLibraryCopyStatusFieldUpdateOperationsInput | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issues?: LibraryIssueUncheckedUpdateManyWithoutCopyNestedInput
  }

  export type LibraryCopyUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    status?: EnumLibraryCopyStatusFieldUpdateOperationsInput | $Enums.LibraryCopyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryIssueCreateManyCopyInput = {
    id?: string
    studentId: string
    issueDate: Date | string
    dueDate: Date | string
    returnDate?: Date | string | null
    status?: $Enums.LibraryIssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryIssueUpdateWithoutCopyInput = {
    id?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumLibraryIssueStatusFieldUpdateOperationsInput | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutLibraryIssuesNestedInput
  }

  export type LibraryIssueUncheckedUpdateWithoutCopyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumLibraryIssueStatusFieldUpdateOperationsInput | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryIssueUncheckedUpdateManyWithoutCopyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumLibraryIssueStatusFieldUpdateOperationsInput | $Enums.LibraryIssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeChargeCreateManyFeeAccountInput = {
    id?: string
    title: string
    amount: number
    dueDate?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type FeePaymentCreateManyFeeAccountInput = {
    id?: string
    amount: number
    paidAt?: Date | string
    method?: string | null
    reference?: string | null
    createdAt?: Date | string
  }

  export type FeeChargeUpdateWithoutFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeChargeUncheckedUpdateWithoutFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeChargeUncheckedUpdateManyWithoutFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUpdateWithoutFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUncheckedUpdateWithoutFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeePaymentUncheckedUpdateManyWithoutFeeAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}